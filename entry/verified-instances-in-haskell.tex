\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}


\begin{document}

\% Verify your Typeclass Instances in Haskell Today! \% Justin Le \% April 1,
2017

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/verified-instances-in-haskell.html}{in
Code}}.}

One of the most common gripes people have when learning Haskell is the fact that
typeclass "laws" are only laws by convention, and aren't enforced by the
language and compiler. When asked why, the typical response is "Haskell can't do
that", followed by a well-intentioned redirection to quickcheck or some other
fuzzing library.

But, to any experienced Haskeller, "Haskell's type system can't express X" is
always interpreted as a (personal) challenge.

GHC Haskell's type system has been advanced enough to provide verified
typeclasses for a long time, since the introduction of data kinds and associated
types. And with the
\emph{\href{http://hackage.haskell.org/package/singletons}{singletons}} library,
it's now as easy as ever.

(The code for this post is available
\href{https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs}{here}
if you want to follow along! Some of the examples here involving \texttt{Demote}
and relying on its injectivity will only work with
\href{https://github.com/goldfirere/singletons}{singletons HEAD}, even though
the necessary patches were made seven months ago{[}\^{}shackage{]})

\section{Semigroups}

Let's start simple -\/- everyone's favorite structural addition to magmas,
\href{http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html}{semigroups}.
A semigroup is a type with an associative binary operation,
\texttt{(\textless{}\textgreater{})}:

\texttt{haskell\ class\ Semigroup\ a\ where\ \ \ \ \ (\textless{}\textgreater{})\ ::\ a\ -\textgreater{}\ a\ -\textgreater{}\ a}

Its one law is associativity:

\texttt{haskell\ (x\ \textless{}\textgreater{}\ y)\ \textless{}\textgreater{}\ z\ =\ x\ \textless{}\textgreater{}\ (y\ \textless{}\textgreater{}\ z)}

But, this class stinks, because it's super easy to write bad instances:

```haskell data List a = Nil \textbar{} Cons a (List a) deriving Show

infixr 5 \texttt{Cons}

instance Semigroup (List a) where Nil \textless{}\textgreater{} ys = ys Cons x
xs \textless{}\textgreater{} ys = Cons x (ys \textless{}\textgreater{} xs) ```

This instance isn't associative:

\texttt{haskell\ ghci\textgreater{}\ ((1\ \textasciigrave{}Cons\textasciigrave{}\ 2\ \textasciigrave{}Cons\textasciigrave{}\ Nil)\ \textless{}\textgreater{}\ (3\ \textasciigrave{}Cons\textasciigrave{}\ 4\ \textasciigrave{}Cons\textasciigrave{}\ Nil))\ \textless{}\textgreater{}\ (5\ \textasciigrave{}Cons\textasciigrave{}\ 6\ \textasciigrave{}Cons\textasciigrave{}\ Nil)\ 1\ \textasciigrave{}Cons\textasciigrave{}\ 5\ \textasciigrave{}Cons\textasciigrave{}\ 3\ \textasciigrave{}Cons\textasciigrave{}\ 6\ \textasciigrave{}Cons\textasciigrave{}\ 2\ \textasciigrave{}Cons\textasciigrave{}\ 4\ \textasciigrave{}Cons\textasciigrave{}\ Nil\ ghci\textgreater{}\ (1\ \textasciigrave{}Cons\textasciigrave{}\ 2\ \textasciigrave{}Cons\textasciigrave{}\ Nil)\ \textless{}\textgreater{}\ ((3\ \textasciigrave{}Cons\textasciigrave{}\ 4\ \textasciigrave{}Cons\textasciigrave{}\ Nil)\ \textless{}\textgreater{}\ (5\ \textasciigrave{}Cons\textasciigrave{}\ 6\ \textasciigrave{}Cons\textasciigrave{}\ Nil))\ 1\ \textasciigrave{}Cons\textasciigrave{}\ 3\ \textasciigrave{}Cons\textasciigrave{}\ 2\ \textasciigrave{}Cons\textasciigrave{}\ 5\ \textasciigrave{}Cons\textasciigrave{}\ 4\ \textasciigrave{}Cons\textasciigrave{}\ 6\ \textasciigrave{}Cons\textasciigrave{}\ Nil}

But if you try to compile it, GHC doesn't complain at all. Is this an error on
the part of Haskell? Not quite; it's an error on the part of the
\texttt{Semigroup} typeclass not requiring proofs that the instance is indeed
associative.

Let's try again.

\subsection{Verify me, Captain}

We will now define \texttt{Semigroup} on the \emph{kind} \texttt{List}, using
\texttt{-XDataKinds}, instead of the type.

```haskell class Semigroup a where type (x :: a) \textless{}\textgreater{} (y ::
a) :: a

\begin{verbatim}
(%<>) :: Sing (x :: a) -> Sing (y :: a) -> Sing (x <> y)

appendAssoc
    :: Sing (x :: a)
    -> Sing (y :: a)
    -> Sing (z :: a)
    -> ((x <> y) <> z) :~: (x <> (y <> z))
\end{verbatim}

```

Now, \texttt{\textless{}\textgreater{}} exists not as a function on
\emph{values}, but as a function on \emph{types}.
\texttt{\%\textless{}\textgreater{}} is a function that performs
\texttt{\textless{}\textgreater{}} at the value level, written to work with
singletons representing the input types, so that GHC can verify that it is
identical to the type family \texttt{\textless{}\textgreater{}}. (it's 100\%
boilerplate and should pretty much exactly match the
\texttt{\textless{}\textgreater{}} type family).{[}\^{}apdf{]} Finally,
\texttt{appendAssoc} is a proof that the type family
\texttt{\textless{}\textgreater{}} is associative, using
\texttt{:\textasciitilde{}:} (type equality witness) from
\texttt{Data.Type.Equality}.

This means that, if a type is an instance of \texttt{Semigroup}, it not only has
to provide
\texttt{\textless{}\textgreater{}}/\texttt{\%\textless{}\textgreater{}}, but
also a \emph{proof that they are associative}. You can't write the full instance
without it!

\texttt{Semigroup} is a "kind-class", because it is a bunch of methods and types
associated with a certain kind. Which \texttt{\textless{}\textgreater{}} is
dispatched when you do something like \texttt{x\ \textless{}\textgreater{}\ y}
depends on the \emph{kind} of \texttt{x} and \texttt{y}. GHC does "kind
inference" and uses the \texttt{\textless{}\textgreater{}} corresponding to the
kinds of \texttt{x} and \texttt{y}.

Using the \texttt{SingKind} typeclass from the singletons library, we can move
back and forth from \texttt{Sing\ x} and \texttt{x}, and get our original
(value-level) \texttt{\textless{}\textgreater{}} back:

\texttt{haskell\ (\textless{}\textgreater{})\ \ \ \ \ ::\ (SingKind\ m,\ Semigroup\ m)\ \ \ \ \ =\textgreater{}\ Demote\ m\ \ \ \ \ -\textgreater{}\ Demote\ m\ \ \ \ \ -\textgreater{}\ Demote\ m\ x\ \textless{}\textgreater{}\ y\ =\ withSomeSing\ x\ \$\ \textbackslash{}sX\ -\textgreater{}\ \ \ \ \ \ \ \ \ \ \ \ withSomeSing\ y\ \$\ \textbackslash{}sY\ -\textgreater{}\ \ \ \ \ \ \ \ \ \ \ \ \ \ fromSing\ (sX\ \%\textless{}\textgreater{}\ sY)}

(This works best with singletons HEAD at the moment, because \texttt{Demote} is
injective. On 2.2 or lower, using this would require an explicit type
application or annotation at any place you use
\texttt{\textless{}\textgreater{}} or \texttt{\%\textless{}\textgreater{}})

Now, let's write the instance for \texttt{List}. First, we need to define the
singletons:

\texttt{haskell\ data\ instance\ Sing\ (xs\ ::\ List\ a)\ where\ \ \ \ \ SNil\ \ ::\ Sing\ Nil\ \ \ \ \ SCons\ ::\ Sing\ x\ -\textgreater{}\ Sing\ xs\ -\textgreater{}\ Sing\ (Cons\ x\ xs)}

Then, we can define the instance, using the traditional \texttt{(++)} appending
that lists famously have:

```haskell instance Semigroup (List a) where type Nil \textless{}\textgreater{}
ys = ys type Cons x xs \textless{}\textgreater{} ys = Cons x (xs
\textless{}\textgreater{} ys)

\begin{verbatim}
SNil       %<> ys = ys
SCons x xs %<> ys = SCons x (xs %<> ys)

appendAssoc = \case
  SNil       -> \_ _ -> Refl
  SCons x xs -> \ys zs ->
    case appendAssoc xs ys zs of
      Refl -> Refl
\end{verbatim}

```

Like I promised, \texttt{\%\textless{}\textgreater{}} is a boilerplate
re-implementation of \texttt{\textless{}\textgreater{}}, to manipulate
value-level witnesses. \texttt{appendAssoc} is the interesting bit: It's our
proof. It reads like this:

\begin{enumerate}
\item
  If the first list is \texttt{Nil}:

  \texttt{haskell\ -\/-\ left\ hand\ side\ (Nil\ \textless{}\textgreater{}\ ys)\ \textless{}\textgreater{}\ zs\ \ \ =\ ys\ \textless{}\textgreater{}\ zs\ \ \ \ \ \ \ \ -\/-\ definition\ of\ \textasciigrave{}(Nil\ \textless{}\textgreater{})\textasciigrave{}\ -\/-\ right\ hand\ side\ Nil\ \textless{}\textgreater{}\ (ys\ \textless{}\textgreater{}\ zs)\ \ \ =\ ys\ \textless{}\textgreater{}\ zs\ \ \ \ \ \ \ \ -\/-\ definition\ of\ \textasciigrave{}(Nil\ \textless{}\textgreater{})\textasciigrave{}}

  So, no work needed. QED! (Or, as we say in Haskell, \texttt{Refl}!)
\item
  If the first list is \texttt{Cons\ x\ xs}:

  \texttt{haskell\ -\/-\ left\ hand\ side\ (Cons\ x\ xs\ \textless{}\textgreater{}\ ys)\ \textless{}\textgreater{}\ zs\ \ \ =\ (Cons\ x\ (xs\ \textless{}\textgreater{}\ ys))\ \textless{}\textgreater{}\ zs\ \ \ -\/-\ definition\ of\ \textasciigrave{}(Cons\ x\ xs\ \textless{}\textgreater{})\textasciigrave{}\ \ \ =\ Cons\ x\ ((xs\ \textless{}\textgreater{}\ ys)\ \textless{}\textgreater{}\ zs)\ \ \ -\/-\ definition\ of\ \textasciigrave{}(Cons\ x\ xs\ \textless{}\textgreater{})\textasciigrave{}\ -\/-\ right\ hand\ side\ Cons\ x\ xs\ \textless{}\textgreater{}\ (ys\ \textless{}\textgreater{}\ zs)\ \ \ =\ Cons\ x\ (xs\ \textless{}\textgreater{}\ (ys\ \textless{}\textgreater{}\ zs))\ \ \ -\/-\ definition\ of\ \textasciigrave{}(Cons\ x\ xs\ \textless{}\textgreater{})\textasciigrave{}}

  So, the problem reduces to proving that
  \texttt{(xs\ \textless{}\textgreater{}\ ys)\ \textless{}\textgreater{}\ zs} is
  equal to
  \texttt{xs\ \textless{}\textgreater{}\ (ys\ \textless{}\textgreater{}\ zs)}.
  If we can do that, then we can prove that the whole things are equal. We
  generate that proof using \texttt{appendAssoc\ xs\ ys\ zs}, and, wit that
  proof in scope...QED!
\end{enumerate}

And, we're done!

Note that if you had tried any \emph{non-associative} implementation of
\texttt{\textless{}\textgreater{}} (and \texttt{\%\textless{}\textgreater{}}),
GHC would reject it because you wouldn't have been able to write the proof!

\subsubsection{Automatic Singletons}

Deriving \texttt{Sing} and \texttt{SingKind} and both versions of
\texttt{\textless{}\textgreater{}} is kind of tedious, so it's useful to use
template haskell to do it all for us:

```haskell \$(singletons {[}d\textbar{} data List a = Nil \textbar{} Cons a
(List a) deriving (Show)

infixr 5 \texttt{Cons}

appendList :: List a -\textgreater{} List a -\textgreater{} List a appendList
Nil ys = ys appendList (Cons x xs) ys = Cons x (appendList xs ys) \textbar{}{]})

instance Semigroup (List a) where type xs \textless{}\textgreater{} ys =
AppendList xs ys (\%\textless{}\textgreater{}) = sAppendList

\begin{verbatim}
appendAssoc = \case
  SNil       -> \_ _ -> Refl
  SCons _ xs -> \ys zs ->
    case appendAssoc xs ys zs of
      Refl -> Refl
\end{verbatim}

```

The boilerplate of re-defining \texttt{\textless{}\textgreater{}} as
\texttt{\%\textless{}\textgreater{}} goes away!

And now, we we can do:

\texttt{haskell\ ghci\textgreater{}\ print\ \$\ ((1::Integer)\ \textasciigrave{}Cons\textasciigrave{}\ 2\ \textasciigrave{}Cons\textasciigrave{}\ Nil)\ \textless{}\textgreater{}\ (3\ \textasciigrave{}Cons\textasciigrave{}\ 4\ \textasciigrave{}Cons\textasciigrave{}\ Nil)\ 1\ \textasciigrave{}Cons\textasciigrave{}\ 2\ \textasciigrave{}Cons\textasciigrave{}\ 3\ \textasciigrave{}Cons\textasciigrave{}\ 4\ \textasciigrave{}Cons\textasciigrave{}\ Nil}

Ta dah!

\subsection{Naturally, Maybe}

Now that we have our basic infrastructure, let's implement some other famous
semigroups:

First, the inductive nats, \texttt{data\ N\ =\ Z\ \textbar{}\ S\ N:}

```haskell \$(singletons {[}d\textbar{} data N = Z \textbar{} S N deriving
(Show)

plus :: N -\textgreater{} N -\textgreater{} N plus Z y = y plus (S x) y = S
(plus x y) \textbar{}{]})

instance Semigroup N where type xs \textless{}\textgreater{} ys = Plus xs ys
(\%\textless{}\textgreater{}) = sPlus

\begin{verbatim}
appendAssoc = \case
  SZ -> \_ _ -> Refl
  SS x -> \y z ->
    case appendAssoc x y z of
      Refl -> Refl
\end{verbatim}

```

And the standard instance for \texttt{Maybe}, which lifts the underlying
semigroup:

```haskell \$(singletons {[}d\textbar{} data Option a = None \textbar{} Some a
deriving (Show) \textbar{}{]})

instance Semigroup a =\textgreater{} Semigroup (Option a) where type None
\textless{}\textgreater{} y = y type x \textless{}\textgreater{} None = x type
Some x \textless{}\textgreater{} Some y = Some (x \textless{}\textgreater{} y)

\begin{verbatim}
SNone   %<> y       = y
x       %<> SNone   = x
SSome x %<> SSome y = SSome (x %<> y)

appendAssoc = \case
    SNone   -> \_ _ -> Refl
    SSome x -> \case
      SNone -> \_ -> Refl
      SSome y -> \case
        SNone -> Refl
        SSome z ->
          case appendAssoc x y z of
            Refl -> Refl
\end{verbatim}

```

\texttt{haskell\ ghci\textgreater{}\ print\ \$\ S\ (S\ Z)\ \textless{}\textgreater{}\ S\ Z\ S\ (S\ (S\ Z))\ ghci\textgreater{}\ print\ \$\ Some\ (S\ Z)\ \textless{}\textgreater{}\ Some\ (S\ (S\ (S\ Z)))\ Some\ (S\ (S\ (S\ (S\ Z))))\ ghci\textgreater{}\ print\ \$\ None\ \ \ \ \ \ \ \textless{}\textgreater{}\ Some\ (S\ (S\ (S\ Z)))\ Some\ (S\ (S\ (S\ Z)))}

\section{Going Monoidal}

Of course, we can now introduce the \texttt{Monoid} typeclass, which introduces
a new element \texttt{empty}, along with the laws that appending with empty
leaves things unchanged:

```haskell class Semigroup a =\textgreater{} Monoid a where type Empty a :: a

\begin{verbatim}
sEmpty :: Sing (Empty a)

emptyIdentLeft
    :: Sing x
    -> (Empty a <> x) :~: x

emptyIdentRight
    :: Sing x
    -> (x <> Empty a) :~: x
\end{verbatim}

empty :: (SingKind m, Monoid m) =\textgreater{} Demote m empty = fromSing sEmpty
```

Because working implicitly return-type polymorphism at the type level can be
annoying sometimes, we have \texttt{Empty} take the \emph{kind} \texttt{a} as a
parameter, instead of having it be inferred through kind inference like we did
for \texttt{\textless{}\textgreater{}}. That is, \texttt{Empty\ (List\ a)} is
\texttt{Empty} for the \emph{kind} \texttt{List\ a}.

As usual in Haskell, the instances write themselves!

```haskell instance Monoid (List a) where type Empty (List a) = Nil

\begin{verbatim}
sEmpty = SNil
emptyIdentLeft _ = Refl
emptyIdentRight  = \case
  SNil -> Refl
  SCons _ xs ->
    case emptyIdentRight xs of
      Refl -> Refl
\end{verbatim}

instance Monoid N where type Empty N = Z

\begin{verbatim}
sEmpty = SZ
emptyIdentLeft _ = Refl
emptyIdentRight  = \case
  SZ -> Refl
  SS x -> case emptyIdentRight x of
    Refl -> Refl
\end{verbatim}

instance Semigroup a =\textgreater{} Monoid (Option a) where type Empty (Option
a) = None

\begin{verbatim}
sEmpty = SNone
emptyIdentLeft  _ = Refl
emptyIdentRight _ = Refl
\end{verbatim}

```

\section{Play that Funcy Music}

How about some higher-kinded typeclasses?

```haskell class Functor f where type Fmap a b (g :: a
\textasciitilde{}\textgreater{} b) (x :: f a) :: f b

\begin{verbatim}
sFmap
    :: Sing (g            :: a ~> b)
    -> Sing (x            :: f a   )
    -> Sing (Fmap a b g x :: f b   )

-- | fmap id x == x
fmapId
    :: Sing (x :: f a)
    -> Fmap a a IdSym0 x :~: x

-- | fmap f (fmap g x) = fmap (f . g) x
fmapCompose
    :: Sing (g :: b ~> c)
    -> Sing (h :: a ~> b)
    -> Sing (x :: f a   )
    -> Fmap b c g (Fmap a b h x) :~: Fmap a c (((:.$) @@ g) @@ h) x
\end{verbatim}

```

\texttt{Fmap\ a\ b\ g\ x} maps the \emph{type-level function}
\texttt{g\ ::\ a\ \textasciitilde{}\textgreater{}\ b} over \texttt{x\ ::\ f\ a},
and returns a type of kind \texttt{f\ b}. Like with \texttt{Empty}, to help with
kind inference, we have \texttt{Fmap} explicitly requre the \emph{kinds} of the
input and results of \texttt{g} (\texttt{a} and \texttt{b}) so GHC doesn't have
to struggle to infer it implicitly.

And, of course, along with \texttt{sFmap} (the singleton mirror of
\texttt{Fmap}), we have our laws: \texttt{fmap\ id\ x\ =\ x}, and
\texttt{fmap\ g\ (fmap\ h)\ x\ =\ fmap\ (g\ .\ h)\ x}.

But, what are \texttt{a\ \textasciitilde{}\textgreater{}\ b}, \texttt{IdSym0},
\texttt{:.\$}, and \texttt{@@}? They're a part of the \emph{defunctionalization}
system that the singletons library uses. A
\texttt{g\ ::\ a\ \textasciitilde{}\textgreater{}\ b} means that \texttt{g}
represents a type-level function taking a type of kind \texttt{a} to a type of
kind \texttt{b}, but, importantly, encodes it in a way that makes Haskell happy.
This hack is required because you can't partially apply type families in
Haskell. If \texttt{g} was a regular old \texttt{a\ -\textgreater{}\ b} type
family, you wouldn't be able to pass just \texttt{g} into \texttt{Fmap\ a\ b\ g}
(because it'd be partially applied, and type families always have to appear
fully saturated).

You can convert a \texttt{g\ ::\ a\ \textasciitilde{}\textgreater{}\ b} back
into a regular old \texttt{g\ ::\ a\ -\textgreater{}\ b} using \texttt{Apply},
or its convenient infix synonym \texttt{@@}, like
\texttt{g\ @@\ (x\ ::\ a)\ ::\ b}

The singletons library provides
\texttt{type\ family\ Id\ a\ where\ Id\ a\ =\ a}, but we can't pass in
\texttt{Id} directly into \texttt{Fmap}. We have to pass in its
"defunctionalized" encoding,
\texttt{IdSym0\ ::\ a\ \textasciitilde{}\textgreater{}\ a}.

For the composition law, we use \texttt{(:.\$)} (which is a defunctionalized
type-level \texttt{.}) and apply it to \texttt{g} and \texttt{h} to get,
essentially, \texttt{g\ :.\ h}, where \texttt{:.} is type-level function
composition.

Now we Haskell.

```haskell \$(singletons {[}d\textbar{} mapOption :: (a -\textgreater{} b)
-\textgreater{} Option a -\textgreater{} Option b mapOption \_ None = None
mapOption f (Some x) = Some (f x)

mapList :: (a -\textgreater{} b) -\textgreater{} List a -\textgreater{} List b
mapList \_ Nil = Nil mapList f (Cons x xs) = Cons (f x) (mapList f xs)
\textbar{}{]})

instance Functor Option where type Fmap a b g x = MapOption g x

\begin{verbatim}
sFmap = sMapOption
fmapId = \case
  SNone   -> Refl
  SSome _ -> Refl

fmapCompose _ _ = \case
  SNone   -> Refl
  SSome _ -> Refl
\end{verbatim}

instance Functor List where type Fmap a b g x = MapList g x

\begin{verbatim}
sFmap = sMapList
fmapId = \case
  SNil       -> Refl
  SCons _ xs ->
    case fmapId xs of
      Refl -> Refl

fmapCompose g h = \case
  SNil -> Refl
  SCons _ xs ->
    case fmapCompose g h xs of
      Refl -> Refl
\end{verbatim}

```

And there you have it. A verified \texttt{Functor} typeclass, ensuring that all
instances are lawful. Never tell me that Haskell's type system can't do anything
ever again!

Note that any mistakes in implementation (like, for example, having
\texttt{mapOption\ \_\ \_\ =\ None}) will cause a compile-time error now,
because the proofs are impossible to provide.

As a side note, I'm not quite sure how to implement the value-level
\texttt{fmap} from this, since I can't figure out how to promote functions
nicely. Using \texttt{sFmap} is the only way to work with this at the value
level that I can see, but it's probably because of my own lack of understanding.
If anyone knows how to do this, please let me know!

Anyway, what an exciting journey and a wonderful conclusion. I hope you enjoyed
this and will begin using this in your normal day-to-day Haskell. Goodbye, until
next time!

\section{Just one more}

Hah! Of course we aren't done. I wouldn't let you down like that. I know that
you probably saw that the entire last section's only purpose was to build up to
the pièce de résistance: the crown jewel of every Haskell article, the Monad.

```haskell class Functor f =\textgreater{} Monad f where type Return a (x :: a)
:: f a type Bind a b (m :: f a) (g :: a \textasciitilde{}\textgreater{} f b) ::
f b

\begin{verbatim}
sReturn
    :: Sing (x :: a)
    -> Sing (Return a x :: f a)

sBind
    :: Sing (m :: f a)
    -> Sing (g :: a ~> f b)
    -> Sing (Bind a b m g)

-- | (return x >>= f) == f x
returnIdentLeft
    :: Sing (x :: a)
    -> Sing (g :: a ~> f b)
    -> Bind a b (Return a x) g :~: (g @@ x)

-- | (m >>= return) == m
returnIdentRight
    :: Sing (m :: f a)
    -> Bind a a m ReturnSym0 :~: m

-- | m >>= (\x -> f x >>= h) == (m >>= f) >>= h
bindCompose
    :: Sing (m :: f a)
    -> Sing (g :: a ~> f b)
    -> Sing (h :: b ~> f c)
    -> Bind a c m (KCompSym2 a b c g h) :~: Bind b c (Bind a b m g) h
\end{verbatim}

data ReturnSym0 :: a \textasciitilde{}\textgreater{} f a type instance Apply
(ReturnSym0 :: a \textasciitilde{}\textgreater{} f a) (x :: a) = Return a x

type KComp a b c (g :: a \textasciitilde{}\textgreater{} f b) (h :: b
\textasciitilde{}\textgreater{} f c) (x :: a) = Bind b c (g @@ x) h data
KCompSym2 a b c g h :: (a \textasciitilde{}\textgreater{} f c) type instance
Apply (KCompSym2 a b c g h :: a \textasciitilde{}\textgreater{} f c) (x :: a) =
KComp a b c g h x

return :: (SingKind a, SingKind (f a), Monad f) =\textgreater{} Demote a
-\textgreater{} Demote (f a) return x = withSomeSing x \$ \textbackslash{}sX
-\textgreater{} fromSing (sReturn sX) ```

To help with kind inference, again, we provide explicit kind arguments for
\texttt{Return} (the kind of the thing that is being lifted) and \texttt{Bind}
(the original \texttt{a} and the resulting \texttt{b}).

Some boilerplate exists there at the bottom -\/-\/- it's the plumbing for the
defunctionalization system. \texttt{returnIdentRight} requires a
defunctionalized version of \texttt{Return}, so we can provide that by defining
\texttt{ReturnSym0}, and writing an \texttt{Apply} instance for it (which
"applies" it the parameter \texttt{x}).

We introduce \texttt{KComp} (kleisli composition) and its defunctionalized
version in order to express the third law, because we don't yet have type-level
lambdas in Haskell. The actual function it is expressing is
\texttt{\textbackslash{}x\ -\textgreater{}\ f\ x\ \textgreater{}\textgreater{}=\ g},
and that definition is given on the
\texttt{type\ KComp\ a\ b\ c\ ...\ =\ Bind\ ...} line. \texttt{KCompSym2} is the
defunctioanlized version, which is not a \texttt{a\ -\textgreater{}\ f\ c} but
rather an \texttt{a\ \textasciitilde{}\textgreater{}\ f\ c}, which allows it to
be partially applied (like we do for \texttt{composeBind}). And, finally, to
hook all of this up into the defunctionalization system, we write an
\texttt{Apply} instance yet again.

And, again, if anyone knows how I can write a value-level \texttt{Bind}, I'd
definitely appreciate hearing!

Let's see some sample implementations.

```haskell \$(singletons {[}d\textbar{} bindOption :: Option a -\textgreater{}
(a -\textgreater{} Option b) -\textgreater{} Option b bindOption None \_ = None
bindOption (Some x) f = f x

concatMapList :: (a -\textgreater{} List b) -\textgreater{} List a
-\textgreater{} List b concatMapList \_ Nil = Nil concatMapList f (Cons x xs) =
f x \texttt{appendList} concatMapList f xs \textbar{}{]})

instance Monad Option where type Return a x = Some x type Bind a b m g =
BindOption m g

\begin{verbatim}
sReturn = SSome
sBind   = sBindOption

returnIdentLeft _ _ = Refl
returnIdentRight = \case
  SNone   -> Refl
  SSome x -> case sReturn x of
    SSome _ -> Refl
bindCompose = \case
  SNone   -> \_ _ -> Refl
  SSome _ -> \_ _ -> Refl
\end{verbatim}

instance Monad List where type Return a x = PureList x type Bind a b m g =
ConcatMapList g m

\begin{verbatim}
sReturn   = sPureList
sBind x f = sConcatMapList f x

returnIdentLeft x g = case sReturn x of
  SCons y SNil -> case emptyIdentRight (unSingFun1 Proxy g y) of
    Refl -> Refl

returnIdentRight = \case
  SNil       -> Refl
  SCons _ xs -> case returnIdentRight xs of
    Refl -> Refl

bindCompose = \case
  SNil       -> \_ _ -> Refl
  SCons x xs -> \g h -> case bindCompose xs g h of
    Refl -> case unSingFun1 Proxy g x of
      SNil       -> Refl
      SCons y ys ->
        let gxs  = sConcatMapList g xs
            hgxs = sConcatMapList h gxs
            hy   = unSingFun1 Proxy h y
            hys  = sConcatMapList h ys
        in  case distribConcatMap h ys gxs of
              Refl -> case appendAssoc hy hys hgxs of
                Refl -> Refl
\end{verbatim}

-\/- \textbar{} Proving that concatMap distributes over
\textless{}\textgreater{} distribConcatMap :: Sing (g :: a
\textasciitilde{}\textgreater{} List b) -\textgreater{} Sing (xs :: List a)
-\textgreater{} Sing (ys :: List a) -\textgreater{} ConcatMapList g (xs
\textless{}\textgreater{} ys) :\textasciitilde{}: (ConcatMapList g xs
\textless{}\textgreater{} ConcatMapList g ys) distribConcatMap g =
\textbackslash{}case SNil -\textgreater{} \_ -\textgreater{} Refl SCons x xs
-\textgreater{} \textbackslash{}ys -\textgreater{} case distribConcatMap g xs ys
of Refl -\textgreater{} let gx = unSingFun1 Proxy g x cmgxs = sConcatMapList g
xs cmgys = sConcatMapList g ys in case appendAssoc gx cmgxs cmgys of Refl
-\textgreater{} Refl ```

Here we use \texttt{unSingFun1}, which converts a singleton of a type-level
function into a value-level function on singletons:

\texttt{haskell\ unSingFun1\ \ \ \ \ ::\ Proxy\ (f\ \ \ \ \ \ ::\ a\ \textasciitilde{}\textgreater{}\ b)\ \ \ \ \ -\textgreater{}\ Sing\ \ (f\ \ \ \ \ \ ::\ a\ \textasciitilde{}\textgreater{}\ b)\ \ \ \ \ -\textgreater{}\ Sing\ \ (x\ \ \ \ \ \ ::\ a)\ \ \ \ \ -\textgreater{}\ Sing\ \ (f\ @@\ x\ ::\ b)}

The \texttt{Proxy} argument only exists for historical reasons, I believe. But,
the crux is that, given a
\texttt{Sing\ (f\ ::\ a\ \textasciitilde{}\textgreater{}\ b)} and a
\texttt{Sing\ (x\ ::\ a)}, we can "apply" them to get
\texttt{Sing\ (f\ @@\ x\ ::\ b)}

The proofs for the list instance is admittedly ugly to write, due to the fact
that \texttt{List} is a recursive type. It's also tricky because Haskell has
poor to little support for theorem proving and no real tools to help you write
them efficiently. But, the proofs for \texttt{Option} are really something,
aren't they? It's kind of amazing how much GHC can do on its own without
requiring any manual proving on the part of the user.

\section{Disclaimer}

Don't do this in actual code, please
(\href{https://twitter.com/mstk/status/848677244478279680}{why?}). This post
started off as an April Fools joke that accidentally compiled correctly for
reasons which I cannot explain.

While I don't recommend that you do this in actual code, but definitely do
recommend that you do it for fun! The code in this post is available
\href{https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs}{here}
if you want to play around!

\end{document}
