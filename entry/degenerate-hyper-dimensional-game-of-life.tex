\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Degenerate Hyper-Dimensional Game of Life},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Degenerate Hyper-Dimensional Game of Life}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html}{in
Code}}.}

tldr: Over the course of a month, we were able to successive new mathematical
properties of a ``degenerate'' hyper-dimensional game of life" to take a ``10
dimensions may just barely be possible on a supercomputer'' to ``10 dimensions
is easy enough to be run on any modern browser, and 40 dimensions can be reached
with a compiled language''. Includes interactive visualizations and simulations!

This is a story about breaking the degenerate hyper-dimensional game of life by
exploratory visualizations and math! Let's travel back in time: t'was the night
before December 17, 2020, The release of
\href{https://adventofcode.com/2020/day/17}{``Conway Cubes''}, day 17 of the
``Advent of Code'' (fun little coding puzzles building up to Christmas). One
part about Advent of Code I've always found especially fun is that, because the
problems are so self-contained and tidy, they are often \emph{open-ended} in the
interesting ways you can solve them or expand them.

On the surface, Day 17 seemed to essentially be a straightforward extension of
\href{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life}{Conway's Game Of
Life} (``GoL''). GoL is a simulation played out on a 2d grid, where cells are
``on'' and ``off'', and at each step of the simulation, the on/off cells spread
and propagate in fascinating ways based on the state of their neighbors.

The twist of the Advent of Code puzzle is it asks what would happen if we played
out the rules of GoL in 3d, and then 4d! The ``starting conditions'' are a 8x8
2D grid picked out for each participant, and the puzzle solution is the number
of live cells after six steps. My personal starting conditions were:

\begin{verbatim}
#####..#
#..###.#
###.....
.#.#.#..
##.#..#.
######..
.##..###
###.####
\end{verbatim}

I submitted my answer with a direct implementation (scoring the 66th spot on the
leader board for that day)\ldots and that was that for the ``competitive'' part.
But the real fun always starts after! When discussing with some friends, we
started talking about the trade-offs of different implementations and realized
that the extra dimensionality was no joke\ldots as you upped the number of
dimensions, the number of points you have to consider grow as
\includegraphics{https://latex.codecogs.com/png.latex?O\%28\%282t\%2B6\%29\%5Ed\%29},
and the number of neighbors of each point to check grows as
\includegraphics{https://latex.codecogs.com/png.latex?O\%283\%5Ed\%29}. So for
4D it's definitely possible to solve naively\ldots but anything higher is going
to strain. My naive solution on 6D took three minutes, and 7D in a reasonable
amount of time (612,220,032 points with 2,186 neighbors each) seemed
\emph{impossible} on commercial consumer hardware because of the sheer number of
points in 7D space. But I thought\ldots what if a breakthrough in optimization
was possible? I set my goal as 10D (3,570,467,226,624 points with 59,048
neighbors each), not knowing if it was possible.

And soon\ldots a breakthrough did come! Someone brought up that if we look at
the 3d version, we see there's actually a \emph{mirror symmetry}! That is,
because everything starts off on the xy plane, with z=0, the resulting
progression must be symmetrical on both sides (positive and negative z).

\begin{figure}
\centering
\includegraphics{/img/entries/advent-gol/life3d.gif}
\caption{d=3 animation by
\href{https://www.reddit.com/r/adventofcode/comments/kfa3nr/2020_day_17_godot_cubes_i_think_i_went_a_bit_too/}{u/ZuBsPaCe}}
\end{figure}

In the end that means we only have to simulate one of the
``halves''/``quadrants'' of the higher-dimensional space, since all
``quadrants'' are identical! This saves down the number of points by a factor of
two for each extra dimension
(\includegraphics{https://latex.codecogs.com/png.latex?O\%282\%5E\%7Bd-2\%7D\%29}).
My 7D implementation completed in 6 minutes! 8D still hung forever, though.

Well, it didn't get us to d=10\ldots but this discovery completely changed how
we saw this puzzle. With one breakthrough down, we began to believe that there
would be more just around the corner, made possible by our problem's special
degeneracy (that is, that we start on a 2d slice).

Such a dream (as posed in
\href{https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/}{this
reddit thread I started}) turned into a month-long quest of breakthrough after
breakthrough, exploiting different aspects of this degeneracy! It was a long,
harrowing journey full of sudden twists and turns and bursts of excitement when
new innovations came. And in the end, the hopeful question ``What if d=10 was
possible?'' turned into ``d=10 in 100ms, d=40 in eight minutes.'' I even got
d=10 fast enough to run on easily any modern browser --- this post includes
those simulations! Furthermore, the whole journey became an adventure in the
power of visualization combined with abstract thinking.

So, let's take a deep dive --- deeper than you probably ever expected to dive
into any particular degenerate starting conditions of a hyper-dimensional game
of life :D

\hypertarget{starting-off}{%
\section{Starting Off}\label{starting-off}}

First of all, let's meet our friend for the rest of this journey. In the drawer
below, you can draw (with your mouse) the 8x8 grid you want to simulate for the
rest of this post. As you draw, the rest of the visualizations will update to
use this as their initial conditions.

\leavevmode\hypertarget{golDrawer}{}%
Please enable Javascript

And for fun, here's a 2D vanilla game of life implementation (for six time
steps) to test out your creation. I recommend trying out some of the
\href{https://en.wikipedia.org/wiki/Conway\%27s_Game_of_Life\#Examples_of_patterns}{interesting
well-known patterns}!

\leavevmode\hypertarget{gol2D}{}%
Please enable Javascript

Now that that's there, let's start at the beginning: what's the naive, baseline
solution?

A reasonable initial thought would be:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Keep a 2D (or 3D, or 4D, etc.) array of booleans.
\item
  At each step:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Make a fresh copy of the entire space
    (\includegraphics{https://latex.codecogs.com/png.latex?O\%28n\%5Ed\%29}).
  \item
    Loop over each item in your array
    (\includegraphics{https://latex.codecogs.com/png.latex?O\%28n\%5Ed\%29}).
    Count all of the neighbors
    (\includegraphics{https://latex.codecogs.com/png.latex?O\%283\%5Ed\%29})
    that are \texttt{true} (``alive''), and write to the new array based on the
    rules table of GoL (2 or 3 neighbors for a live cell stays alive, 3
    neighbors for a dead cell turns alive).
  \end{enumerate}
\item
  You have a new array! Loop again six times.
\end{enumerate}

Sounds reasonable enough! And this does work for the 2D case pretty well (like
in the \href{https://adventofcode.com/2020/day/11}{Day 11 puzzle}). However,
there are some clear issues when moving into higher dimensions. The size of your
array grows exponentially on your dimension, and so does the number of neighbors
you'd have to check. And the
\href{https://en.wikipedia.org/wiki/Curse_of_dimensionality}{curse of
dimensionality} assures us that more and more of that array would become wasted
as the proportion of ``on'' points shrinks to zero for higher dimensions.

Oh, but what's that? The percentage of ``on'' points shrinks to zero for higher
dimensions? That actually sounds like something we can use to our advantage!
The\ldots{}\emph{blessing of dimensionality}, I daresay? Because we know the
vast majority of our points will be ``off'', there's another method.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Keep a \emph{set} of points that are ``on''.
\item
  At each step:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Initialize a dynamic map (key-value store) of points to integers. This map
    associates each point to the number of live neighbors it has.
  \item
    For each step, iterate over each of your ``on'' points, expand all of their
    neighbors \includegraphics{https://latex.codecogs.com/png.latex?n_i}
    (\includegraphics{https://latex.codecogs.com/png.latex?\%28O\%283\%5Ed\%29\%29}),
    and increment the value associated with
    \includegraphics{https://latex.codecogs.com/png.latex?n_i} in your dynamic
    map.

    For example, if the point \texttt{\textless{}2,3\textgreater{}} is in your
    set of live points, you would add increment the map's values at keys
    \texttt{\textless{}1,2\textgreater{}},
    \texttt{\textless{}2,2\textgreater{}},
    \texttt{\textless{}3,2\textgreater{}}, etc.: all 8 neighbors of
    \texttt{\textless{}2,3\textgreater{}}.
  \item
    Collect your new set of on points: keep all of the keys in your dynamic map
    corresponding to live points if their integers are 2 or 3, and keep all of
    the keys in your dynamic map corresponding to dead points if their integers
    are 3.
  \end{enumerate}
\item
  You have a new set! Loop again six times!
\end{enumerate}

I discuss this algorithm much more deeply with actual code in
\href{https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day17.md}{my
solutions write-up in my Advent of Code reflections journal}.

This method nets us a huge advantage because we now only have to loop over the
number of items that we know are alive! Any points far away from our set of
alive points can be properly ignored. This narrows down our huge iteration
space, and the benefits compound with every dimension due to the blessing of
dimensionality!{[}\^{}bittweak{]}

The nice thing about this method is that it's easy enough to generalize to any
dimension: instead of, say, keeping \texttt{{[}x,y{]}} in your set for 2D, just
keep \texttt{{[}x,y,z{]}} for 3D, or any length array of coordinates. One minor
trick you need to think through is generating all
\includegraphics{https://latex.codecogs.com/png.latex?3\%5Ed-1} neighbors, but
but that's going to come down to a d-ary
\href{https://observablehq.com/@d3/d3-cross}{cartesian product} of
\texttt{{[}-1,0,1{]}} to itself.{[}\^{}crosstrick{]}

Here's a version of the set-based implementation, using a nice trick I learned
from \href{https://twitter.com/phaazon_}{phaazon} to get the right neighbors by
doing a cartesian product against \texttt{{[}0,-1,1{]}}, which leaves the first
item as the \texttt{\textless{}0,0\textgreater{}} ``original point'' we want to
exclude:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ itertools }\ImportTok{import}\NormalTok{ islice, product}
\ImportTok{from}\NormalTok{ collections }\ImportTok{import}\NormalTok{ Counter}

\KeywordTok{def}\NormalTok{ mk\_neighbs(point):}
    \CommentTok{"""Return neighboring points, each equally weighted}

\CommentTok{    (1,2)}
\CommentTok{    => [(1, 1), (1, 3), (0, 2), (0, 1), (0, 3), (2, 2), (2, 1), (2, 3)]}
\CommentTok{    """}
\NormalTok{    gen }\OperatorTok{=}\NormalTok{ product(}\OperatorTok{*}\NormalTok{[[x, x}\DecValTok{{-}1}\NormalTok{, x}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ point])}
    \CommentTok{\# skip the first item, the original point}
    \BuiltInTok{next}\NormalTok{(gen)}
    \ControlFlowTok{return}\NormalTok{ gen}

\KeywordTok{def}\NormalTok{ step(pts):}
    \CommentTok{"""Takes a set of points (tuples) and steps them in the simulation}
\CommentTok{    """}
\NormalTok{    neighbs }\OperatorTok{=}\NormalTok{ Counter()}
    \ControlFlowTok{for}\NormalTok{ point }\KeywordTok{in}\NormalTok{ pts:}
\NormalTok{        neighbs }\OperatorTok{+=}\NormalTok{ Counter(mk\_neighbs(point))}

    \KeywordTok{def}\NormalTok{ validate(point, ncount):}
        \ControlFlowTok{if}\NormalTok{ point }\KeywordTok{in}\NormalTok{ pts:}
            \ControlFlowTok{return}\NormalTok{ ncount }\OperatorTok{==} \DecValTok{2} \KeywordTok{or}\NormalTok{ ncount }\OperatorTok{==} \DecValTok{3}
        \ControlFlowTok{else}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ ncount }\OperatorTok{==} \DecValTok{3}

    \ControlFlowTok{return}\NormalTok{ [p }\ControlFlowTok{for}\NormalTok{ p, n }\KeywordTok{in}\NormalTok{ neighbs.items() }\ControlFlowTok{if}\NormalTok{ validate(p, n)]}
\end{Highlighting}
\end{Shaded}

And\ldots there's actually a neat optimization we can use (brought to our
attention by
\href{https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ghmllf8}{Peter
Tseng}) to avoid the check of the original set in step 2c above: when you
iterate over each point, increment the eight neighbors' map values by \emph{2},
and then increment the point itself by 1. Then in the final integer under each
key, \texttt{n\ /\ 2} or \texttt{n\ \textgreater{}\textgreater{}\ 1} gives you
the number of neighbors and \texttt{n\ \%\ 2} (modulo) gives you whether or not
that cell was alive.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ itertools }\ImportTok{import}\NormalTok{ islice, product, chain,repeat}
\ImportTok{from}\NormalTok{ collections }\ImportTok{import}\NormalTok{ Counter}

\KeywordTok{def}\NormalTok{ mk\_neighbs(point):}
    \CommentTok{"""Return neighboring points, with special optimization trick weights}

\CommentTok{    (1,2)}
\CommentTok{    => [((1, 2), 1), ((1, 1), 2), ((1, 3), 2), ((0, 2), 2), ((0, 1), 2),}
\CommentTok{        ((0, 3), 2), ((2, 2), 2), ((2, 1), 2), ((2, 3), 2)}
\CommentTok{       ]}
\CommentTok{    """}
\NormalTok{    neighb\_pts }\OperatorTok{=}\NormalTok{ product(}\OperatorTok{*}\NormalTok{[[x, x}\DecValTok{{-}1}\NormalTok{, x}\OperatorTok{+}\DecValTok{1}\NormalTok{] }\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ point])}
    \CommentTok{\# associate the original point with +1, and the neighbors with +2}
    \ControlFlowTok{return} \BuiltInTok{zip}\NormalTok{(neighb\_pts, chain([}\DecValTok{1}\NormalTok{], repeat(}\DecValTok{2}\NormalTok{)))}

\KeywordTok{def}\NormalTok{ step(pts):}
    \CommentTok{"""Takes a set of points (tuples) and steps them in the simulation}
\CommentTok{    """}
\NormalTok{    neighbs }\OperatorTok{=}\NormalTok{ Counter()}
    \ControlFlowTok{for}\NormalTok{ point }\KeywordTok{in}\NormalTok{ pts:}
\NormalTok{        neighbs }\OperatorTok{+=}\NormalTok{ Counter(}\BuiltInTok{dict}\NormalTok{(mk\_neighbs(point)))}

    \KeywordTok{def}\NormalTok{ validate(val):}
        \CommentTok{\# the true neighbor count, since we inserted +2 for neighbors}
\NormalTok{        ncount }\OperatorTok{=}\NormalTok{ val }\OperatorTok{//} \DecValTok{2}
        \CommentTok{\# was originally alive if odd, since we inserted +1 for self}
        \ControlFlowTok{if}\NormalTok{ val }\OperatorTok{\%} \DecValTok{2} \OperatorTok{==} \DecValTok{1}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ ncount }\OperatorTok{==} \DecValTok{2} \KeywordTok{or}\NormalTok{ ncount }\OperatorTok{==} \DecValTok{3}
        \ControlFlowTok{else}\NormalTok{:}
            \ControlFlowTok{return}\NormalTok{ ncount }\OperatorTok{==} \DecValTok{3}

    \ControlFlowTok{return}\NormalTok{ [p }\ControlFlowTok{for}\NormalTok{ p, q }\KeywordTok{in}\NormalTok{ neighbs.items() }\ControlFlowTok{if}\NormalTok{ validate(q)]}
\end{Highlighting}
\end{Shaded}

\hypertarget{three-dimensions}{%
\section{Three Dimensions}\label{three-dimensions}}

Let's see how this looks for the 3D case! To make things easier to see, we can
render things in ``slices'' in 3D space: each grid represents a slice at a
different z level (ie, the z=0 square represents all squares
\includegraphics{https://latex.codecogs.com/png.latex?\%3Cx\%2Cy\%2C0\%3E}).
Press ``Play'' to have the simulation cycle through 6 time steps!

\leavevmode\hypertarget{gol3D}{}%
Please enable Javascript

In ``reality'', each of those 13 slices above are stacked on top of each other
in 3D space. You'll see that most initial conditions will spread out from the
center z=0 point, which means they are actually spreading ``up and down'' the z
axis.

If you mouse over (or tap) any individual tiny
\texttt{\textless{}x,y\textgreater{}} cell, you'll see the all of the 26
(\includegraphics{https://latex.codecogs.com/png.latex?3\%5Ed-1})
\texttt{\textless{}x,y,z\textgreater{}} 3D neighbors of the point you're
hovering over highlighted in blue --- these 26 points form a 3D cube around your
mouse once everything is stacked correctly. You can use this cube to help see
how the simulation progresses. If your mouse is hovering over a live cell, and
there are 2 or 3 live cells highlighted in your cube, it'll stay alive in the
next time step. If your mouse is hovering over a dead cell and there are exactly
3 live cells highlighted in your cube, it will come alive in the next step.

\hypertarget{axis-reflection-symmetry}{%
\subsection{Axis Reflection Symmetry}\label{axis-reflection-symmetry}}

Try playing around with different initial conditions to see how they evolve! See
any patterns?

Well, the yellow highlight might have given given things away, but\ldots note
that the entire thing has reflection symmetry across z=0! z=1 is always the same
as z=-1, z=2 is always the same as z=-2, etc. Fundamentally, this is because our
starting solution has z-plane symmetry: the initial 2D slice is symmetric with
reflections across z, because z=0. This is the first ``degeneracy'' that this
blog post's title is referring to. The negative and positive directions are
interchangeable! This is reflected in the yellow highlight on hover: when you
mouse-over a z square, its corresponding reflected twin is highlighted, and will
always be identical.

This means that we actually only need to simulate \emph{positive} z's\ldots and
for our final answer we just ``un-reflect'' to get the total number.

Well, actually\ldots the picture is slightly more complicated. We also need to
change how to distribute neighbors. That's because, once we commit to only
keeping the positive z's, some cells need to be double-counted as neighbors. In
particular, any \texttt{z=0} cell would previously had a neighbor at both
\texttt{z=-1} and \texttt{z=1}\ldots but now if we only keep the positive z's,
it would have \texttt{z=1} as a neighbor \emph{twice}.

The following interactive element lets you explore what this looks like:

\leavevmode\hypertarget{golSyms3DForward}{}%
Please enable Javascript

Each square represents an entire ``slice'' of z. When you mouse-over or tap a
z-cell, its z-neighbors are highlighted with how many times that neighbor has to
be counted, and the green bar tells you from what direction that neighborship
arose from. For example, mousing over z=3, z=2 and z=4 get highlighted with the
values ``1'' because they are neighbors of 3, on the left and right side
(respectively). Note that one neat property for all squares (except for z=6,
which goes off the scale) is that the ``total'' higher-dimensional neighbors is
always 2
(\includegraphics{https://latex.codecogs.com/png.latex?3\%5E\%28d-2\%29-1}),
it's just that where those neighbors fall is re-arranged slightly.

The tricky square is now z=0: if you mouse-over it, you'll see that it has a
single neighbor z=1 that is counted twice, as a neighbor from both the left and
right side.

We can compute the above diagram by expanding z=0 to its neighbors (z=-1, and
z=1), applying the absolute value function, and seeing how points double-up.
This gives us the ``forward neighbors'', and we can directly use it for the
original ``keep the full array'' GoL implementation.

However, for the ``keep active points and expand their neighbors'' GoL
implementation\ldots we have to find the opposite. Remember that to build our
``neighbors map'' (the map of points to how many active neighbors they have), we
have each cell ``pro-actively'' add its contributions to all of its neighbors.
\texttt{\textless{}1,2,3\textgreater{}} is a neighbor to
\texttt{\textless{}1,3,4\textgreater{}} once, so when we expand
\texttt{\textless{}1,2,3\textgreater{}} we would increment the value in the map
at \texttt{\textless{}1,3,4\textgreater{}} by 1 because
\texttt{\textless{}1,2,3\textgreater{}} is a neighbor of
\texttt{\textless{}1,3,4\textgreater{}} once.

Now, how do we count \texttt{\textless{}1,3,1\textgreater{}} expanding into
\texttt{\textless{}1,3,0\textgreater{}}? Well, normally,
\texttt{\textless{}1,3,1\textgreater{}} is a neighbor of
\texttt{\textless{}1,3,0\textgreater{}} once. However, if we only keep the
normalized z values, \texttt{\textless{}1,3,1\textgreater{}} is a neighbor of
\texttt{\textless{}1,3,0\textgreater{}}\ldots twice! To compute the total
neighbor count of \texttt{\textless{}1,3,0\textgreater{}}, we have to count the
contribution from \texttt{\textless{}1,3,1\textgreater{}} twice (once for
\texttt{\textless{}1,3,1\textgreater{}} and once for
\texttt{\textless{}1,3,-1\textgreater{}}, which was normalized away).

That means we have to follow the rules in the previous element \emph{backwards},
like:

\leavevmode\hypertarget{golSyms3DReverse}{}%
Please enable Javascript

These are the ``reverse neighbors'': how much times a given point counts as a
neighbor for its surrounding points. Here, mousing over z=1 shows that it counts
as a neighbor for z=0 twice, from both the left and the right. It also counts as
a neighbor for z=2 once (from the left side).

We can account for this by hard-coding the rules into our step algorithm: if our
z goes from \texttt{1} to \texttt{0}, increment its value twice in the neighbor
map. Otherwise, simply increment by 1 as normal.

This rule is relatively easy to implement, and as a result we now halved our
total number of points we need to keep and check for 3D! It's also simple enough
to generalize (just do the \texttt{1\ -\textgreater{}\ 0} check for every
``higher dimension'' and double its contribution for each
\texttt{1\ -\textgreater{}\ 0} transition is seen)\ldots and that means we
reduce the number of 4D points we need to track by a factor of four, the number
of 5D points by a factor of eight, the number of 6D points by a factor of
16\ldots{} now our total points to check only grows as
\includegraphics{https://latex.codecogs.com/png.latex?O\%28n\%5Ed\%20\%2F\%202\%5E\%7Bd-2\%7D\%29}
instead of
\includegraphics{https://latex.codecogs.com/png.latex?O\%28n\%5Ed\%29}!

This discovery late in the night of December 16th was what inspired us to
believe and dream that more breakthroughs might be possible to bring things down
even further.

And those breakthroughs soon came\ldots{}

\hypertarget{four-dimensions}{%
\section{Four Dimensions}\label{four-dimensions}}

Let's look at how the 4 dimensions works! We can visualize this by taking
``z-w'' slices at different x-y planes as well. The labels in these boxes are
the \texttt{\textless{}z,w\textgreater{}} of each slice. The very center is
\texttt{\textless{}z,w\textgreater{}\ =\ \textless{}0,0\textgreater{}} the row
in the middle from the top is \texttt{w=0}, and the column in the very middle
from the left is \texttt{z=0}. It's basically taking the 3D visualization above
and expanding it in an extra dimension. Press ``Play'' to run your initial
conditions!

\leavevmode\hypertarget{gol4D}{}%
Please enable Javascript

We get something interesting as well: most initial conditions will spread out
from the center
\texttt{\textless{}z,w\textgreater{}\ =\ \textless{}0,0\textgreater{}} point
radially, spreading outwards into positive and negative z and w. Mouse-over or
tap any individual tiny \texttt{\textless{}x.y\textgreater{}} cell and you'll
see each of its 80
(\includegraphics{https://latex.codecogs.com/png.latex?3\%5Ed-1})
\texttt{\textless{}x,y,z,w\textgreater{}} 4D neighbors highlighted in blue,
forming a little 3x3x3 ``tesseract'' (4D cube, or hypercube). Like in the 3D
case, you can use this little hypercube to track how the simulation progresses:
if your mouse if hovering over a live cell with 2 or 3 live cells in its
hypercube, it'll stay alive in the next step, if it's hovering over a dead cell
with 3 live cells in its hypercube, it'll come alive in the next step.

\hypertarget{diagonal-reflection-symmetry}{%
\subsection{Diagonal Reflection Symmetry}\label{diagonal-reflection-symmetry}}

Play around and explore how simulations evolve! You will notice that the axis
reflection symmetry is still preserved, but four ways (the slice at
\texttt{\textless{}z,w\textgreater{}\ =\ \textless{}3,4\textgreater{}} is always
going to be identical to the slice at \texttt{\textless{}-3,4\textgreater{}},
\texttt{\textless{}3,-4\textgreater{}}, and
\texttt{\textless{}-3,-4\textgreater{}}). These are reflected in the ``dark
yellow'' highlights above.

(TODO)

\leavevmode\hypertarget{golFlat}{}%
Please enable Javascript

\leavevmode\hypertarget{golSyms4DForward}{}%
Please enable Javascript

\leavevmode\hypertarget{golSyms4DReverse}{}%
Please enable Javascript

\leavevmode\hypertarget{golTreeForward}{}%
Please enable Javascript

\leavevmode\hypertarget{golTreeReverse}{}%
Please enable Javascript

\leavevmode\hypertarget{golSyms5D}{}%
Please enable Javascript

\begin{verbatim}
sim642  I wanted to ask this before but forgot: did anyone try to take advantage of the symmetry, e.g. in z axis in part 1?
sim642  Should halve the amount of calculations you have to do
sim642  Only some extra work at the end to differentiate z=0 and z>0 positions to know which to count twice
sim642  And in part 2 I feel like you could also exploit the symmetry in w axis simultaneously
\end{verbatim}

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
