<!DOCTYPE HTML>
<html><head><title>Verify your Typeclass Instances in Haskell Today! · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="One of the most common gripes people have when learning Haskell is the fact that typeclass &quot;laws&quot; are only laws by convention, and aren&#39;t enforced by the language and compiler. When asked why, the typical response is &quot;Haskell can&#39;t do that&quot;, followed by a well-intentioned redirection to quickcheck or some other fuzzing library. But, to any experienced Haskeller, &quot;Haskell&#39;s type system can&#39;t express X&quot; is always interpreted as a (personal) challenge. GHC Haskell&#39;s type system has been advanced enough to provide verified typeclasses for a long time, since the introduction of data kinds and associated types. And with the singletons library, it&#39;s now as easy as ever. (The code for this post is available here if you want to follow along! Some of the examples here involving Demote and relying on its injectivity will only work with singletons HEAD, even though the necessary patches were made seven months ago[^shackage])"><meta property="og:type" content="article"><meta property="og:title" content="Verify your Typeclass Instances in Haskell Today!"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/verified-instances-in-haskell.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/verified-instances-in-haskell.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Verify your Typeclass Instances in Haskell Today!</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2017-04-01T12:25:04Z" pubdate="" class="pubdate">Saturday April 1, 2017</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/verified-instances.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/verified-instances-in-haskell.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/verified-instances-in-haskell.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>One of the most common gripes people have when learning Haskell is the fact that typeclass &quot;laws&quot; are only laws by convention, and aren't enforced by the language and compiler. When asked why, the typical response is &quot;Haskell can't do that&quot;, followed by a well-intentioned redirection to quickcheck or some other fuzzing library.</p>
<p>But, to any experienced Haskeller, &quot;Haskell's type system can't express X&quot; is always interpreted as a (personal) challenge.</p>
<p>GHC Haskell's type system has been advanced enough to provide verified typeclasses for a long time, since the introduction of data kinds and associated types. And with the <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library, it's now as easy as ever.</p>
<p>(The code for this post is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs">here</a> if you want to follow along! Some of the examples here involving <code>Demote</code> and relying on its injectivity will only work with <a href="https://github.com/goldfirere/singletons">singletons HEAD</a>, even though the necessary patches were made seven months ago[^shackage])</p>
<h2>Semigroups</h2>
<p>Let's start simple -- everyone's favorite structural addition to magmas, <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html">semigroups</a>. A semigroup is a type with an associative binary operation, <code>(&lt;&gt;)</code>:</p>
<p><code>haskell class Semigroup a where     (&lt;&gt;) :: a -&gt; a -&gt; a</code></p>
<p>Its one law is associativity:</p>
<p><code>haskell (x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</code></p>
<p>But, this class stinks, because it's super easy to write bad instances:</p>
<p>```haskell data List a = Nil | Cons a (List a) deriving Show</p>
<p>infixr 5 <code>Cons</code></p>
<p>instance Semigroup (List a) where Nil &lt;&gt; ys = ys Cons x xs &lt;&gt; ys = Cons x (ys &lt;&gt; xs) ```</p>
<p>This instance isn't associative:</p>
<p><code>haskell ghci&gt; ((1 `Cons` 2 `Cons` Nil) &lt;&gt; (3 `Cons` 4 `Cons` Nil)) &lt;&gt; (5 `Cons` 6 `Cons` Nil) 1 `Cons` 5 `Cons` 3 `Cons` 6 `Cons` 2 `Cons` 4 `Cons` Nil ghci&gt; (1 `Cons` 2 `Cons` Nil) &lt;&gt; ((3 `Cons` 4 `Cons` Nil) &lt;&gt; (5 `Cons` 6 `Cons` Nil)) 1 `Cons` 3 `Cons` 2 `Cons` 5 `Cons` 4 `Cons` 6 `Cons` Nil</code></p>
<p>But if you try to compile it, GHC doesn't complain at all. Is this an error on the part of Haskell? Not quite; it's an error on the part of the <code>Semigroup</code> typeclass not requiring proofs that the instance is indeed associative.</p>
<p>Let's try again.</p>
<h3>Verify me, Captain</h3>
<p>We will now define <code>Semigroup</code> on the <em>kind</em> <code>List</code>, using <code>-XDataKinds</code>, instead of the type.</p>
<p>```haskell class Semigroup a where type (x :: a) &lt;&gt; (y :: a) :: a</p>
<pre><code>(%&lt;&gt;) :: Sing (x :: a) -&gt; Sing (y :: a) -&gt; Sing (x &lt;&gt; y)

appendAssoc
    :: Sing (x :: a)
    -&gt; Sing (y :: a)
    -&gt; Sing (z :: a)
    -&gt; ((x &lt;&gt; y) &lt;&gt; z) :~: (x &lt;&gt; (y &lt;&gt; z))</code></pre>
<p>```</p>
<p>Now, <code>&lt;&gt;</code> exists not as a function on <em>values</em>, but as a function on <em>types</em>. <code>%&lt;&gt;</code> is a function that performs <code>&lt;&gt;</code> at the value level, written to work with singletons representing the input types, so that GHC can verify that it is identical to the type family <code>&lt;&gt;</code>. (it's 100% boilerplate and should pretty much exactly match the <code>&lt;&gt;</code> type family).[^apdf] Finally, <code>appendAssoc</code> is a proof that the type family <code>&lt;&gt;</code> is associative, using <code>:~:</code> (type equality witness) from <code>Data.Type.Equality</code>.</p>
<p>This means that, if a type is an instance of <code>Semigroup</code>, it not only has to provide <code>&lt;&gt;</code>/<code>%&lt;&gt;</code>, but also a <em>proof that they are associative</em>. You can't write the full instance without it!</p>
<p><code>Semigroup</code> is a &quot;kind-class&quot;, because it is a bunch of methods and types associated with a certain kind. Which <code>&lt;&gt;</code> is dispatched when you do something like <code>x &lt;&gt; y</code> depends on the <em>kind</em> of <code>x</code> and <code>y</code>. GHC does &quot;kind inference&quot; and uses the <code>&lt;&gt;</code> corresponding to the kinds of <code>x</code> and <code>y</code>.</p>
<p>Using the <code>SingKind</code> typeclass from the singletons library, we can move back and forth from <code>Sing x</code> and <code>x</code>, and get our original (value-level) <code>&lt;&gt;</code> back:</p>
<p><code>haskell (&lt;&gt;)     :: (SingKind m, Semigroup m)     =&gt; Demote m     -&gt; Demote m     -&gt; Demote m x &lt;&gt; y = withSomeSing x $ \sX -&gt;            withSomeSing y $ \sY -&gt;              fromSing (sX %&lt;&gt; sY)</code></p>
<p>(This works best with singletons HEAD at the moment, because <code>Demote</code> is injective. On 2.2 or lower, using this would require an explicit type application or annotation at any place you use <code>&lt;&gt;</code> or <code>%&lt;&gt;</code>)</p>
<p>Now, let's write the instance for <code>List</code>. First, we need to define the singletons:</p>
<p><code>haskell data instance Sing (xs :: List a) where     SNil  :: Sing Nil     SCons :: Sing x -&gt; Sing xs -&gt; Sing (Cons x xs)</code></p>
<p>Then, we can define the instance, using the traditional <code>(++)</code> appending that lists famously have:</p>
<p>```haskell instance Semigroup (List a) where type Nil &lt;&gt; ys = ys type Cons x xs &lt;&gt; ys = Cons x (xs &lt;&gt; ys)</p>
<pre><code>SNil       %&lt;&gt; ys = ys
SCons x xs %&lt;&gt; ys = SCons x (xs %&lt;&gt; ys)

appendAssoc = \case
  SNil       -&gt; \_ _ -&gt; Refl
  SCons x xs -&gt; \ys zs -&gt;
    case appendAssoc xs ys zs of
      Refl -&gt; Refl</code></pre>
<p>```</p>
<p>Like I promised, <code>%&lt;&gt;</code> is a boilerplate re-implementation of <code>&lt;&gt;</code>, to manipulate value-level witnesses. <code>appendAssoc</code> is the interesting bit: It's our proof. It reads like this:</p>
<ol>
<li><p>If the first list is <code>Nil</code>:</p>
<p><code>haskell -- left hand side (Nil &lt;&gt; ys) &lt;&gt; zs   = ys &lt;&gt; zs        -- definition of `(Nil &lt;&gt;)` -- right hand side Nil &lt;&gt; (ys &lt;&gt; zs)   = ys &lt;&gt; zs        -- definition of `(Nil &lt;&gt;)`</code></p>
<p>So, no work needed. QED! (Or, as we say in Haskell, <code>Refl</code>!)</p></li>
<li><p>If the first list is <code>Cons x xs</code>:</p>
<p><code>haskell -- left hand side (Cons x xs &lt;&gt; ys) &lt;&gt; zs   = (Cons x (xs &lt;&gt; ys)) &lt;&gt; zs   -- definition of `(Cons x xs &lt;&gt;)`   = Cons x ((xs &lt;&gt; ys) &lt;&gt; zs)   -- definition of `(Cons x xs &lt;&gt;)` -- right hand side Cons x xs &lt;&gt; (ys &lt;&gt; zs)   = Cons x (xs &lt;&gt; (ys &lt;&gt; zs))   -- definition of `(Cons x xs &lt;&gt;)`</code></p>
<p>So, the problem reduces to proving that <code>(xs &lt;&gt; ys) &lt;&gt; zs</code> is equal to <code>xs &lt;&gt; (ys &lt;&gt; zs)</code>. If we can do that, then we can prove that the whole things are equal. We generate that proof using <code>appendAssoc xs ys zs</code>, and, wit that proof in scope...QED!</p></li>
</ol>
<p>And, we're done!</p>
<p>Note that if you had tried any <em>non-associative</em> implementation of <code>&lt;&gt;</code> (and <code>%&lt;&gt;</code>), GHC would reject it because you wouldn't have been able to write the proof!</p>
<h4>Automatic Singletons</h4>
<p>Deriving <code>Sing</code> and <code>SingKind</code> and both versions of <code>&lt;&gt;</code> is kind of tedious, so it's useful to use template haskell to do it all for us:</p>
<p>```haskell $(singletons [d| data List a = Nil | Cons a (List a) deriving (Show)</p>
<p>infixr 5 <code>Cons</code></p>
<p>appendList :: List a -&gt; List a -&gt; List a appendList Nil ys = ys appendList (Cons x xs) ys = Cons x (appendList xs ys) |])</p>
<p>instance Semigroup (List a) where type xs &lt;&gt; ys = AppendList xs ys (%&lt;&gt;) = sAppendList</p>
<pre><code>appendAssoc = \case
  SNil       -&gt; \_ _ -&gt; Refl
  SCons _ xs -&gt; \ys zs -&gt;
    case appendAssoc xs ys zs of
      Refl -&gt; Refl</code></pre>
<p>```</p>
<p>The boilerplate of re-defining <code>&lt;&gt;</code> as <code>%&lt;&gt;</code> goes away!</p>
<p>And now, we we can do:</p>
<p><code>haskell ghci&gt; print $ ((1::Integer) `Cons` 2 `Cons` Nil) &lt;&gt; (3 `Cons` 4 `Cons` Nil) 1 `Cons` 2 `Cons` 3 `Cons` 4 `Cons` Nil</code></p>
<p>Ta dah!</p>
<h3>Naturally, Maybe</h3>
<p>Now that we have our basic infrastructure, let's implement some other famous semigroups:</p>
<p>First, the inductive nats, <code>data N = Z | S N:</code></p>
<p>```haskell $(singletons [d| data N = Z | S N deriving (Show)</p>
<p>plus :: N -&gt; N -&gt; N plus Z y = y plus (S x) y = S (plus x y) |])</p>
<p>instance Semigroup N where type xs &lt;&gt; ys = Plus xs ys (%&lt;&gt;) = sPlus</p>
<pre><code>appendAssoc = \case
  SZ -&gt; \_ _ -&gt; Refl
  SS x -&gt; \y z -&gt;
    case appendAssoc x y z of
      Refl -&gt; Refl</code></pre>
<p>```</p>
<p>And the standard instance for <code>Maybe</code>, which lifts the underlying semigroup:</p>
<p>```haskell $(singletons [d| data Option a = None | Some a deriving (Show) |])</p>
<p>instance Semigroup a =&gt; Semigroup (Option a) where type None &lt;&gt; y = y type x &lt;&gt; None = x type Some x &lt;&gt; Some y = Some (x &lt;&gt; y)</p>
<pre><code>SNone   %&lt;&gt; y       = y
x       %&lt;&gt; SNone   = x
SSome x %&lt;&gt; SSome y = SSome (x %&lt;&gt; y)

appendAssoc = \case
    SNone   -&gt; \_ _ -&gt; Refl
    SSome x -&gt; \case
      SNone -&gt; \_ -&gt; Refl
      SSome y -&gt; \case
        SNone -&gt; Refl
        SSome z -&gt;
          case appendAssoc x y z of
            Refl -&gt; Refl</code></pre>
<p>```</p>
<p><code>haskell ghci&gt; print $ S (S Z) &lt;&gt; S Z S (S (S Z)) ghci&gt; print $ Some (S Z) &lt;&gt; Some (S (S (S Z))) Some (S (S (S (S Z)))) ghci&gt; print $ None       &lt;&gt; Some (S (S (S Z))) Some (S (S (S Z)))</code></p>
<h2>Going Monoidal</h2>
<p>Of course, we can now introduce the <code>Monoid</code> typeclass, which introduces a new element <code>empty</code>, along with the laws that appending with empty leaves things unchanged:</p>
<p>```haskell class Semigroup a =&gt; Monoid a where type Empty a :: a</p>
<pre><code>sEmpty :: Sing (Empty a)

emptyIdentLeft
    :: Sing x
    -&gt; (Empty a &lt;&gt; x) :~: x

emptyIdentRight
    :: Sing x
    -&gt; (x &lt;&gt; Empty a) :~: x</code></pre>
<p>empty :: (SingKind m, Monoid m) =&gt; Demote m empty = fromSing sEmpty ```</p>
<p>Because working implicitly return-type polymorphism at the type level can be annoying sometimes, we have <code>Empty</code> take the <em>kind</em> <code>a</code> as a parameter, instead of having it be inferred through kind inference like we did for <code>&lt;&gt;</code>. That is, <code>Empty (List a)</code> is <code>Empty</code> for the <em>kind</em> <code>List a</code>.</p>
<p>As usual in Haskell, the instances write themselves!</p>
<p>```haskell instance Monoid (List a) where type Empty (List a) = Nil</p>
<pre><code>sEmpty = SNil
emptyIdentLeft _ = Refl
emptyIdentRight  = \case
  SNil -&gt; Refl
  SCons _ xs -&gt;
    case emptyIdentRight xs of
      Refl -&gt; Refl</code></pre>
<p>instance Monoid N where type Empty N = Z</p>
<pre><code>sEmpty = SZ
emptyIdentLeft _ = Refl
emptyIdentRight  = \case
  SZ -&gt; Refl
  SS x -&gt; case emptyIdentRight x of
    Refl -&gt; Refl</code></pre>
<p>instance Semigroup a =&gt; Monoid (Option a) where type Empty (Option a) = None</p>
<pre><code>sEmpty = SNone
emptyIdentLeft  _ = Refl
emptyIdentRight _ = Refl</code></pre>
<p>```</p>
<h2>Play that Funcy Music</h2>
<p>How about some higher-kinded typeclasses?</p>
<p>```haskell class Functor f where type Fmap a b (g :: a ~&gt; b) (x :: f a) :: f b</p>
<pre><code>sFmap
    :: Sing (g            :: a ~&gt; b)
    -&gt; Sing (x            :: f a   )
    -&gt; Sing (Fmap a b g x :: f b   )

-- | fmap id x == x
fmapId
    :: Sing (x :: f a)
    -&gt; Fmap a a IdSym0 x :~: x

-- | fmap f (fmap g x) = fmap (f . g) x
fmapCompose
    :: Sing (g :: b ~&gt; c)
    -&gt; Sing (h :: a ~&gt; b)
    -&gt; Sing (x :: f a   )
    -&gt; Fmap b c g (Fmap a b h x) :~: Fmap a c (((:.$) @@ g) @@ h) x</code></pre>
<p>```</p>
<p><code>Fmap a b g x</code> maps the <em>type-level function</em> <code>g :: a ~&gt; b</code> over <code>x :: f a</code>, and returns a type of kind <code>f b</code>. Like with <code>Empty</code>, to help with kind inference, we have <code>Fmap</code> explicitly requre the <em>kinds</em> of the input and results of <code>g</code> (<code>a</code> and <code>b</code>) so GHC doesn't have to struggle to infer it implicitly.</p>
<p>And, of course, along with <code>sFmap</code> (the singleton mirror of <code>Fmap</code>), we have our laws: <code>fmap id x = x</code>, and <code>fmap g (fmap h) x = fmap (g . h) x</code>.</p>
<p>But, what are <code>a ~&gt; b</code>, <code>IdSym0</code>, <code>:.$</code>, and <code>@@</code>? They're a part of the <em>defunctionalization</em> system that the singletons library uses. A <code>g :: a ~&gt; b</code> means that <code>g</code> represents a type-level function taking a type of kind <code>a</code> to a type of kind <code>b</code>, but, importantly, encodes it in a way that makes Haskell happy. This hack is required because you can't partially apply type families in Haskell. If <code>g</code> was a regular old <code>a -&gt; b</code> type family, you wouldn't be able to pass just <code>g</code> into <code>Fmap a b g</code> (because it'd be partially applied, and type families always have to appear fully saturated).</p>
<p>You can convert a <code>g :: a ~&gt; b</code> back into a regular old <code>g :: a -&gt; b</code> using <code>Apply</code>, or its convenient infix synonym <code>@@</code>, like <code>g @@ (x :: a) :: b</code></p>
<p>The singletons library provides <code>type family Id a where Id a = a</code>, but we can't pass in <code>Id</code> directly into <code>Fmap</code>. We have to pass in its &quot;defunctionalized&quot; encoding, <code>IdSym0 :: a ~&gt; a</code>.</p>
<p>For the composition law, we use <code>(:.$)</code> (which is a defunctionalized type-level <code>.</code>) and apply it to <code>g</code> and <code>h</code> to get, essentially, <code>g :. h</code>, where <code>:.</code> is type-level function composition.</p>
<p>Now we Haskell.</p>
<p>```haskell $(singletons [d| mapOption :: (a -&gt; b) -&gt; Option a -&gt; Option b mapOption _ None = None mapOption f (Some x) = Some (f x)</p>
<p>mapList :: (a -&gt; b) -&gt; List a -&gt; List b mapList _ Nil = Nil mapList f (Cons x xs) = Cons (f x) (mapList f xs) |])</p>
<p>instance Functor Option where type Fmap a b g x = MapOption g x</p>
<pre><code>sFmap = sMapOption
fmapId = \case
  SNone   -&gt; Refl
  SSome _ -&gt; Refl

fmapCompose _ _ = \case
  SNone   -&gt; Refl
  SSome _ -&gt; Refl</code></pre>
<p>instance Functor List where type Fmap a b g x = MapList g x</p>
<pre><code>sFmap = sMapList
fmapId = \case
  SNil       -&gt; Refl
  SCons _ xs -&gt;
    case fmapId xs of
      Refl -&gt; Refl

fmapCompose g h = \case
  SNil -&gt; Refl
  SCons _ xs -&gt;
    case fmapCompose g h xs of
      Refl -&gt; Refl</code></pre>
<p>```</p>
<p>And there you have it. A verified <code>Functor</code> typeclass, ensuring that all instances are lawful. Never tell me that Haskell's type system can't do anything ever again!</p>
<p>Note that any mistakes in implementation (like, for example, having <code>mapOption _ _ = None</code>) will cause a compile-time error now, because the proofs are impossible to provide.</p>
<p>As a side note, I'm not quite sure how to implement the value-level <code>fmap</code> from this, since I can't figure out how to promote functions nicely. Using <code>sFmap</code> is the only way to work with this at the value level that I can see, but it's probably because of my own lack of understanding. If anyone knows how to do this, please let me know!</p>
<p>Anyway, what an exciting journey and a wonderful conclusion. I hope you enjoyed this and will begin using this in your normal day-to-day Haskell. Goodbye, until next time!</p>
<h2>Just one more</h2>
<p>Hah! Of course we aren't done. I wouldn't let you down like that. I know that you probably saw that the entire last section's only purpose was to build up to the pièce de résistance: the crown jewel of every Haskell article, the Monad.</p>
<p>```haskell class Functor f =&gt; Monad f where type Return a (x :: a) :: f a type Bind a b (m :: f a) (g :: a ~&gt; f b) :: f b</p>
<pre><code>sReturn
    :: Sing (x :: a)
    -&gt; Sing (Return a x :: f a)

sBind
    :: Sing (m :: f a)
    -&gt; Sing (g :: a ~&gt; f b)
    -&gt; Sing (Bind a b m g)

-- | (return x &gt;&gt;= f) == f x
returnIdentLeft
    :: Sing (x :: a)
    -&gt; Sing (g :: a ~&gt; f b)
    -&gt; Bind a b (Return a x) g :~: (g @@ x)

-- | (m &gt;&gt;= return) == m
returnIdentRight
    :: Sing (m :: f a)
    -&gt; Bind a a m ReturnSym0 :~: m

-- | m &gt;&gt;= (\x -&gt; f x &gt;&gt;= h) == (m &gt;&gt;= f) &gt;&gt;= h
bindCompose
    :: Sing (m :: f a)
    -&gt; Sing (g :: a ~&gt; f b)
    -&gt; Sing (h :: b ~&gt; f c)
    -&gt; Bind a c m (KCompSym2 a b c g h) :~: Bind b c (Bind a b m g) h</code></pre>
<p>data ReturnSym0 :: a ~&gt; f a type instance Apply (ReturnSym0 :: a ~&gt; f a) (x :: a) = Return a x</p>
<p>type KComp a b c (g :: a ~&gt; f b) (h :: b ~&gt; f c) (x :: a) = Bind b c (g @@ x) h data KCompSym2 a b c g h :: (a ~&gt; f c) type instance Apply (KCompSym2 a b c g h :: a ~&gt; f c) (x :: a) = KComp a b c g h x</p>
<p>return :: (SingKind a, SingKind (f a), Monad f) =&gt; Demote a -&gt; Demote (f a) return x = withSomeSing x $ \sX -&gt; fromSing (sReturn sX) ```</p>
<p>To help with kind inference, again, we provide explicit kind arguments for <code>Return</code> (the kind of the thing that is being lifted) and <code>Bind</code> (the original <code>a</code> and the resulting <code>b</code>).</p>
<p>Some boilerplate exists there at the bottom --- it's the plumbing for the defunctionalization system. <code>returnIdentRight</code> requires a defunctionalized version of <code>Return</code>, so we can provide that by defining <code>ReturnSym0</code>, and writing an <code>Apply</code> instance for it (which &quot;applies&quot; it the parameter <code>x</code>).</p>
<p>We introduce <code>KComp</code> (kleisli composition) and its defunctionalized version in order to express the third law, because we don't yet have type-level lambdas in Haskell. The actual function it is expressing is <code>\x -&gt; f x &gt;&gt;= g</code>, and that definition is given on the <code>type KComp a b c ... = Bind ...</code> line. <code>KCompSym2</code> is the defunctioanlized version, which is not a <code>a -&gt; f c</code> but rather an <code>a ~&gt; f c</code>, which allows it to be partially applied (like we do for <code>composeBind</code>). And, finally, to hook all of this up into the defunctionalization system, we write an <code>Apply</code> instance yet again.</p>
<p>And, again, if anyone knows how I can write a value-level <code>Bind</code>, I'd definitely appreciate hearing!</p>
<p>Let's see some sample implementations.</p>
<p>```haskell $(singletons [d| bindOption :: Option a -&gt; (a -&gt; Option b) -&gt; Option b bindOption None _ = None bindOption (Some x) f = f x</p>
<p>concatMapList :: (a -&gt; List b) -&gt; List a -&gt; List b concatMapList _ Nil = Nil concatMapList f (Cons x xs) = f x <code>appendList</code> concatMapList f xs |])</p>
<p>instance Monad Option where type Return a x = Some x type Bind a b m g = BindOption m g</p>
<pre><code>sReturn = SSome
sBind   = sBindOption

returnIdentLeft _ _ = Refl
returnIdentRight = \case
  SNone   -&gt; Refl
  SSome x -&gt; case sReturn x of
    SSome _ -&gt; Refl
bindCompose = \case
  SNone   -&gt; \_ _ -&gt; Refl
  SSome _ -&gt; \_ _ -&gt; Refl</code></pre>
<p>instance Monad List where type Return a x = PureList x type Bind a b m g = ConcatMapList g m</p>
<pre><code>sReturn   = sPureList
sBind x f = sConcatMapList f x

returnIdentLeft x g = case sReturn x of
  SCons y SNil -&gt; case emptyIdentRight (unSingFun1 Proxy g y) of
    Refl -&gt; Refl

returnIdentRight = \case
  SNil       -&gt; Refl
  SCons _ xs -&gt; case returnIdentRight xs of
    Refl -&gt; Refl

bindCompose = \case
  SNil       -&gt; \_ _ -&gt; Refl
  SCons x xs -&gt; \g h -&gt; case bindCompose xs g h of
    Refl -&gt; case unSingFun1 Proxy g x of
      SNil       -&gt; Refl
      SCons y ys -&gt;
        let gxs  = sConcatMapList g xs
            hgxs = sConcatMapList h gxs
            hy   = unSingFun1 Proxy h y
            hys  = sConcatMapList h ys
        in  case distribConcatMap h ys gxs of
              Refl -&gt; case appendAssoc hy hys hgxs of
                Refl -&gt; Refl</code></pre>
<p>-- | Proving that concatMap distributes over &lt;&gt; distribConcatMap :: Sing (g :: a ~&gt; List b) -&gt; Sing (xs :: List a) -&gt; Sing (ys :: List a) -&gt; ConcatMapList g (xs &lt;&gt; ys) :~: (ConcatMapList g xs &lt;&gt; ConcatMapList g ys) distribConcatMap g = \case SNil -&gt; _ -&gt; Refl SCons x xs -&gt; \ys -&gt; case distribConcatMap g xs ys of Refl -&gt; let gx = unSingFun1 Proxy g x cmgxs = sConcatMapList g xs cmgys = sConcatMapList g ys in case appendAssoc gx cmgxs cmgys of Refl -&gt; Refl ```</p>
<p>Here we use <code>unSingFun1</code>, which converts a singleton of a type-level function into a value-level function on singletons:</p>
<p><code>haskell unSingFun1     :: Proxy (f      :: a ~&gt; b)     -&gt; Sing  (f      :: a ~&gt; b)     -&gt; Sing  (x      :: a)     -&gt; Sing  (f @@ x :: b)</code></p>
<p>The <code>Proxy</code> argument only exists for historical reasons, I believe. But, the crux is that, given a <code>Sing (f :: a ~&gt; b)</code> and a <code>Sing (x :: a)</code>, we can &quot;apply&quot; them to get <code>Sing (f @@ x :: b)</code></p>
<p>The proofs for the list instance is admittedly ugly to write, due to the fact that <code>List</code> is a recursive type. It's also tricky because Haskell has poor to little support for theorem proving and no real tools to help you write them efficiently. But, the proofs for <code>Option</code> are really something, aren't they? It's kind of amazing how much GHC can do on its own without requiring any manual proving on the part of the user.</p>
<h2>Disclaimer</h2>
<p>Don't do this in actual code, please (<a href="https://twitter.com/mstk/status/848677244478279680">why?</a>). This post started off as an April Fools joke that accidentally compiled correctly for reasons which I cannot explain.</p>
<p>While I don't recommend that you do this in actual code, but definitely do recommend that you do it for fun! The code in this post is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs">here</a> if you want to play around!</p></div><footer><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/abominations.html" class="tag-a-tag">#abominations</a></li><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/existential-types.html" class="tag-a-tag">#existential types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">Introducing the Hamilton library</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">Fixed-Length Vector Types in Haskell (an Update for 2017)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/verified-instances-in-haskell.html';
    this.page.identifier = 'verified-instances';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>