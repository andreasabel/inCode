<!DOCTYPE HTML>
<html><head><title>Verify your Typeclass Instances in Haskell Today! · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="One of the most common gripes people have when learning Haskell is the fact that typeclass “laws” are only laws by convention, and aren’t enforced by the language and compiler. When asked why, the typical response is “Haskell can’t do that”, followed by a well-intentioned redirection to quickcheck or some other fuzzing library. But, to any experienced Haskeller, “Haskell’s type system can’t express X” is always interpreted as a (personal) challenge. GHC Haskell’s type system has been advanced enough to provide verified typeclasses for a long time, since the introduction of data kinds and associated types. And with the singletons library, it’s now as easy as ever. (The code for this post is available here if you want to follow along!)"><meta property="og:type" content="article"><meta property="og:title" content="Verify your Typeclass Instances in Haskell Today!"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/verified-instances-in-haskell.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/verified-instances-in-haskell.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Verify your Typeclass Instances in Haskell Today!</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2017-04-01T12:25:04Z" pubdate="" class="pubdate">Saturday April 1, 2017</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/verified-instances.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/verified-instances-in-haskell.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/verified-instances-in-haskell.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>One of the most common gripes people have when learning Haskell is the fact that typeclass “laws” are only laws by convention, and aren’t enforced by the language and compiler. When asked why, the typical response is “Haskell can’t do that”, followed by a well-intentioned redirection to quickcheck or some other fuzzing library.</p>
<p>But, to any experienced Haskeller, “Haskell’s type system can’t express X” is always interpreted as a (personal) challenge.</p>
<p>GHC Haskell’s type system has been advanced enough to provide verified typeclasses for a long time, since the introduction of data kinds and associated types. And with the <em><a href="http://hackage.haskell.org/package/singletons">singletons</a></em> library, it’s now as easy as ever.</p>
<p>(The code for this post is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs">here</a> if you want to follow along!)</p>
<h2 id="semigroups">Semigroups</h2>
<p>Let’s start simple – everyone’s favorite structural addition to magmas, <a href="http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Semigroup.html">semigroups</a>. A semigroup is a type with an associative binary operation, <code>(&lt;&gt;)</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">    (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Its one law is associativity:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">(x <span class="fu">&lt;&gt;</span> y) <span class="fu">&lt;&gt;</span> z <span class="fu">=</span> x <span class="fu">&lt;&gt;</span> (y <span class="fu">&lt;&gt;</span> z)</a></code></pre></div>
<p>But, this class stinks, because it’s super easy to write bad instances:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">infixr</span> <span class="dv">5</span> <span class="ot">`Cons`</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="dt">Nil</span>       <span class="fu">&lt;&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="dt">Cons</span> x xs <span class="fu">&lt;&gt;</span> ys <span class="fu">=</span> <span class="dt">Cons</span> x (ys <span class="fu">&lt;&gt;</span> xs)</a></code></pre></div>
<p>This instance isn’t associative:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">ghci<span class="fu">&gt;</span> ((<span class="dv">1</span> <span class="ot">`Cons`</span> <span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>) <span class="fu">&lt;&gt;</span> (<span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dv">4</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>)) <span class="fu">&lt;&gt;</span> (<span class="dv">5</span> <span class="ot">`Cons`</span> <span class="dv">6</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">1</span> <span class="ot">`Cons`</span> <span class="dv">5</span> <span class="ot">`Cons`</span> <span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dv">6</span> <span class="ot">`Cons`</span> <span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dv">4</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">ghci<span class="fu">&gt;</span> (<span class="dv">1</span> <span class="ot">`Cons`</span> <span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>) <span class="fu">&lt;&gt;</span> ((<span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dv">4</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>) <span class="fu">&lt;&gt;</span> (<span class="dv">5</span> <span class="ot">`Cons`</span> <span class="dv">6</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">1</span> <span class="ot">`Cons`</span> <span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dv">5</span> <span class="ot">`Cons`</span> <span class="dv">4</span> <span class="ot">`Cons`</span> <span class="dv">6</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span></a></code></pre></div>
<p>But if you try to compile it, GHC doesn’t complain at all. Is this an error on the part of Haskell? Not quite; it’s an error on the part of the <code>Semigroup</code> typeclass not requiring proofs that the instance is indeed associative.</p>
<p>Let’s try again.</p>
<h3 id="verify-me-captain">Verify me, Captain</h3>
<p>We will now define <code>Semigroup</code> on the <em>kind</em> <code>List</code>, using <code>-XDataKinds</code>, instead of the type.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="kw">type</span> (<span class="ot">x ::</span> a) <span class="fu">&lt;&gt;</span> (<span class="ot">y ::</span> a)<span class="ot"> ::</span> a</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">    (%&lt;&gt;) ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> a) <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">y ::</span> a) <span class="ot">-&gt;</span> <span class="dt">Sing</span> (x <span class="fu">&lt;&gt;</span> y)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    appendAssoc</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> a)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">y ::</span> a)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">z ::</span> a)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">        <span class="ot">-&gt;</span> ((x <span class="fu">&lt;&gt;</span> y) <span class="fu">&lt;&gt;</span> z) <span class="fu">:~:</span> (x <span class="fu">&lt;&gt;</span> (y <span class="fu">&lt;&gt;</span> z))</a></code></pre></div>
<p>Now, <code>&lt;&gt;</code> exists not as a function on <em>values</em>, but as a function on <em>types</em>. <code>%&lt;&gt;</code> is a function that performs <code>&lt;&gt;</code> at the value level, written to work with singletons representing the input types, so that GHC can verify that it is identical to the type family <code>&lt;&gt;</code>. (it’s 100% boilerplate and should pretty much exactly match the <code>&lt;&gt;</code> type family).<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> Finally, <code>appendAssoc</code> is a proof that the type family <code>&lt;&gt;</code> is associative, using <code>:~:</code> (type equality witness) from <code>Data.Type.Equality</code>.</p>
<p>This means that, if a type is an instance of <code>Semigroup</code>, it not only has to provide <code>&lt;&gt;</code>/<code>%&lt;&gt;</code>, but also a <em>proof that they are associative</em>. You can’t write the full instance without it!</p>
<p><code>Semigroup</code> is a “kind-class”, because it is a bunch of methods and types associated with a certain kind. Which <code>&lt;&gt;</code> is dispatched when you do something like <code>x &lt;&gt; y</code> depends on the <em>kind</em> of <code>x</code> and <code>y</code>. GHC does “kind inference” and uses the <code>&lt;&gt;</code> corresponding to the kinds of <code>x</code> and <code>y</code>.</p>
<p>Using the <code>SingKind</code> typeclass from the singletons library, we can move back and forth from <code>Sing x</code> and <code>x</code>, and get our original (value-level) <code>&lt;&gt;</code> back:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">(<span class="fu">&lt;&gt;</span>)</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">SingKind</span> m, <span class="dt">Semigroup</span> m)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">=&gt;</span> <span class="dt">Demote</span> m</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Demote</span> m</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">Demote</span> m</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">x <span class="fu">&lt;&gt;</span> y <span class="fu">=</span> withSomeSing x <span class="fu">$</span> \sX <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">           withSomeSing y <span class="fu">$</span> \sY <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">             fromSing (sX <span class="fu">%&lt;&gt;</span> sY)</a></code></pre></div>
<p>Now, let’s write the instance for <code>List</code>. First, we need to define the singletons:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">xs ::</span> <span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="dt">SNil</span><span class="ot">  ::</span> <span class="dt">Sing</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="dt">SCons</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> xs <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Cons</span> x xs)</a></code></pre></div>
<p>Then, we can define the instance, using the traditional <code>(++)</code> appending that lists famously have:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Nil</span>       <span class="fu">&lt;&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    <span class="kw">type</span> <span class="dt">Cons</span> x xs <span class="fu">&lt;&gt;</span> ys <span class="fu">=</span> <span class="dt">Cons</span> x (xs <span class="fu">&lt;&gt;</span> ys)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="dt">SNil</span>       <span class="fu">%&lt;&gt;</span> ys <span class="fu">=</span> ys</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    <span class="dt">SCons</span> x xs <span class="fu">%&lt;&gt;</span> ys <span class="fu">=</span> <span class="dt">SCons</span> x (xs <span class="fu">%&lt;&gt;</span> ys)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    appendAssoc <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="dt">SNil</span>       <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">      <span class="dt">SCons</span> x xs <span class="ot">-&gt;</span> \ys zs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        <span class="kw">case</span> appendAssoc xs ys zs <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">          <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Like I promised, <code>%&lt;&gt;</code> is a boilerplate re-implementation of <code>&lt;&gt;</code>, to manipulate value-level witnesses. <code>appendAssoc</code> is the interesting bit: It’s our proof. It reads like this:</p>
<ol type="1">
<li><p>If the first list is <code>Nil</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- left hand side</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">(<span class="dt">Nil</span> <span class="fu">&lt;&gt;</span> ys) <span class="fu">&lt;&gt;</span> zs</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">=</span> ys <span class="fu">&lt;&gt;</span> zs        <span class="co">-- definition of `(Nil &lt;&gt;)`</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="co">-- right hand side</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="dt">Nil</span> <span class="fu">&lt;&gt;</span> (ys <span class="fu">&lt;&gt;</span> zs)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="fu">=</span> ys <span class="fu">&lt;&gt;</span> zs        <span class="co">-- definition of `(Nil &lt;&gt;)`</span></a></code></pre></div>
<p>So, no work needed. QED! (Or, as we say in Haskell, <code>Refl</code>!)</p></li>
<li><p>If the first list is <code>Cons x xs</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- left hand side</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">(<span class="dt">Cons</span> x xs <span class="fu">&lt;&gt;</span> ys) <span class="fu">&lt;&gt;</span> zs</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">=</span> (<span class="dt">Cons</span> x (xs <span class="fu">&lt;&gt;</span> ys)) <span class="fu">&lt;&gt;</span> zs   <span class="co">-- definition of `(Cons x xs &lt;&gt;)`</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">=</span> <span class="dt">Cons</span> x ((xs <span class="fu">&lt;&gt;</span> ys) <span class="fu">&lt;&gt;</span> zs)   <span class="co">-- definition of `(Cons x xs &lt;&gt;)`</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">-- right hand side</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="dt">Cons</span> x xs <span class="fu">&lt;&gt;</span> (ys <span class="fu">&lt;&gt;</span> zs)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="fu">=</span> <span class="dt">Cons</span> x (xs <span class="fu">&lt;&gt;</span> (ys <span class="fu">&lt;&gt;</span> zs))   <span class="co">-- definition of `(Cons x xs &lt;&gt;)`</span></a></code></pre></div>
<p>So, the problem reduces to proving that <code>(xs &lt;&gt; ys) &lt;&gt; zs</code> is equal to <code>xs &lt;&gt; (ys &lt;&gt; zs)</code>. If we can do that, then we can prove that the whole things are equal. We generate that proof using <code>appendAssoc xs ys zs</code>, and, wit that proof in scope…QED!</p></li>
</ol>
<p>And, we’re done!</p>
<p>Note that if you had tried any <em>non-associative</em> implementation of <code>&lt;&gt;</code> (and <code>%&lt;&gt;</code>), GHC would reject it because you wouldn’t have been able to write the proof!</p>
<h4 id="automatic-singletons">Automatic Singletons</h4>
<p>Deriving <code>Sing</code> and <code>SingKind</code> and both versions of <code>&lt;&gt;</code> is kind of tedious, so it’s useful to use template haskell to do it all for us:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  data List a = Nil | Cons a (List a)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      deriving (Show)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  infixr 5 `Cons`</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">  appendList :: List a -&gt; List a -&gt; List a</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  appendList Nil         ys = ys</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  appendList (Cons x xs) ys = Cons x (appendList xs ys)</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  |])</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="kw">type</span> xs <span class="fu">&lt;&gt;</span> ys <span class="fu">=</span> <span class="dt">AppendList</span> xs ys</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">    (<span class="fu">%&lt;&gt;</span>) <span class="fu">=</span> sAppendList</a>
<a class="sourceLine" id="cb11-15" data-line-number="15"></a>
<a class="sourceLine" id="cb11-16" data-line-number="16">    appendAssoc <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17">      <span class="dt">SNil</span>       <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">      <span class="dt">SCons</span> _ xs <span class="ot">-&gt;</span> \ys zs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-19" data-line-number="19">        <span class="kw">case</span> appendAssoc xs ys zs <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20">          <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>The boilerplate of re-defining <code>&lt;&gt;</code> as <code>%&lt;&gt;</code> goes away!</p>
<p>And now, we we can do:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">ghci<span class="fu">&gt;</span> print <span class="fu">$</span> ((<span class="dv">1</span><span class="ot">::</span><span class="dt">Integer</span>) <span class="ot">`Cons`</span> <span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>) <span class="fu">&lt;&gt;</span> (<span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dv">4</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="dv">1</span> <span class="ot">`Cons`</span> <span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dv">4</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span></a></code></pre></div>
<p>Ta dah!</p>
<h3 id="naturally-maybe">Naturally, Maybe</h3>
<p>Now that we have our basic infrastructure, let’s implement some other famous semigroups:</p>
<p>First, the inductive nats, <code>data N = Z | S N:</code></p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  data N = Z | S N</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    deriving (Show)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  plus :: N -&gt; N -&gt; N</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  plus Z     y = y</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  plus (S x) y = S (plus x y)</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  |])</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    <span class="kw">type</span> xs <span class="fu">&lt;&gt;</span> ys <span class="fu">=</span> <span class="dt">Plus</span> xs ys</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    (<span class="fu">%&lt;&gt;</span>) <span class="fu">=</span> sPlus</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    appendAssoc <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      <span class="dt">SZ</span> <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16">      <span class="dt">SS</span> x <span class="ot">-&gt;</span> \y z <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17">        <span class="kw">case</span> appendAssoc x y z <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">          <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>And the standard instance for <code>Maybe</code>, which lifts the underlying semigroup:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  data Option a = None | Some a</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">      deriving (Show)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  |])</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Option</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="kw">type</span> <span class="dt">None</span>   <span class="fu">&lt;&gt;</span> y      <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="kw">type</span> x      <span class="fu">&lt;&gt;</span> <span class="dt">None</span>   <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">    <span class="kw">type</span> <span class="dt">Some</span> x <span class="fu">&lt;&gt;</span> <span class="dt">Some</span> y <span class="fu">=</span> <span class="dt">Some</span> (x <span class="fu">&lt;&gt;</span> y)</a>
<a class="sourceLine" id="cb14-10" data-line-number="10"></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    <span class="dt">SNone</span>   <span class="fu">%&lt;&gt;</span> y       <span class="fu">=</span> y</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    x       <span class="fu">%&lt;&gt;</span> <span class="dt">SNone</span>   <span class="fu">=</span> x</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    <span class="dt">SSome</span> x <span class="fu">%&lt;&gt;</span> <span class="dt">SSome</span> y <span class="fu">=</span> <span class="dt">SSome</span> (x <span class="fu">%&lt;&gt;</span> y)</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"></a>
<a class="sourceLine" id="cb14-15" data-line-number="15">    appendAssoc <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb14-16" data-line-number="16">        <span class="dt">SNone</span>   <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">        <span class="dt">SSome</span> x <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb14-18" data-line-number="18">          <span class="dt">SNone</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19">          <span class="dt">SSome</span> y <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb14-20" data-line-number="20">            <span class="dt">SNone</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb14-21" data-line-number="21">            <span class="dt">SSome</span> z <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-22" data-line-number="22">              <span class="kw">case</span> appendAssoc x y z <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-23" data-line-number="23">                <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">ghci<span class="fu">&gt;</span> print <span class="fu">$</span> <span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="fu">&lt;&gt;</span> <span class="dt">S</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">ghci<span class="fu">&gt;</span> print <span class="fu">$</span> <span class="dt">Some</span> (<span class="dt">S</span> <span class="dt">Z</span>) <span class="fu">&lt;&gt;</span> <span class="dt">Some</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="dt">Some</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>))))</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">ghci<span class="fu">&gt;</span> print <span class="fu">$</span> <span class="dt">None</span>       <span class="fu">&lt;&gt;</span> <span class="dt">Some</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="dt">Some</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</a></code></pre></div>
<h2 id="going-monoidal">Going Monoidal</h2>
<p>Of course, we can now introduce the <code>Monoid</code> typeclass, which introduces a new element <code>empty</code>, along with the laws that appending with empty leaves things unchanged:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Empty</span><span class="ot"> a ::</span> a</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">    sEmpty ::</span> <span class="dt">Sing</span> (<span class="dt">Empty</span> a)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    emptyIdentLeft</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="ot">        ::</span> <span class="dt">Sing</span> x</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">        <span class="ot">-&gt;</span> (<span class="dt">Empty</span> a <span class="fu">&lt;&gt;</span> x) <span class="fu">:~:</span> x</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">    emptyIdentRight</a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="ot">        ::</span> <span class="dt">Sing</span> x</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">        <span class="ot">-&gt;</span> (x <span class="fu">&lt;&gt;</span> <span class="dt">Empty</span> a) <span class="fu">:~:</span> x</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">empty</a>
<a class="sourceLine" id="cb16-15" data-line-number="15"><span class="ot">    ::</span> (<span class="dt">SingKind</span> m, <span class="dt">Monoid</span> m)</a>
<a class="sourceLine" id="cb16-16" data-line-number="16">    <span class="ot">=&gt;</span> <span class="dt">Demote</span> m</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">empty <span class="fu">=</span> fromSing sEmpty</a></code></pre></div>
<p>Because working implicitly return-type polymorphism at the type level can be annoying sometimes, we have <code>Empty</code> take the <em>kind</em> <code>a</code> as a parameter, instead of having it be inferred through kind inference like we did for <code>&lt;&gt;</code>. That is, <code>Empty (List a)</code> is <code>Empty</code> for the <em>kind</em> <code>List a</code>.</p>
<p>As usual in Haskell, the instances write themselves!</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">List</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Empty</span> (<span class="dt">List</span> a) <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">    sEmpty <span class="fu">=</span> <span class="dt">SNil</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    emptyIdentLeft _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    emptyIdentRight  <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">      <span class="dt">SNil</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">      <span class="dt">SCons</span> _ xs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">        <span class="kw">case</span> emptyIdentRight xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">          <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11"></a>
<a class="sourceLine" id="cb17-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">N</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">    <span class="kw">type</span> <span class="dt">Empty</span> <span class="dt">N</span> <span class="fu">=</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14"></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">    sEmpty <span class="fu">=</span> <span class="dt">SZ</span></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">    emptyIdentLeft _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-17" data-line-number="17">    emptyIdentRight  <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb17-18" data-line-number="18">      <span class="dt">SZ</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-19" data-line-number="19">      <span class="dt">SS</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> emptyIdentRight x <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-21" data-line-number="21"></a>
<a class="sourceLine" id="cb17-22" data-line-number="22"><span class="kw">instance</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Option</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-23" data-line-number="23">    <span class="kw">type</span> <span class="dt">Empty</span> (<span class="dt">Option</span> a) <span class="fu">=</span> <span class="dt">None</span></a>
<a class="sourceLine" id="cb17-24" data-line-number="24"></a>
<a class="sourceLine" id="cb17-25" data-line-number="25">    sEmpty <span class="fu">=</span> <span class="dt">SNone</span></a>
<a class="sourceLine" id="cb17-26" data-line-number="26">    emptyIdentLeft  _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb17-27" data-line-number="27">    emptyIdentRight _ <span class="fu">=</span> <span class="dt">Refl</span></a></code></pre></div>
<h2 id="play-that-funcy-music">Play that Funcy Music</h2>
<p>How about some higher-kinded typeclasses?</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Fmap</span> a b (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> b) (<span class="ot">x ::</span> f a)<span class="ot"> ::</span> f b</a>
<a class="sourceLine" id="cb18-3" data-line-number="3"></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">    sFmap</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">g            ::</span> a <span class="fu">~&gt;</span> b)</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">x            ::</span> f a   )</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Fmap</span> a b g<span class="ot"> x ::</span> f b   )</a>
<a class="sourceLine" id="cb18-8" data-line-number="8"></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    <span class="co">-- | fmap id x == x</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">    fmapId</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> f a)</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">        <span class="ot">-&gt;</span> <span class="dt">Fmap</span> a a <span class="dt">IdSym0</span> x <span class="fu">:~:</span> x</a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">    <span class="co">-- | fmap f (fmap g x) = fmap (f . g) x</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">    fmapCompose</a>
<a class="sourceLine" id="cb18-16" data-line-number="16"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">g ::</span> b <span class="fu">~&gt;</span> c)</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">h ::</span> a <span class="fu">~&gt;</span> b)</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> f a   )</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">        <span class="ot">-&gt;</span> <span class="dt">Fmap</span> b c g (<span class="dt">Fmap</span> a b h x) <span class="fu">:~:</span> <span class="dt">Fmap</span> a c (((<span class="fu">:.$</span>) <span class="fu">@@</span> g) <span class="fu">@@</span> h) x</a></code></pre></div>
<p><code>Fmap a b g x</code> maps the <em>type-level function</em> <code>g :: a ~&gt; b</code> over <code>x :: f a</code>, and returns a type of kind <code>f b</code>. Like with <code>Empty</code>, to help with kind inference, we have <code>Fmap</code> explicitly requre the <em>kinds</em> of the input and results of <code>g</code> (<code>a</code> and <code>b</code>) so GHC doesn’t have to struggle to infer it implicitly.</p>
<p>And, of course, along with <code>sFmap</code> (the singleton mirror of <code>Fmap</code>), we have our laws: <code>fmap id x = x</code>, and <code>fmap g (fmap h) x = fmap (g . h) x</code>.</p>
<p>But, what are <code>a ~&gt; b</code>, <code>IdSym0</code>, <code>:.$</code>, and <code>@@</code>? They’re a part of the <em>defunctionalization</em> system that the singletons library uses. A <code>g :: a ~&gt; b</code> means that <code>g</code> represents a type-level function taking a type of kind <code>a</code> to a type of kind <code>b</code>, but, importantly, encodes it in a way that makes Haskell happy. This hack is required because you can’t partially apply type families in Haskell. If <code>g</code> was a regular old <code>a -&gt; b</code> type family, you wouldn’t be able to pass just <code>g</code> into <code>Fmap a b g</code> (because it’d be partially applied, and type families always have to appear fully saturated).</p>
<p>You can convert a <code>g :: a ~&gt; b</code> back into a regular old <code>g :: a -&gt; b</code> using <code>Apply</code>, or its convenient infix synonym <code>@@</code>, like <code>g @@ (x :: a) :: b</code></p>
<p>The singletons library provides <code>type family Id a where Id a = a</code>, but we can’t pass in <code>Id</code> directly into <code>Fmap</code>. We have to pass in its “defunctionalized” encoding, <code>IdSym0 :: a ~&gt; a</code>.</p>
<p>For the composition law, we use <code>(:.$)</code> (which is a defunctionalized type-level <code>.</code>) and apply it to <code>g</code> and <code>h</code> to get, essentially, <code>g :. h</code>, where <code>:.</code> is type-level function composition.</p>
<p>Now we Haskell.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  mapOption :: (a -&gt; b) -&gt; Option a -&gt; Option b</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  mapOption _ None     = None</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  mapOption f (Some x) = Some (f x)</a>
<a class="sourceLine" id="cb19-5" data-line-number="5"></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  mapList :: (a -&gt; b) -&gt; List a -&gt; List b</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  mapList _ Nil         = Nil</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  mapList f (Cons x xs) = Cons (f x) (mapList f xs)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">  |])</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"></a>
<a class="sourceLine" id="cb19-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Option</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">    <span class="kw">type</span> <span class="dt">Fmap</span> a b g x <span class="fu">=</span> <span class="dt">MapOption</span> g x</a>
<a class="sourceLine" id="cb19-13" data-line-number="13"></a>
<a class="sourceLine" id="cb19-14" data-line-number="14">    sFmap <span class="fu">=</span> sMapOption</a>
<a class="sourceLine" id="cb19-15" data-line-number="15">    fmapId <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb19-16" data-line-number="16">      <span class="dt">SNone</span>   <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-17" data-line-number="17">      <span class="dt">SSome</span> _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-18" data-line-number="18"></a>
<a class="sourceLine" id="cb19-19" data-line-number="19">    fmapCompose _ _ <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb19-20" data-line-number="20">      <span class="dt">SNone</span>   <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-21" data-line-number="21">      <span class="dt">SSome</span> _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-22" data-line-number="22"></a>
<a class="sourceLine" id="cb19-23" data-line-number="23"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-24" data-line-number="24">    <span class="kw">type</span> <span class="dt">Fmap</span> a b g x <span class="fu">=</span> <span class="dt">MapList</span> g x</a>
<a class="sourceLine" id="cb19-25" data-line-number="25"></a>
<a class="sourceLine" id="cb19-26" data-line-number="26">    sFmap <span class="fu">=</span> sMapList</a>
<a class="sourceLine" id="cb19-27" data-line-number="27">    fmapId <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb19-28" data-line-number="28">      <span class="dt">SNil</span>       <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-29" data-line-number="29">      <span class="dt">SCons</span> _ xs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-30" data-line-number="30">        <span class="kw">case</span> fmapId xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-31" data-line-number="31">          <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-32" data-line-number="32"></a>
<a class="sourceLine" id="cb19-33" data-line-number="33">    fmapCompose g h <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb19-34" data-line-number="34">      <span class="dt">SNil</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb19-35" data-line-number="35">      <span class="dt">SCons</span> _ xs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-36" data-line-number="36">        <span class="kw">case</span> fmapCompose g h xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-37" data-line-number="37">          <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>And there you have it. A verified <code>Functor</code> typeclass, ensuring that all instances are lawful. Never tell me that Haskell’s type system can’t do anything ever again!</p>
<p>Note that any mistakes in implementation (like, for example, having <code>mapOption _ _ = None</code>) will cause a compile-time error now, because the proofs are impossible to provide.</p>
<p>As a side note, I’m not quite sure how to implement the value-level <code>fmap</code> from this, since I can’t figure out how to promote functions nicely. Using <code>sFmap</code> is the only way to work with this at the value level that I can see, but it’s probably because of my own lack of understanding. If anyone knows how to do this, please let me know!</p>
<p>Anyway, what an exciting journey and a wonderful conclusion. I hope you enjoyed this and will begin using this in your normal day-to-day Haskell. Goodbye, until next time!</p>
<h2 id="just-one-more">Just one more</h2>
<p>Hah! Of course we aren’t done. I wouldn’t let you down like that. I know that you probably saw that the entire last section’s only purpose was to build up to the pièce de résistance: the crown jewel of every Haskell article, the Monad.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    <span class="kw">type</span> <span class="dt">Return</span> a   (<span class="ot">x ::</span> a)<span class="ot">                   ::</span> f a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">    <span class="kw">type</span> <span class="dt">Bind</span>   a b (<span class="ot">m ::</span> f a) (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> f b)<span class="ot"> ::</span> f b</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    sReturn</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> a)</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Return</span> a<span class="ot"> x ::</span> f a)</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">    sBind</a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">m ::</span> f a)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> f b)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">Bind</span> a b m g)</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">    <span class="co">-- | (return x &gt;&gt;= f) == f x</span></a>
<a class="sourceLine" id="cb20-15" data-line-number="15">    returnIdentLeft</a>
<a class="sourceLine" id="cb20-16" data-line-number="16"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">x ::</span> a)</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> f b)</a>
<a class="sourceLine" id="cb20-18" data-line-number="18">        <span class="ot">-&gt;</span> <span class="dt">Bind</span> a b (<span class="dt">Return</span> a x) g <span class="fu">:~:</span> (g <span class="fu">@@</span> x)</a>
<a class="sourceLine" id="cb20-19" data-line-number="19"></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">    <span class="co">-- | (m &gt;&gt;= return) == m</span></a>
<a class="sourceLine" id="cb20-21" data-line-number="21">    returnIdentRight</a>
<a class="sourceLine" id="cb20-22" data-line-number="22"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">m ::</span> f a)</a>
<a class="sourceLine" id="cb20-23" data-line-number="23">        <span class="ot">-&gt;</span> <span class="dt">Bind</span> a a m <span class="dt">ReturnSym0</span> <span class="fu">:~:</span> m</a>
<a class="sourceLine" id="cb20-24" data-line-number="24"></a>
<a class="sourceLine" id="cb20-25" data-line-number="25">    <span class="co">-- | m &gt;&gt;= (\x -&gt; f x &gt;&gt;= h) == (m &gt;&gt;= f) &gt;&gt;= h</span></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">    bindCompose</a>
<a class="sourceLine" id="cb20-27" data-line-number="27"><span class="ot">        ::</span> <span class="dt">Sing</span> (<span class="ot">m ::</span> f a)</a>
<a class="sourceLine" id="cb20-28" data-line-number="28">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> f b)</a>
<a class="sourceLine" id="cb20-29" data-line-number="29">        <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">h ::</span> b <span class="fu">~&gt;</span> f c)</a>
<a class="sourceLine" id="cb20-30" data-line-number="30">        <span class="ot">-&gt;</span> <span class="dt">Bind</span> a c m (<span class="dt">KCompSym2</span> a b c g h) <span class="fu">:~:</span> <span class="dt">Bind</span> b c (<span class="dt">Bind</span> a b m g) h</a>
<a class="sourceLine" id="cb20-31" data-line-number="31"></a>
<a class="sourceLine" id="cb20-32" data-line-number="32"><span class="kw">data</span> <span class="dt">ReturnSym0</span><span class="ot"> ::</span> a <span class="fu">~&gt;</span> f a</a>
<a class="sourceLine" id="cb20-33" data-line-number="33"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">ReturnSym0</span><span class="ot"> ::</span> a <span class="fu">~&gt;</span> f a) (<span class="ot">x ::</span> a) <span class="fu">=</span> <span class="dt">Return</span> a x</a>
<a class="sourceLine" id="cb20-34" data-line-number="34"></a>
<a class="sourceLine" id="cb20-35" data-line-number="35"><span class="kw">type</span> <span class="dt">KComp</span> a b c (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> f b) (<span class="ot">h ::</span> b <span class="fu">~&gt;</span> f c) (<span class="ot">x ::</span> a) <span class="fu">=</span> <span class="dt">Bind</span> b c (g <span class="fu">@@</span> x) h</a>
<a class="sourceLine" id="cb20-36" data-line-number="36"><span class="kw">data</span> <span class="dt">KCompSym2</span> a b c g<span class="ot"> h ::</span> (a <span class="fu">~&gt;</span> f c)</a>
<a class="sourceLine" id="cb20-37" data-line-number="37"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Apply</span> (<span class="dt">KCompSym2</span> a b c g<span class="ot"> h ::</span> a <span class="fu">~&gt;</span> f c) (<span class="ot">x ::</span> a) <span class="fu">=</span> <span class="dt">KComp</span> a b c g h x</a>
<a class="sourceLine" id="cb20-38" data-line-number="38"></a>
<a class="sourceLine" id="cb20-39" data-line-number="39">return</a>
<a class="sourceLine" id="cb20-40" data-line-number="40"><span class="ot">    ::</span> (<span class="dt">SingKind</span> a, <span class="dt">SingKind</span> (f a), <span class="dt">Monad</span> f)</a>
<a class="sourceLine" id="cb20-41" data-line-number="41">    <span class="ot">=&gt;</span> <span class="dt">Demote</span> a</a>
<a class="sourceLine" id="cb20-42" data-line-number="42">    <span class="ot">-&gt;</span> <span class="dt">Demote</span> (f a)</a>
<a class="sourceLine" id="cb20-43" data-line-number="43">return x <span class="fu">=</span> withSomeSing x <span class="fu">$</span> \sX <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-44" data-line-number="44">             fromSing (sReturn sX)</a></code></pre></div>
<p>To help with kind inference, again, we provide explicit kind arguments for <code>Return</code> (the kind of the thing that is being lifted) and <code>Bind</code> (the original <code>a</code> and the resulting <code>b</code>).</p>
<p>Some boilerplate exists there at the bottom — it’s the plumbing for the defunctionalization system. <code>returnIdentRight</code> requires a defunctionalized version of <code>Return</code>, so we can provide that by defining <code>ReturnSym0</code>, and writing an <code>Apply</code> instance for it (which “applies” it the parameter <code>x</code>).</p>
<p>We introduce <code>KComp</code> (kleisli composition) and its defunctionalized version in order to express the third law, because we don’t yet have type-level lambdas in Haskell. The actual function it is expressing is <code>\x -&gt; f x &gt;&gt;= g</code>, and that definition is given on the <code>type KComp a b c ... = Bind ...</code> line. <code>KCompSym2</code> is the defunctioanlized version, which is not a <code>a -&gt; f c</code> but rather an <code>a ~&gt; f c</code>, which allows it to be partially applied (like we do for <code>composeBind</code>). And, finally, to hook all of this up into the defunctionalization system, we write an <code>Apply</code> instance yet again.</p>
<p>And, again, if anyone knows how I can write a value-level <code>Bind</code>, I’d definitely appreciate hearing!</p>
<p>Let’s see some sample implementations.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="fu">$</span>(singletons [d|</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">  bindOption :: Option a -&gt; (a -&gt; Option b) -&gt; Option b</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  bindOption None     _ = None</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  bindOption (Some x) f = f x</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  concatMapList :: (a -&gt; List b) -&gt; List a -&gt; List b</a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  concatMapList _ Nil         = Nil</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">  concatMapList f (Cons x xs) = f x `appendList` concatMapList f xs</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  |])</a>
<a class="sourceLine" id="cb21-10" data-line-number="10"></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Option</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12">    <span class="kw">type</span> <span class="dt">Return</span> a   x   <span class="fu">=</span> <span class="dt">Some</span> x</a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    <span class="kw">type</span> <span class="dt">Bind</span>   a b m g <span class="fu">=</span> <span class="dt">BindOption</span> m g</a>
<a class="sourceLine" id="cb21-14" data-line-number="14"></a>
<a class="sourceLine" id="cb21-15" data-line-number="15">    sReturn <span class="fu">=</span> <span class="dt">SSome</span></a>
<a class="sourceLine" id="cb21-16" data-line-number="16">    sBind   <span class="fu">=</span> sBindOption</a>
<a class="sourceLine" id="cb21-17" data-line-number="17"></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">    returnIdentLeft _ _ <span class="fu">=</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19">    returnIdentRight <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb21-20" data-line-number="20">      <span class="dt">SNone</span>   <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-21" data-line-number="21">      <span class="dt">SSome</span> x <span class="ot">-&gt;</span> <span class="kw">case</span> sReturn x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-22" data-line-number="22">        <span class="dt">SSome</span> _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-23" data-line-number="23">    bindCompose <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb21-24" data-line-number="24">      <span class="dt">SNone</span>   <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-25" data-line-number="25">      <span class="dt">SSome</span> _ <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-26" data-line-number="26"></a>
<a class="sourceLine" id="cb21-27" data-line-number="27"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">List</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-28" data-line-number="28">    <span class="kw">type</span> <span class="dt">Return</span> a   x   <span class="fu">=</span> <span class="dt">PureList</span> x</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">    <span class="kw">type</span> <span class="dt">Bind</span>   a b m g <span class="fu">=</span> <span class="dt">ConcatMapList</span> g m</a>
<a class="sourceLine" id="cb21-30" data-line-number="30"></a>
<a class="sourceLine" id="cb21-31" data-line-number="31">    sReturn   <span class="fu">=</span> sPureList</a>
<a class="sourceLine" id="cb21-32" data-line-number="32">    sBind x f <span class="fu">=</span> sConcatMapList f x</a>
<a class="sourceLine" id="cb21-33" data-line-number="33"></a>
<a class="sourceLine" id="cb21-34" data-line-number="34">    returnIdentLeft x g <span class="fu">=</span> <span class="kw">case</span> sReturn x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-35" data-line-number="35">      <span class="dt">SCons</span> y <span class="dt">SNil</span> <span class="ot">-&gt;</span> <span class="kw">case</span> emptyIdentRight (unSingFun1 g y) <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-36" data-line-number="36">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-37" data-line-number="37"></a>
<a class="sourceLine" id="cb21-38" data-line-number="38">    returnIdentRight <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb21-39" data-line-number="39">      <span class="dt">SNil</span>       <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-40" data-line-number="40">      <span class="dt">SCons</span> _ xs <span class="ot">-&gt;</span> <span class="kw">case</span> returnIdentRight xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-41" data-line-number="41">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-42" data-line-number="42"></a>
<a class="sourceLine" id="cb21-43" data-line-number="43">    bindCompose <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb21-44" data-line-number="44">      <span class="dt">SNil</span>       <span class="ot">-&gt;</span> \_ _ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-45" data-line-number="45">      <span class="dt">SCons</span> x xs <span class="ot">-&gt;</span> \g h <span class="ot">-&gt;</span> <span class="kw">case</span> bindCompose xs g h <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-46" data-line-number="46">        <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="kw">case</span> unSingFun1 g x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-47" data-line-number="47">          <span class="dt">SNil</span>       <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-48" data-line-number="48">          <span class="dt">SCons</span> y ys <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-49" data-line-number="49">            <span class="kw">let</span> gxs  <span class="fu">=</span> sConcatMapList g xs</a>
<a class="sourceLine" id="cb21-50" data-line-number="50">                hgxs <span class="fu">=</span> sConcatMapList h gxs</a>
<a class="sourceLine" id="cb21-51" data-line-number="51">                hy   <span class="fu">=</span> unSingFun1 h y</a>
<a class="sourceLine" id="cb21-52" data-line-number="52">                hys  <span class="fu">=</span> sConcatMapList h ys</a>
<a class="sourceLine" id="cb21-53" data-line-number="53">            <span class="kw">in</span>  <span class="kw">case</span> distribConcatMap h ys gxs <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-54" data-line-number="54">                  <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="kw">case</span> appendAssoc hy hys hgxs <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-55" data-line-number="55">                    <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-56" data-line-number="56"></a>
<a class="sourceLine" id="cb21-57" data-line-number="57"><span class="co">-- | Proving that concatMap distributes over &lt;&gt;</span></a>
<a class="sourceLine" id="cb21-58" data-line-number="58">distribConcatMap</a>
<a class="sourceLine" id="cb21-59" data-line-number="59"><span class="ot">    ::</span> <span class="dt">Sing</span> (<span class="ot">g ::</span> a <span class="fu">~&gt;</span> <span class="dt">List</span> b)</a>
<a class="sourceLine" id="cb21-60" data-line-number="60">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">xs ::</span> <span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb21-61" data-line-number="61">    <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="ot">ys ::</span> <span class="dt">List</span> a)</a>
<a class="sourceLine" id="cb21-62" data-line-number="62">    <span class="ot">-&gt;</span> <span class="dt">ConcatMapList</span> g (xs <span class="fu">&lt;&gt;</span> ys) <span class="fu">:~:</span> (<span class="dt">ConcatMapList</span> g xs <span class="fu">&lt;&gt;</span> <span class="dt">ConcatMapList</span> g ys)</a>
<a class="sourceLine" id="cb21-63" data-line-number="63">distribConcatMap g <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb21-64" data-line-number="64">    <span class="dt">SNil</span> <span class="ot">-&gt;</span> \_ <span class="ot">-&gt;</span> <span class="dt">Refl</span></a>
<a class="sourceLine" id="cb21-65" data-line-number="65">    <span class="dt">SCons</span> x xs <span class="ot">-&gt;</span> \ys <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-66" data-line-number="66">      <span class="kw">case</span> distribConcatMap g xs ys <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-67" data-line-number="67">        <span class="dt">Refl</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-68" data-line-number="68">          <span class="kw">let</span> gx    <span class="fu">=</span> unSingFun1 g x</a>
<a class="sourceLine" id="cb21-69" data-line-number="69">              cmgxs <span class="fu">=</span> sConcatMapList g xs</a>
<a class="sourceLine" id="cb21-70" data-line-number="70">              cmgys <span class="fu">=</span> sConcatMapList g ys</a>
<a class="sourceLine" id="cb21-71" data-line-number="71">          <span class="kw">in</span>  <span class="kw">case</span> appendAssoc gx cmgxs cmgys <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-72" data-line-number="72">                <span class="dt">Refl</span> <span class="ot">-&gt;</span> <span class="dt">Refl</span></a></code></pre></div>
<p>Here we use <code>unSingFun1</code>, which converts a singleton of a type-level function into a value-level function on singletons:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">unSingFun1</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Sing</span>  (<span class="ot">f      ::</span> a <span class="fu">~&gt;</span> b)</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">Sing</span>  (<span class="ot">x      ::</span> a)</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">Sing</span>  (f <span class="fu">@@</span><span class="ot"> x ::</span> b)</a></code></pre></div>
<p>The crux is that, given a <code>Sing (f :: a ~&gt; b)</code> and a <code>Sing (x :: a)</code>, we can “apply” them to get <code>Sing (f @@ x :: b)</code></p>
<p>The proofs for the list instance is admittedly ugly to write, due to the fact that <code>List</code> is a recursive type. It’s also tricky because Haskell has poor to little support for theorem proving and no real tools to help you write them efficiently. But, the proofs for <code>Option</code> are really something, aren’t they? It’s kind of amazing how much GHC can do on its own without requiring any manual proving on the part of the user.</p>
<h2 id="disclaimer">Disclaimer</h2>
<p>Don’t do this in actual code, please (<a href="https://twitter.com/mstk/status/848677244478279680">why?</a>). This post started off as an April Fools joke that accidentally compiled correctly for reasons which I cannot explain.</p>
<p>While I don’t recommend that you do this in actual code, but definitely do recommend that you do it for fun! The code in this post is available <a href="https://github.com/mstksg/inCode/tree/master/code-samples/verified-instances/VerifiedInstances.hs">here</a> if you want to play around!</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>In full <em>singletons</em> style, this should actually be expressed in terms of the the <em>partially applied</em> (defunctionalized) <code>&lt;&gt;</code>. However, I’m giving the non-defunctionalized versions here for clarity.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/abominations.html" class="tag-a-tag">#abominations</a></li><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/existential-types.html" class="tag-a-tag">#existential types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/singletons.html" class="tag-a-tag">#singletons</a></li><li><a href="https://blog.jle.im/entries/tagged/types.html" class="tag-a-tag">#types</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">Introducing the Hamilton library</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">Fixed-Length Vector Types in Haskell (an Update for 2017)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/verified-instances-in-haskell.html';
    this.page.identifier = 'verified-instances';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/mstksg">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>