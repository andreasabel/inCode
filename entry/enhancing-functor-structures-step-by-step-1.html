<!DOCTYPE HTML>
<html><head><title>Enhancing Functor Structures Step-By-Step (Part 1) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="A style of Haskell programming that I’ve been pretty excited about with over the past year or so is something that I can maybe call a “functor structure” designed pattern. This is the interest that culminated in my Functor Combinatorpedia post last year and the functor-combinators library. In the blog post I called this style the “functor combinator” style because it involved building these functor structures out of small, simple pieces. But I’ve never really explored the more exotic types of lowercase-f functors in Hask — contravariant functors and invariant functors. In this post we’re going to be exploring these different types of functor structures step-by-step, by starting with a simple useful structure and enhancing it piece by piece. This process reflects a lot of the way I personally work through these things — I normally don’t get the whole powerful structure all the way; instead I incrementally add things as I see how things fit together. We’re going build the tools to describe a json schema, in the form of an algebraic data type – sums and products. We’ll start off just building things we can use to describe the schema (by printing out documentation), and by the end of the journey we’ll also be able to parse and generate values with our schema. This series is designed for an intermediate Haskeller with familiarity in things like monadic parser combinators."><meta property="og:type" content="article"><meta property="og:title" content="Enhancing Functor Structures Step-By-Step (Part 1)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Enhancing Functor Structures Step-By-Step (Part 1)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/functor-structures-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/enhancing-functor-structures-step-by-step-1.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>A style of Haskell programming that I’ve been pretty excited about with over the past year or so is something that I can maybe call a “functor structure” designed pattern. This is the interest that culminated in my <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">Functor Combinatorpedia</a> post last year and the <a href="https://hackage.haskell.org/package/functor-combinators">functor-combinators</a> library. In the blog post I called this style the “functor combinator” style because it involved building these functor structures out of small, simple pieces. But I’ve never really explored the more exotic types of lowercase-f functors in Hask — contravariant functors and invariant functors.</p>
<p>In this post we’re going to be exploring these different types of functor structures step-by-step, by starting with a simple useful structure and enhancing it piece by piece. This process reflects a lot of the way I personally work through these things — I normally don’t get the whole powerful structure all the way; instead I incrementally add things as I see how things fit together.</p>
<p>We’re going build the tools to describe a <em>json schema</em>, in the form of an algebraic data type – sums and products. We’ll start off just building things we can use to <em>describe</em> the schema (by printing out documentation), and by the end of the journey we’ll also be able to parse and generate values with our schema.</p>
<p>This series is designed for an intermediate Haskeller with familiarity in things like monadic parser combinators.</p>
<h2 id="the-schema">The Schema</h2>
<p>Let’s start with the simplest level of describing our schema: a plain ol’ AST describing the possibilities our schema can take.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L11-L33</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">data</span> <span class="dt">Schema</span> <span class="ot">=</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>      <span class="dt">RecordType</span>  [<span class="dt">Field</span>]</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="op">|</span> <span class="dt">SumType</span>     [<span class="dt">Choice</span>]</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  <span class="dt">Primitive</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">data</span> <span class="dt">Field</span> <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    {<span class="ot"> fieldName  ::</span> <span class="dt">String</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    ,<span class="ot"> fieldValue ::</span> <span class="dt">Schema</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    }</span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="kw">data</span> <span class="dt">Choice</span> <span class="ot">=</span> <span class="dt">Choice</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    {<span class="ot"> choiceName  ::</span> <span class="dt">String</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    ,<span class="ot"> choiceValue ::</span> <span class="dt">Schema</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    }</span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="kw">data</span> <span class="dt">Primitive</span> <span class="ot">=</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>      <span class="dt">PString</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="op">|</span> <span class="dt">PNumber</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="op">|</span> <span class="dt">PBool</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Our schema will either represent a record of many different fields, a sum of many different options, or a primitive value. If it’s a sum type, it’ll be described by a list of <code>Choice</code>, which describes each branch. If it’s a record type, it’ll be described by a list of <code>Field</code>, which describes each field. If it’s a primitive type, it’ll a <code>Primitive</code>, which is either a string, number, or boolean.</p>
<p>Our end goal is to be able to write a schema for a type like</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L35-L38</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">data</span> <span class="dt">Customer</span> <span class="ot">=</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>      <span class="dt">CPerson</span>   {<span class="ot"> cpName ::</span> <span class="dt">String</span>,<span class="ot"> cpAge ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="op">|</span> <span class="dt">CBusiness</span> {<span class="ot"> cbEmployees ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>and be able to represent documenting, parsing, and printing it all within <code>Schema</code>. For our basic <code>Schema</code> above, this looks like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L40-L54</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ot">customerSchema ::</span> <span class="dt">Schema</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>customerSchema <span class="ot">=</span> <span class="dt">SumType</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    [ <span class="dt">Choice</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Person&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>            [ <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Name&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> <span class="dt">PString</span> }</span>
<span id="cb3-9"><a href="#cb3-9"></a>            , <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Age&quot;</span> , fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> <span class="dt">PNumber</span> }</span>
<span id="cb3-10"><a href="#cb3-10"></a>            ]</span>
<span id="cb3-11"><a href="#cb3-11"></a>        }</span>
<span id="cb3-12"><a href="#cb3-12"></a>    , <span class="dt">Choice</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Business&quot;</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>            [ <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Employees&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> <span class="dt">PNumber</span> } ]</span>
<span id="cb3-16"><a href="#cb3-16"></a>        }</span>
<span id="cb3-17"><a href="#cb3-17"></a>    ]</span></code></pre></div>
<p>And a value like</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">PCustomer</span> { cpName <span class="ot">=</span> <span class="st">&quot;Sam&quot;</span>, cpAge <span class="ot">=</span> <span class="dv">40</span> }</span></code></pre></div>
<p>might be represented by a json value like</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb5-1"><a href="#cb5-1"></a><span class="fu">{</span> <span class="dt">&quot;tag&quot;</span><span class="fu">:</span> <span class="st">&quot;Customer&quot;</span><span class="fu">,</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="dt">&quot;contents&quot;</span><span class="fu">:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="fu">{</span> <span class="dt">&quot;Name&quot;</span><span class="fu">:</span> <span class="st">&quot;Sam&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="fu">,</span> <span class="dt">&quot;Age&quot;</span><span class="fu">:</span> <span class="fl">40.0</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="fu">}</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="fu">}</span></span></code></pre></div>
<h2 id="documentation">Documentation</h2>
<p>Using our schema type, let’s make a documentation generator. It’ll take a <code>Schema</code> and nicely formatted documentation describing what the schema itself.</p>
<p>To make our lives easier, we’ll be using the <em><a href="https://hackage.haskell.org/package/prettyprinter">prettyprinter</a></em> library, which will handle indentation, horizontal and vertical concatenation, and other printing concerns for us.</p>
<p>Let’s build things up by defining documentation generators for our individual types, so they’ll be easier to assemble.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L56-L81</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>schemaDoc</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">    ::</span> <span class="dt">String</span>       <span class="co">-- ^ name</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Schema</span>       <span class="co">-- ^ schema</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">fieldDoc ::</span> <span class="dt">Field</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="ot">choiceDoc ::</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="ot">primDoc ::</span> <span class="dt">Primitive</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span></code></pre></div>
<p>So <code>schemaDoc</code> will take the name of our type and a schema, and generate a <code>PP.Doc x</code>, the type of a text document in the <em>prettyprinter</em> library.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> And <code>fieldDoc</code>, <code>choiceDoc</code>, and <code>primDoc</code> just generate the documentation for each individual field or constructor.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L75-L85</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">fieldDoc ::</span> <span class="dt">Field</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb7-4"><a href="#cb7-4"></a>fieldDoc <span class="dt">Field</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc fieldName fieldValue</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="ot">choiceDoc ::</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb7-7"><a href="#cb7-7"></a>choiceDoc <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc choiceName choiceValue</span>
<span id="cb7-8"><a href="#cb7-8"></a></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="ot">primDoc ::</span> <span class="dt">Primitive</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb7-10"><a href="#cb7-10"></a>primDoc <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="dt">PString</span> <span class="ot">-&gt;</span> <span class="st">&quot;string&quot;</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>  <span class="dt">PNumber</span> <span class="ot">-&gt;</span> <span class="st">&quot;number&quot;</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>  <span class="dt">PBool</span>   <span class="ot">-&gt;</span> <span class="st">&quot;bool&quot;</span></span></code></pre></div>
<p>Nothing too fancy here — since <code>Field</code> and <code>Choice</code> just have a name and a sub-schema, we can have them call <code>schemaDoc</code>. <code>primDoc</code> requires making our leaf documentation, so we can just print what type they have.</p>
<p>We tie it all together with <code>schemaDoc</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L56-L73</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>schemaDoc</span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ot">    ::</span> <span class="dt">String</span>       <span class="co">-- ^ name</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Schema</span>       <span class="co">-- ^ schema</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb8-7"><a href="#cb8-7"></a>schemaDoc title <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> PP.vsep [</span>
<span id="cb8-9"><a href="#cb8-9"></a>        PP.pretty (<span class="st">&quot;{&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;}&quot;</span>)</span>
<span id="cb8-10"><a href="#cb8-10"></a>      , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>          <span class="fu">map</span> (\fld <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span> <span class="op">PP.&lt;+&gt;</span> PP.indent <span class="dv">2</span> (fieldDoc fld)) fs</span>
<span id="cb8-12"><a href="#cb8-12"></a>      ]</span>
<span id="cb8-13"><a href="#cb8-13"></a>    <span class="dt">SumType</span> cs    <span class="ot">-&gt;</span> PP.vsep [</span>
<span id="cb8-14"><a href="#cb8-14"></a>        PP.pretty (<span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</span>
<span id="cb8-15"><a href="#cb8-15"></a>      , <span class="st">&quot;Choice of:&quot;</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>      , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>          <span class="fu">map</span> choiceDoc cs</span>
<span id="cb8-18"><a href="#cb8-18"></a>      ]</span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> PP.pretty (title <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span>)</span>
<span id="cb8-20"><a href="#cb8-20"></a>              <span class="op">PP.&lt;+&gt;</span> primDoc p</span></code></pre></div>
<p>Here we use <code>PP.vsep</code>, which takes a list of docs and concatenates them vertically, <code>PP.&lt;+&gt;</code> which concatenates two docs horizontally, and <code>PP.indent</code> which indents things before going down a level. We appropriately call <code>fieldDoc</code>, <code>choiceDoc</code>, and <code>primDoc</code> when we actually need to print one of them.</p>
<p>Hopefully that wasn’t too bad! There were a lot of moving parts because we have a recursive data type, but in the end hopefully each specific branch was self-contained enough to understand on their own. In the end the important thing to take away isn’t the mechanics of document generation, but rather how the data flows. Make sure you at least understand how the functions call each other, and how — this pattern is going to be very consistent across all the schema processors we write!</p>
<p>We can test out our function on <code>customerSchema</code>, taking advantage of the fact that <code>PP.Doc</code>’s <code>Show</code> instance will render the document:</p>
<pre><code>ghci&gt; schemaDoc &quot;Customer&quot; customerSchema
(Customer)
Choice of:
  {Person}
    *   Name: string
    *   Age: number
  {Business}
    *   Employees: number</code></pre>
<p>It works!</p>
<h2 id="parsing-with-covariance">Parsing with Covariance</h2>
<p>Now, let’s talk about using our <code>Schema</code> type to define a json parser. We’re going to rewrite <code>Schema</code> to take a type parameter to represent the type we want to parse into. A <code>Schema a</code> will be a schema that can be used to generate documentation <em>and</em> describe a parser of <code>a</code>s. In the end, we want <code>customerSchema :: Schema Customer</code>, and a function like</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">schemaParser ::</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> a</span></code></pre></div>
<p>to generate a json parser of <code>a</code>s. We’ll be using the json parser type <code>Parse err a</code> from <em><a href="https://hackage.haskell.org/package/aeson-better-errors">aeson-better-errors</a></em> (not because of the better errors, but just because it’s closer to an actual incremental/stateful parser than other alternatives out there), which can be run with <code>parse :: Parse err a -&gt; ByteString -&gt; Either (ParseError err) a</code>. So our final interface will look like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L157-L158</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="ot">parseSchema ::</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">A.ParseError</span> <span class="dt">ErrType</span>) a</span>
<span id="cb11-4"><a href="#cb11-4"></a>parseSchema sc <span class="ot">=</span> A.parse (schemaParser sc)</span></code></pre></div>
<p>To do this, we now have to include information on “how to parse an <code>a</code>” in our schema. Remember that our actual json format is pretty fixed/structured, so all our <code>Schema</code> has to express are variations within that structure. The only variation that our <code>Schema</code> can express are how sums/products are structured, and also how to parse primitive types. And so, the main thing we need to modify is just <code>Primitive</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L46-L50</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>      <span class="dt">PString</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (<span class="dt">Scientific</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb12-7"><a href="#cb12-7"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>A <code>Primitive a</code> will be a way to parse a json primitive — it can be <code>PString</code>, <code>PNumber</code>, or <code>PBool</code>. To create a “String Parser”, you need to use <code>PString</code> with a function on “what to do with the string you get”. To create a “Bool parser”, you need <code>PBool</code> with a function on what to do with the bool you get.</p>
<p>We can write some helper primitives:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L52-L59</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="ot">pString ::</span> <span class="dt">Primitive</span> <span class="dt">String</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>pString <span class="ot">=</span> <span class="dt">PString</span> <span class="dt">Just</span></span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="ot">pInt ::</span> <span class="dt">Primitive</span> <span class="dt">Int</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>pInt <span class="ot">=</span> <span class="dt">PNumber</span> toBoundedInteger</span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="ot">pBool ::</span> <span class="dt">Primitive</span> <span class="dt">Bool</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>pBool <span class="ot">=</span> <span class="dt">PBool</span> <span class="dt">Just</span></span></code></pre></div>
<p><code>pString :: Primitive String</code> is the most basic way to parse a primitive json string: just return the <code>String</code> itself. <code>pInt</code> needs to reject any non-integer numbers, so <code>toBoundedInteger :: Scientific -&gt; Maybe Int</code> works well.</p>
<p>We can now start writing our parsers for each branch of <code>Schema</code>. The <code>SchemaLeaf</code> branch should be the simplest. We can use <em>aeson-better-error</em>’s primitive value parsers:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">-- | Parse successfuly only if the current value is a String, running the</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co">-- validation function</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="ot">withString     ::</span> (<span class="dt">String</span>     <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ErrType</span> a) <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> a</span>
<span id="cb14-4"><a href="#cb14-4"></a></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="ot">withScientific ::</span> (<span class="dt">Scientific</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ErrType</span> a) <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> a</span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="ot">withBool       ::</span> (<span class="dt">Bool</span>       <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ErrType</span> a) <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> a</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L134-L141</span></span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="ot">primParser ::</span> <span class="dt">Primitive</span> a <span class="ot">-&gt;</span> <span class="dt">A.Parse</span> <span class="dt">String</span> a</span>
<span id="cb15-4"><a href="#cb15-4"></a>primParser <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  <span class="dt">PString</span> f <span class="ot">-&gt;</span> A.withString <span class="op">$</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>    <span class="fu">maybe</span> (<span class="dt">Left</span> <span class="st">&quot;error validating string&quot;</span>) <span class="dt">Right</span> <span class="op">.</span> f</span>
<span id="cb15-7"><a href="#cb15-7"></a>  <span class="dt">PNumber</span> f <span class="ot">-&gt;</span> A.withScientific <span class="op">$</span></span>
<span id="cb15-8"><a href="#cb15-8"></a>    <span class="fu">maybe</span> (<span class="dt">Left</span> <span class="st">&quot;error validating number&quot;</span>) <span class="dt">Right</span> <span class="op">.</span> f</span>
<span id="cb15-9"><a href="#cb15-9"></a>  <span class="dt">PBool</span> f <span class="ot">-&gt;</span> A.withBool <span class="op">$</span></span>
<span id="cb15-10"><a href="#cb15-10"></a>    <span class="fu">maybe</span> (<span class="dt">Left</span> <span class="st">&quot;error validating bool&quot;</span>) <span class="dt">Right</span> <span class="op">.</span> f</span></code></pre></div>
<p>Nothing too fancy, mostly plumbing.</p>
<h3 id="deducing-ap">Deducing Ap</h3>
<p>However, this small change (and adding the type parameter) leaves in a predicament. What should <code>Schema</code> look like?</p>
<p>At first glance, we might think we could just write</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb16-2"><a href="#cb16-2"></a>      <span class="dt">RecordType</span>  [<span class="dt">Field</span> a]</span>
<span id="cb16-3"><a href="#cb16-3"></a>    <span class="op">|</span> <span class="dt">SumType</span>     [<span class="dt">Choice</span> a]</span>
<span id="cb16-4"><a href="#cb16-4"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb16-5"><a href="#cb16-5"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L34-L40</span></span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="kw">data</span> <span class="dt">Field</span> a <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb16-9"><a href="#cb16-9"></a></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="kw">data</span> <span class="dt">Choice</span> a <span class="ot">=</span> <span class="dt">Choice</span></span></code></pre></div>
<p>But there’s a problem here: <code>RecordType</code> is a combination of <code>Field</code>s, but…each <code>Field</code> is of a different type! For example, in our <code>Customer</code> example, the <code>Person</code> branch has two fields: <code>Name</code> and <code>Age</code>. Our name schema would look like <code>nameField :: Field String</code>, and our age schema would look like <code>ageField :: Field Int</code>…and so you can’t really put that into a list like <code>[Field a]</code> since they each have different types. And further more, we want a final <code>Customer</code> (in our <code>Schema Customer</code>), a type which is different from both <code>String</code> and <code>Int</code>.</p>
<p>What we need is a way to express heterogeneous collection/sequence of <code>Field a</code>, coupled with a way of “combining” all of them to create an aggregate value of a final type. A type that says “use a bunch of <code>Field</code> of <code>x</code>s of different types to generate a final <code>a</code>”.</p>
<p>There are a couple of ways to arrive at this mystery type. One way is to recognize “combine a bunch of <code>f x</code>s of different types to create an <code>f b</code>” is essentially the MO of the <em>Applicative</em> abstraction, and so essentially we want to give <code>Field</code> some sort of <code>Applicative</code> structure. And so we can reach for “the type that gives something an <code>Applicative</code> structure”, the <a href="https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html">free applicative</a>.</p>
<p>Another way is to think about it as an enhancement along a functor combinator described in the <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">functor combinatorpedia</a>. Here we know we want to enhance <code>Field</code> in a specific way, so we can scan the list of functor combinators until there is one that we need. And scrolling down, we see:</p>
<blockquote>
<p><a href="https://blog.jle.im/entry/functor-combinatorpedia.html#ap-ap1"><strong>Ap / Ap1 </strong></a></p>
<p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html">Control.Applicative.Free</a></em> / <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html">Data.Functor.Apply.Free</a></em></p>
<p><strong>Enhancement</strong>: The ability to provide multiple <code>f</code>s that the interpreter <em>must</em> consume <em>all</em> of. (…)</p>
<p>While <code>ListF</code> may be considered “multiple options <em>offered</em>”, <code>Ap</code> can be considered “multiple actions all <em>required</em>”. The interpreter must consume/interpret <em>all</em> of the multiple <code>f</code>s in order to interpret an <code>Ap</code>.</p>
<p>Note that ordering is not enforced: while the consumer must handle each <code>f</code> eventually, they are free to handle it in whatever order they desire. In fact, they could even all be handled in parallel. See <code>Free</code> for a version where ordering is enforced.</p>
<p>…</p>
<p>Because this has an <code>Applicative</code> instance, you can use <code>(&lt;*&gt;) :: Ap f (a -&gt; b) -&gt; Ap f a -&gt; Ap f b</code> to sequence multiple <code>Ap f</code>s together, and <code>pure :: a -&gt; Ap f a</code> to produce a “no-op” <code>Ap</code> without any <code>f</code>s.</p>
</blockquote>
<p>That sounds like it matches to me! In order to parse a <code>RecordType</code>, we need to parse <em>every</em> <code>Field</code>. It doesn’t make any sense to skip one field or the other: they all need to be processed and parsed. This sounds like just the thing we need.</p>
<p>The description here also gives a clue for what we might want to use for <code>SumType</code> (<code>ListF</code> sounds like a good companion for the behavior we want sum type parsers to have)</p>
<h3 id="building-ap">Building Ap</h3>
<p>With this, we can write our final <code>Schema</code> type.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L28-L50</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>      <span class="dt">RecordType</span>  (<span class="dt">Ap</span> <span class="dt">Field</span> a)</span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="op">|</span> <span class="dt">SumType</span>     (<span class="dt">ListF</span> <span class="dt">Choice</span> a)</span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="kw">data</span> <span class="dt">Field</span> a <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>    {<span class="ot"> fieldName  ::</span> <span class="dt">String</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>    ,<span class="ot"> fieldValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb17-12"><a href="#cb17-12"></a>    }</span>
<span id="cb17-13"><a href="#cb17-13"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb17-14"><a href="#cb17-14"></a></span>
<span id="cb17-15"><a href="#cb17-15"></a><span class="kw">data</span> <span class="dt">Choice</span> a <span class="ot">=</span> <span class="dt">Choice</span></span>
<span id="cb17-16"><a href="#cb17-16"></a>    {<span class="ot"> choiceName  ::</span> <span class="dt">String</span></span>
<span id="cb17-17"><a href="#cb17-17"></a>    ,<span class="ot"> choiceValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb17-18"><a href="#cb17-18"></a>    }</span>
<span id="cb17-19"><a href="#cb17-19"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb17-20"><a href="#cb17-20"></a></span>
<span id="cb17-21"><a href="#cb17-21"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>      <span class="dt">PString</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb17-23"><a href="#cb17-23"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (<span class="dt">Scientific</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb17-24"><a href="#cb17-24"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb17-25"><a href="#cb17-25"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>Note that I switched from <code>[Choice a]</code> to <code>ListF Choice a</code> — the two are the same, but the latter has the <code>Functor</code> instance we want (<code>fmap :: (a -&gt; b) -&gt; ListF Choice a -&gt; ListF Choice b</code>), and is an instance of useful functor combinator typeclasses. Furthermore, it illustrates the symmetry between sum types and record, since <code>Ap</code> and <code>ListF</code> are contrasting types: <code>Ap</code> represents a product between many required fields, and <code>ListF</code> represents a sum between many possible choices. It’s more clear how product types and sum types are “opposites” in a nice clean way.</p>
<p>We can now make our <code>Customer</code> schema:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L66-L80</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="ot">customerSchema ::</span> <span class="dt">Schema</span> <span class="dt">Customer</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>customerSchema <span class="ot">=</span> <span class="dt">SumType</span> <span class="op">$</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>      inject <span class="dt">Choice</span></span>
<span id="cb18-6"><a href="#cb18-6"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Person&quot;</span></span>
<span id="cb18-7"><a href="#cb18-7"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span> <span class="op">$</span></span>
<span id="cb18-8"><a href="#cb18-8"></a>            <span class="dt">CPerson</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>              <span class="op">&lt;$&gt;</span> inject <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Name&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> pString }</span>
<span id="cb18-10"><a href="#cb18-10"></a>              <span class="op">&lt;*&gt;</span> inject <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Age&quot;</span> , fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> pInt    }</span>
<span id="cb18-11"><a href="#cb18-11"></a>        }</span>
<span id="cb18-12"><a href="#cb18-12"></a>  <span class="op">&lt;!&gt;</span> inject <span class="dt">Choice</span></span>
<span id="cb18-13"><a href="#cb18-13"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Business&quot;</span></span>
<span id="cb18-14"><a href="#cb18-14"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span> <span class="op">$</span></span>
<span id="cb18-15"><a href="#cb18-15"></a>            <span class="dt">CBusiness</span></span>
<span id="cb18-16"><a href="#cb18-16"></a>              <span class="op">&lt;$&gt;</span> inject <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Employees&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> pInt }</span>
<span id="cb18-17"><a href="#cb18-17"></a>        }</span></code></pre></div>
<p>The main new thing is using <code>inject :: Choice a -&gt; ListF Choice a</code> and <code>inject :: Field a -&gt; Ap Field a</code> to lift our base types into their appropriate combinators. Then after that, we just use <code>Ap</code>’s <code>Applicative</code> instance and <code>ListF</code>’s <code>Plus</code> instance to combine them together. Overall it should look very similar to the schema we wrote for the documentation section.</p>
<h3 id="interpreting-ap">Interpreting Ap</h3>
<p>Now, the typical way to “run” an applied functor combinator is with interpreting functions, like:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">interpret ::</span> <span class="dt">Applicative</span> g <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> g x) <span class="ot">-&gt;</span> <span class="dt">Ap</span> f a    <span class="ot">-&gt;</span> g a</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ot">interpret ::</span> <span class="dt">Plus</span> g        <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> g x) <span class="ot">-&gt;</span> <span class="dt">ListF</span> f a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>You can interpret an <code>Ap f a</code> into any <code>Applicative g</code>, and you can interpret a <code>ListF f a</code> into any <code>Plus g</code> (<code>Plus</code> is basically <code>Alternative</code> without an <code>Applicative</code> requirement). Basically, you write a function to interpret any <code>f</code> you find, and <code>interpret</code> will accumulate them all together for you.</p>
<p>In our case, if we decided to use <code>interpret</code>, we could write:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="ot">interpret ::</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Field</span>  x <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> x) <span class="ot">-&gt;</span> <span class="dt">Ap</span>    <span class="dt">Field</span>  a <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> x</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="ot">interpret ::</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Choice</span> x <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> x) <span class="ot">-&gt;</span> <span class="dt">ListF</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> x</span></code></pre></div>
<p>Basically, if we have a way to parse each <code>Field</code>, then we have a way to parse an <code>Ap Field a</code>. If we have a way to parse each <code>Choice</code>, then we have a way to parse a <code>ListF Choice a</code>.</p>
<p>Let’s write those individual parsers for each smaller type:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L131-L132</span></span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="ot">fieldParser ::</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> <span class="dt">A.Parse</span> <span class="dt">String</span> a</span>
<span id="cb21-4"><a href="#cb21-4"></a>fieldParser <span class="dt">Field</span>{<span class="op">..</span>} <span class="ot">=</span> A.key (T.pack fieldName) (schemaParser fieldValue)</span></code></pre></div>
<p>Here we use <em>aeson-better-errors</em>’s <code>key :: Text -&gt; Parser a -&gt; Parser a</code>, which takes a key and a parser, and runs that parser on whatever is under that key. For <code>fieldParser</code>, we run the schema parser for our sub-schema under that key.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L124-L129</span></span>
<span id="cb22-2"><a href="#cb22-2"></a></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="ot">choiceParser ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> <span class="dt">A.Parse</span> <span class="dt">String</span> a</span>
<span id="cb22-4"><a href="#cb22-4"></a>choiceParser <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>  tag <span class="ot">&lt;-</span> A.key <span class="st">&quot;tag&quot;</span> A.asString</span>
<span id="cb22-6"><a href="#cb22-6"></a>  unless (tag <span class="op">==</span> choiceName) <span class="op">$</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>    A.throwCustomError <span class="st">&quot;Tag does not match&quot;</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>  A.key <span class="st">&quot;contents&quot;</span> <span class="op">$</span> schemaParser choiceValue</span></code></pre></div>
<p>Our sum type encoding is a bit more involved, because json doesn’t have any native sum type construct. So we’re going to parse whatever is in the key <code>"tag"</code>, and if that tag matches our current choice’s constructor, we parse the schema parser for our sub-schema under that key. Otherwise, this choice isn’t what is currently in our json value.</p>
<p>Finally, to wrap bring it all together, we use the <code>interpret</code> functions we talked about:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L118-L122</span></span>
<span id="cb23-2"><a href="#cb23-2"></a></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="ot">schemaParser ::</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> <span class="dt">A.Parse</span> <span class="dt">ErrType</span> a</span>
<span id="cb23-4"><a href="#cb23-4"></a>schemaParser <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>    <span class="dt">SumType</span>    cs <span class="ot">-&gt;</span> interpret choiceParser cs</span>
<span id="cb23-6"><a href="#cb23-6"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> interpret fieldParser fs</span>
<span id="cb23-7"><a href="#cb23-7"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> primParser p</span></code></pre></div>
<p>And that’s it!</p>
<p>Ah well, not exactly so fast. Even though they could support it, <em>aeson-better-errors</em> doesn’t provide <code>Plus</code> a for <code>Parse</code>. We can write them as orphans here just because this is a fun learning experience (but we usually do like to avoid defining instances for types or typeclasses that aren’t ours).</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L111-L114</span></span>
<span id="cb24-2"><a href="#cb24-2"></a></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">instance</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Alt</span> (<span class="dt">A.ParseT</span> e f) <span class="kw">where</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    (<span class="op">&lt;!&gt;</span>) <span class="ot">=</span> (<span class="op">A.&lt;|&gt;</span>)</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="kw">instance</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Plus</span> (<span class="dt">A.ParseT</span> <span class="dt">String</span> f) <span class="kw">where</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>    zero  <span class="ot">=</span> A.throwCustomError <span class="st">&quot;No options were validated&quot;</span></span></code></pre></div>
<p>And…that should work!</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>ghci<span class="op">&gt;</span> parseSchema customerSchema  <span class="st">&quot;{ \&quot;tag\&quot;: \&quot;Person\&quot;, \&quot;contents\&quot;: { \&quot;Name\&quot;: \&quot;Same\&quot;, \&quot;Age\&quot;: 40 } }&quot;</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="dt">Right</span> (<span class="dt">CPerson</span> {cpName <span class="ot">=</span> <span class="st">&quot;Same&quot;</span>, cpAge <span class="ot">=</span> <span class="dv">30</span>})</span>
<span id="cb25-4"><a href="#cb25-4"></a>ghci<span class="op">&gt;</span> parseSchema customerSchema  <span class="st">&quot;{ \&quot;tag\&quot;: \&quot;Business\&quot;, \&quot;contents\&quot;: { \&quot;Employees\&quot;: 3 } }&quot;</span></span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="dt">Right</span> (<span class="dt">CBusiness</span> {cbEmployees <span class="ot">=</span> <span class="dv">3</span>})</span></code></pre></div>
<p>We were able to generate a fully functional parser from our schema, by only providing parsers for the smaller, more specific types we had (<code>Field</code> and <code>Choice</code>), and having them all fit together in a way directed by their <code>Apply</code> and <code>Alt</code> typeclass instances.</p>
<h3 id="direct-structural-inspection">Direct Structural Inspection</h3>
<p>However, sometimes the typeclass instances aren’t really the best way to handle things. It gives us a nice principled shortcut — for example, to interpret out of an <code>Ap</code>, GHC needs a way to know “how to sequence <code>Parse</code>s”, and so <code>interpret</code> uses the <code>Applicative</code> instance for that. But we know there are usually different ways to sequence or combine actions — famously in IO, we have the option to sequence IO actions in series or in parallel. So, offloading our logic to a typeclass can be a convenient route, but it’s not necessarily the most pragmatic way.</p>
<p>In our case, the <code>Plus</code> instance actually combines failed fallback behavior in an undesirable way: our errors become not too useful, because <code>&lt;!&gt;</code> always picks the right side’s errors, and we eventually run into <code>A.throwCustomError "No options were validated"</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>ghci<span class="op">&gt;</span> parseSchema customerSchema  <span class="st">&quot;{ \&quot;tag\&quot;: \&quot;Business\&quot;, \&quot;contents\&quot;: { \&quot;Employees\&quot;: \&quot;Mustard\&quot; } }&quot;</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="dt">Left</span> (<span class="dt">BadSchema</span> [] (<span class="dt">CustomError</span> <span class="st">&quot;No options were validated&quot;</span>))</span>
<span id="cb26-3"><a href="#cb26-3"></a>ghci<span class="op">&gt;</span> parseSchema customerSchema  <span class="st">&quot;{ \&quot;tag\&quot;: \&quot;Grape\&quot;, \&quot;contents\&quot;: { \&quot;Color\&quot;: \&quot;purple\&quot; } }&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="dt">Left</span> (<span class="dt">BadSchema</span> [] (<span class="dt">CustomError</span> <span class="st">&quot;No options were validated&quot;</span>))</span></code></pre></div>
<p>Since <code>Plus</code>’s <code>zero</code> definition always falls back to the same error, this is not very useful!</p>
<p>So <code>interpret</code> for <code>ListF</code>, while convenient, isn’t necessarily the best way to tear down a <code>ListF</code>. Luckily, most functor combinators are just ADTs that we can pattern match and break down and access the structures manually. In the case of <code>ListF</code>, the structure is pretty simple:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">data</span> <span class="dt">ListF</span> f a <span class="ot">=</span> <span class="dt">ListF</span> {<span class="ot"> runListF ::</span> [f a] }</span></code></pre></div>
<p>Our <code>ListF Choice a</code> is just <code>[Choice a]</code>. This is something we can work with! Let’s write a better <code>ListF Choice a</code> processor by working with the list itself.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L143-L155</span></span>
<span id="cb28-2"><a href="#cb28-2"></a></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="ot">schemaParser2 ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> <span class="dt">A.Parse</span> <span class="dt">ErrType</span> a</span>
<span id="cb28-4"><a href="#cb28-4"></a>schemaParser2 <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb28-5"><a href="#cb28-5"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> interpret fieldParser fs</span>
<span id="cb28-6"><a href="#cb28-6"></a>    <span class="dt">SumType</span>    cs <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb28-7"><a href="#cb28-7"></a>      <span class="kw">let</span><span class="ot"> schemaMap ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> (<span class="dt">Schema</span> a)</span>
<span id="cb28-8"><a href="#cb28-8"></a>          schemaMap <span class="ot">=</span> M.fromList [ (choiceName, choiceValue) <span class="op">|</span> <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">&lt;-</span> runListF cs ]</span>
<span id="cb28-9"><a href="#cb28-9"></a>      tag <span class="ot">&lt;-</span> A.key <span class="st">&quot;tag&quot;</span> A.asString</span>
<span id="cb28-10"><a href="#cb28-10"></a>      <span class="kw">case</span> M.lookup tag schemaMap <span class="kw">of</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> A.throwCustomError <span class="op">$</span></span>
<span id="cb28-12"><a href="#cb28-12"></a>                <span class="st">&quot;tag &quot;</span> <span class="op">&lt;&gt;</span> tag <span class="op">&lt;&gt;</span> <span class="st">&quot; not recognized: Expected one of &quot;</span></span>
<span id="cb28-13"><a href="#cb28-13"></a>             <span class="op">&lt;&gt;</span> intercalate <span class="st">&quot;, &quot;</span> (M.keys schemaMap)</span>
<span id="cb28-14"><a href="#cb28-14"></a>        <span class="dt">Just</span> sc <span class="ot">-&gt;</span> A.key <span class="st">&quot;contents&quot;</span> (schemaParser2 sc)</span>
<span id="cb28-15"><a href="#cb28-15"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> primParser p</span></code></pre></div>
<p>We can use the structure of <code>ListF</code> to generate a <code>Map</code> associating any tags with the schemas they are meant to encode. We then parse the tag, look up what schema it represents (if any) and then use that schema under the contents key.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a>λ<span class="op">:</span> parseSchema2 customerSchema  <span class="st">&quot;{ \&quot;tag\&quot;: \&quot;Business\&quot;, \&quot;contents\&quot;: { \&quot;Employees\&quot;: \&quot;Mustard\&quot; } }&quot;</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="dt">Left</span> (<span class="dt">BadSchema</span> [<span class="dt">ObjectKey</span> <span class="st">&quot;contents&quot;</span>,<span class="dt">ObjectKey</span> <span class="st">&quot;Employees&quot;</span>] (<span class="dt">WrongType</span> <span class="dt">TyNumber</span> (<span class="dt">String</span> <span class="st">&quot;Mustard&quot;</span>)))</span>
<span id="cb29-3"><a href="#cb29-3"></a>λ<span class="op">:</span> parseSchema2 customerSchema  <span class="st">&quot;{ \&quot;tag\&quot;: \&quot;Grape\&quot;, \&quot;contents\&quot;: { \&quot;Color\&quot;: \&quot;purple\&quot; } }&quot;</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="dt">Left</span> (<span class="dt">BadSchema</span> [] (<span class="dt">CustomError</span> <span class="st">&quot;tag Grape not recognized: Expected one of Business, Person&quot;</span>))</span></code></pre></div>
<p>Much better messages!</p>
<h3 id="backporting-documentation">Backporting documentation</h3>
<p>Remember that the whole point of this exercise was to <em>add</em> functionality to our schema. That means we also have to upgrade our documentation function as well.</p>
<p>Hopefully it is clear from the structure of our data type that we haven’t <em>lost</em> any information. Updating our documentation generator should be just a matter of changing how to we get the items from our <code>ListF</code> and <code>Ap</code>.</p>
<p>Yes, we could manually pattern match and take advantage of the structure, or use an interpretation function directly, etc., but if we just want to get a list of monomorphic items from a functor combinator, there’s a convenient function in <em>functor-combinators</em> called <code>icollect</code>:<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="ot">icollect ::</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ListF</span> f a <span class="ot">-&gt;</span> [b]</span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="ot">icollect ::</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Ap</span>    f a <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>Give it a function to “get” a <code>b</code> out of every <code>f</code>, it collects the <code>b</code> from every <code>f</code> inside the structure and puts it in a list for us. Note that this type is very similar to the <code>map</code> we used earlier:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="co">-- what we used before</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="fu">map</span><span class="ot">      ::</span> (          <span class="dt">Field</span>   <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [<span class="dt">Field</span>]    <span class="ot">-&gt;</span> [b]</span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="co">-- what we can use now</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="ot">icollect ::</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Field</span> x <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Ap</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>So it looks like <code>icollect</code> should work as a drop-in replacement for <code>map</code> …</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L82-L109</span></span>
<span id="cb33-2"><a href="#cb33-2"></a></span>
<span id="cb33-3"><a href="#cb33-3"></a>schemaDoc</span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="ot">    ::</span> <span class="dt">String</span>       <span class="co">-- ^ name</span></span>
<span id="cb33-5"><a href="#cb33-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Schema</span> x     <span class="co">-- ^ schema</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>    <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb33-7"><a href="#cb33-7"></a>schemaDoc title <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb33-8"><a href="#cb33-8"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> PP.vsep [</span>
<span id="cb33-9"><a href="#cb33-9"></a>        PP.pretty (<span class="st">&quot;{&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;}&quot;</span>)</span>
<span id="cb33-10"><a href="#cb33-10"></a>      , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb33-11"><a href="#cb33-11"></a>          icollect (\fld <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span> <span class="op">PP.&lt;+&gt;</span> PP.indent <span class="dv">2</span> (fieldDoc fld)) fs</span>
<span id="cb33-12"><a href="#cb33-12"></a>      ]</span>
<span id="cb33-13"><a href="#cb33-13"></a>    <span class="dt">SumType</span> cs    <span class="ot">-&gt;</span> PP.vsep [</span>
<span id="cb33-14"><a href="#cb33-14"></a>        PP.pretty (<span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</span>
<span id="cb33-15"><a href="#cb33-15"></a>      , <span class="st">&quot;Choice of:&quot;</span></span>
<span id="cb33-16"><a href="#cb33-16"></a>      , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb33-17"><a href="#cb33-17"></a>          icollect choiceDoc cs</span>
<span id="cb33-18"><a href="#cb33-18"></a>      ]</span>
<span id="cb33-19"><a href="#cb33-19"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> PP.pretty (title <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span>)</span>
<span id="cb33-20"><a href="#cb33-20"></a>              <span class="op">PP.&lt;+&gt;</span> primDoc p</span>
<span id="cb33-21"><a href="#cb33-21"></a>  <span class="kw">where</span></span>
<span id="cb33-22"><a href="#cb33-22"></a><span class="ot">    fieldDoc ::</span> <span class="dt">Field</span> x <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb33-23"><a href="#cb33-23"></a>    fieldDoc <span class="dt">Field</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc fieldName fieldValue</span>
<span id="cb33-24"><a href="#cb33-24"></a><span class="ot">    choiceDoc ::</span> <span class="dt">Choice</span> x <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb33-25"><a href="#cb33-25"></a>    choiceDoc <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc choiceName choiceValue</span>
<span id="cb33-26"><a href="#cb33-26"></a><span class="ot">    primDoc ::</span> <span class="dt">Primitive</span> x <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb33-27"><a href="#cb33-27"></a>    primDoc <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb33-28"><a href="#cb33-28"></a>      <span class="dt">PString</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;string&quot;</span></span>
<span id="cb33-29"><a href="#cb33-29"></a>      <span class="dt">PNumber</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;number&quot;</span></span>
<span id="cb33-30"><a href="#cb33-30"></a>      <span class="dt">PBool</span>   _ <span class="ot">-&gt;</span> <span class="st">&quot;bool&quot;</span></span></code></pre></div>
<p>Neat, we just had to replace <code>map (\fld -&gt; ..) fs</code> with <code>icollect (\fld -&gt; ...) fs</code>, and <code>map choiceDoc cs</code> with <code>icollect choiceDoc cs</code>. We were able to re-use the exact same logic — we lose no power and upgrading was a straightforward mechanical transformation.</p>
<h2 id="contravariant-consumption">Contravariant Consumption</h2>
<p>Now, let’s consider instead the situation where we would want to <em>serialize</em> an <code>a</code> with a schema. We’ll make a type <code>Schema a</code> that represents something that can encode an <code>a</code> as a json value; we’ll write a function:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">schemaToValue ::</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span></code></pre></div>
<p>To keep things simple, let’s forget all the parsing stuff for now; we’ll add it back in later. Let’s just create a type that can <em>only</em> serialize by enhancing our documentation schema.</p>
<p>Again, for the same reasons as before, we can get away with the only fundamental change being at the leaves/primitives. Our structure is very limited, and our schema type only expresses only variations within that limit, and the only variations (aside from sum/record structure) are how each leaf can be serialized.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L45-L48</span></span>
<span id="cb35-2"><a href="#cb35-2"></a></span>
<span id="cb35-3"><a href="#cb35-3"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>      <span class="dt">PString</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)</span>
<span id="cb35-5"><a href="#cb35-5"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (a <span class="ot">-&gt;</span> <span class="dt">Scientific</span>)</span>
<span id="cb35-6"><a href="#cb35-6"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span></code></pre></div>
<p>A <code>Primitive a</code> will be a way to <em>serialize</em> a json primitive — it can be <code>PString</code>, <code>PNumber</code>, or <code>PBool</code>. To create a “String Serializer”, you need to use <code>PString</code> with a function on “how to turn it into a <code>String</code>”. To create a “Bool parser”, you need <code>PBool</code> with a function on what how to turn the value into a <code>String</code>.</p>
<p>Again, it can be useful to add some helper primitives:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L67-L74</span></span>
<span id="cb36-2"><a href="#cb36-2"></a></span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="ot">pString ::</span> <span class="dt">Primitive</span> <span class="dt">String</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>pString <span class="ot">=</span> <span class="dt">PString</span> <span class="fu">id</span></span>
<span id="cb36-5"><a href="#cb36-5"></a></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="ot">pInt ::</span> <span class="dt">Primitive</span> <span class="dt">Int</span></span>
<span id="cb36-7"><a href="#cb36-7"></a>pInt <span class="ot">=</span> <span class="dt">PNumber</span> <span class="fu">fromIntegral</span></span>
<span id="cb36-8"><a href="#cb36-8"></a></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="ot">pBool ::</span> <span class="dt">Primitive</span> <span class="dt">Bool</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>pBool <span class="ot">=</span> <span class="dt">PBool</span> <span class="fu">id</span></span></code></pre></div>
<p><code>pString :: Primitive String</code> is the most basic way to serialize a primitive json string: just return the <code>String</code> itself. <code>pInt</code> needs to serialize the <code>Int</code> into a <code>Scientific</code> (the numeric type of the aeson library).</p>
<p>We can start off by writing the serializer for <code>Primitive</code> just go get a feel for how our serializer will work:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L147-L151</span></span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="ot">primToValue ::</span> <span class="dt">Primitive</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>primToValue <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb37-5"><a href="#cb37-5"></a>  <span class="dt">PString</span> f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> <span class="dt">Aeson.String</span> (T.pack (f x))</span>
<span id="cb37-6"><a href="#cb37-6"></a>  <span class="dt">PNumber</span> f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> <span class="dt">Aeson.Number</span> (f x)</span>
<span id="cb37-7"><a href="#cb37-7"></a>  <span class="dt">PBool</span>   f <span class="ot">-&gt;</span> \x <span class="ot">-&gt;</span> <span class="dt">Aeson.Bool</span>   (f x)</span></code></pre></div>
<p>Again, nothing too fancy — mostly plumbing along the <em>aeson</em> library’s primitive constructors.</p>
<h3 id="covariance-vs-contravariance">Covariance vs Contravariance</h3>
<p>Before we go further, let’s take a moment to pause and discuss the difference between covariant and contravariant functors, and the usefulness of those concepts. “Covariant” functors (or capital-F <code>Functor</code>s in Haskell) are functors <code>f</code> where you can consider <code>f a</code> as a “producer” of <code>a</code> — for example, <code>Schema a</code> from our parsing section is a thing you can use to parse/produce an <code>a</code> out of a bytestring. These are things where it makes sense to <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>: if you have a producer of <code>a</code>s, you can always “post-filter” the result with an <code>a -&gt; b</code> to get a producer of <code>b</code>s.</p>
<p>“Contravariant” functors (<code>Contravariant</code> in Haskell) are functors <code>f</code> where you can consider <code>f a</code> as a “consumer” of <code>a</code>. For example, <code>Primtive a</code> (and the <code>Schema a</code> we want to make) from our serializing section is something that consums <code>a</code>s and produces json values. These are things where it makes sense to <code>contramap</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="ot">    contramap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>which says: if you have a consumer of <code>b</code>s, you can always “pre-filter” the input with an <code>a -&gt; b</code> to get a consumer of <code>a</code>s.</p>
<h3 id="deducing-dec">Deducing Dec</h3>
<p>Now, back on to building our <code>Schema</code> type. Again, we might want to write something like</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>      <span class="dt">RecordType</span>  [<span class="dt">Field</span> a]</span>
<span id="cb39-3"><a href="#cb39-3"></a>    <span class="op">|</span> <span class="dt">SumType</span>     [<span class="dt">Choice</span> a]</span>
<span id="cb39-4"><a href="#cb39-4"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb39-5"><a href="#cb39-5"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L33-L39</span></span>
<span id="cb39-7"><a href="#cb39-7"></a></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="kw">data</span> <span class="dt">Field</span> a <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb39-9"><a href="#cb39-9"></a></span>
<span id="cb39-10"><a href="#cb39-10"></a><span class="kw">data</span> <span class="dt">Choice</span> a <span class="ot">=</span> <span class="dt">Choice</span></span></code></pre></div>
<p>However, we have a problem here — and it’s the opposite of the problem we had in the previous case. <code>Choice a</code> doesn’t quite make sense as the sum type consumer for <code>Schema a</code>, because each <code>Choice</code> is only meant to handle the types in a <em>specific</em> branch. For example, in our <code>Customer</code> example, for the <code>CPerson</code> branch we need a <code>Choice (String, Int)</code> to consume its contents, and in the <code>CBusiness</code> branch we need a <code>Choice Int</code> to consume its contents.</p>
<p>What we need is a way to express a hetereogenous collection/sequence of <code>Choice a</code>, coupled with a way of “choosing” exactly one of them to handle one form that our input <code>a</code> can take. A type that says “use exactly one of a bunch of <code>Choice</code>s of different <code>x</code>s, and choose one to dispatch depending on what <code>a</code> we get”.</p>
<p>This one is a little bit trickier to grasp “intuitively”, I feel, because contravariant abstractions and manipulations are much less common/ubiquitous in Haskell than the covariant ones. So how do we find the tool we need?</p>
<p><em>If</em> you are already familiar with contravariant abstractions (but who is?) you might recognize this as the essence of the <a href="https://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant-Divisible.html#g:6">Decidable</a> typeclass, from the <em><a href="https://hackage.haskell.org/package/contravariant">contravariant</a></em> library (or more accurately, <a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Conclude.html">Conclude</a>): a <code>Conclude f</code> allows you to combine two <code>f</code> values, and one will be picked to use based on inspection of the input value (I like to think of this one as the “sharding” abstraction). Then, like in the case with the parsers, we want to find a way to give <code>Choice</code> some <code>Conclude</code> interface, we could look for the “type that gives us a free <code>Conclude</code> structure”; we can look that up and see that it is <a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Divisible-Free.html"><code>Dec</code></a>, and so we use <code>Dec Choice a</code> for our sum type consumer.</p>
<p>But let’s say you’re like the vast majority of Haskell users and have never had any reason to look at the contravariant abstraction hierarchy. How would you think of this?</p>
<p>Like before, we can also look through the <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">functor combinatorpedia</a> (in specific, the contravariant section) and find:</p>
<blockquote>
<p><a href="https://blog.jle.im/entry/functor-combinatorpedia.html#dec-dec1"><strong>Dec / Dec1</strong></a></p>
<p><strong>Enhancement</strong>: The ability to provide multiple <code>f</code>s, one of which will be chosen to consume the overall input.</p>
<p>If <code>f x</code> is a consumer of <code>x</code>s, then <code>Dec f a</code> is a consumer of <code>a</code>s that does its job by choosing a single one of those <code>f</code>s to handle that consumption, based on what <code>a</code> is received.</p>
<p>For example, let’s say you had a type <code>Socket a</code> which represents some IO channel or socket that is expecting to receive <code>a</code>s. A <code>Dec Socket b</code> would be a collection of sockets that expects a single <code>b</code> overall, and will pick exactly one of those <code>f</code>s to handle that <code>b</code>.</p>
</blockquote>
<p>Sounds like exactly what we need!</p>
<h3 id="building-dec">Building Dec</h3>
<p>With this, we can write our final <code>Schema</code> type.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L28-L48</span></span>
<span id="cb40-2"><a href="#cb40-2"></a></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>      <span class="dt">RecordType</span>  (<span class="dt">Div</span> <span class="dt">Field</span> a)</span>
<span id="cb40-5"><a href="#cb40-5"></a>    <span class="op">|</span> <span class="dt">SumType</span>     (<span class="dt">Dec</span> <span class="dt">Choice</span> a)</span>
<span id="cb40-6"><a href="#cb40-6"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb40-7"><a href="#cb40-7"></a></span>
<span id="cb40-8"><a href="#cb40-8"></a><span class="kw">data</span> <span class="dt">Field</span> a <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb40-9"><a href="#cb40-9"></a>    {<span class="ot"> fieldName  ::</span> <span class="dt">String</span></span>
<span id="cb40-10"><a href="#cb40-10"></a>    ,<span class="ot"> fieldValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb40-11"><a href="#cb40-11"></a>    }</span>
<span id="cb40-12"><a href="#cb40-12"></a>  <span class="kw">deriving</span> <span class="dt">Generic</span></span>
<span id="cb40-13"><a href="#cb40-13"></a></span>
<span id="cb40-14"><a href="#cb40-14"></a><span class="kw">data</span> <span class="dt">Choice</span> a <span class="ot">=</span> <span class="dt">Choice</span></span>
<span id="cb40-15"><a href="#cb40-15"></a>    {<span class="ot"> choiceName  ::</span> <span class="dt">String</span></span>
<span id="cb40-16"><a href="#cb40-16"></a>    ,<span class="ot"> choiceValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb40-17"><a href="#cb40-17"></a>    }</span>
<span id="cb40-18"><a href="#cb40-18"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Generic1</span>)</span>
<span id="cb40-19"><a href="#cb40-19"></a></span>
<span id="cb40-20"><a href="#cb40-20"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb40-21"><a href="#cb40-21"></a>      <span class="dt">PString</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)</span>
<span id="cb40-22"><a href="#cb40-22"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (a <span class="ot">-&gt;</span> <span class="dt">Scientific</span>)</span>
<span id="cb40-23"><a href="#cb40-23"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</span></code></pre></div>
<p>Note that I switched from <code>[Field a]</code> to <code>Div Field a</code> — the two are the same, but the latter has the <code>Contravariant</code> instance we want (<code>contramap :: (a -&gt; b) -&gt; Div Field b -&gt; Div Field a</code>), and has useful functor combinator typeclass instances (like <code>ListF</code> before). And, again, I feel like it illustrates the symmetry between sum types and record types; <code>Div</code> and <code>Dec</code> are opposite types, as <code>Dec</code> represents a contravariant choice between different choices, and <code>Div</code> represents a contravariant merger between different consumers. It makes more clear the duality between product types and sum types.</p>
<p>We can assemble our <code>Customer</code> schema, in a way that looks a lot like our parser schema:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L81-L96</span></span>
<span id="cb41-2"><a href="#cb41-2"></a></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="ot">customerSchema ::</span> <span class="dt">Schema</span> <span class="dt">Customer</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>customerSchema <span class="ot">=</span> <span class="dt">SumType</span> <span class="op">$</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>    decide (\<span class="kw">case</span> <span class="dt">CPerson</span> x y <span class="ot">-&gt;</span> <span class="dt">Left</span> (x, y); <span class="dt">CBusiness</span> x <span class="ot">-&gt;</span> <span class="dt">Right</span> x)</span>
<span id="cb41-6"><a href="#cb41-6"></a>      (inject <span class="dt">Choice</span></span>
<span id="cb41-7"><a href="#cb41-7"></a>        { choiceName <span class="ot">=</span> <span class="st">&quot;Person&quot;</span></span>
<span id="cb41-8"><a href="#cb41-8"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span> <span class="op">$</span> divided</span>
<span id="cb41-9"><a href="#cb41-9"></a>            (inject <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Name&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> pString })</span>
<span id="cb41-10"><a href="#cb41-10"></a>            (inject <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Age&quot;</span> , fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> pInt    })</span>
<span id="cb41-11"><a href="#cb41-11"></a>        }</span>
<span id="cb41-12"><a href="#cb41-12"></a>      )</span>
<span id="cb41-13"><a href="#cb41-13"></a>      (inject <span class="dt">Choice</span></span>
<span id="cb41-14"><a href="#cb41-14"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Business&quot;</span></span>
<span id="cb41-15"><a href="#cb41-15"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span> <span class="op">$</span></span>
<span id="cb41-16"><a href="#cb41-16"></a>            inject <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Age&quot;</span> , fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> pInt    }</span>
<span id="cb41-17"><a href="#cb41-17"></a>        }</span>
<span id="cb41-18"><a href="#cb41-18"></a>      )</span></code></pre></div>
<p>Here we use a few contravariant combinators to combine and merge contravariant functors (like <code>Div Field</code> and <code>Dec Choice</code>):</p>
<p><code>decide</code> works like:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a>decide</span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="ot">    ::</span> <span class="dt">Decide</span> f</span>
<span id="cb42-3"><a href="#cb42-3"></a>    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Either</span> b c)    <span class="co">-- ^ break into branches</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>    <span class="ot">-&gt;</span> f b                  <span class="co">-- ^ handle first branch</span></span>
<span id="cb42-5"><a href="#cb42-5"></a>    <span class="ot">-&gt;</span> f c                  <span class="co">-- ^ handle second branch</span></span>
<span id="cb42-6"><a href="#cb42-6"></a>    <span class="ot">-&gt;</span> f a                  <span class="co">-- ^ overall handler</span></span>
<span id="cb42-7"><a href="#cb42-7"></a></span>
<span id="cb42-8"><a href="#cb42-8"></a>decide</span>
<span id="cb42-9"><a href="#cb42-9"></a><span class="ot">    ::</span> (<span class="dt">Customer</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">String</span>, <span class="dt">Int</span>) <span class="dt">Int</span>)   <span class="co">-- ^ break into branches</span></span>
<span id="cb42-10"><a href="#cb42-10"></a>    <span class="ot">-&gt;</span> <span class="dt">Dec</span> <span class="dt">Choice</span> (<span class="dt">String</span>, <span class="dt">Int</span>)                 <span class="co">-- ^ handle CPerson branch</span></span>
<span id="cb42-11"><a href="#cb42-11"></a>    <span class="ot">-&gt;</span> <span class="dt">Dec</span> <span class="dt">Choice</span> <span class="dt">Int</span>                           <span class="co">-- ^ handle CBusiness branch</span></span>
<span id="cb42-12"><a href="#cb42-12"></a>    <span class="ot">-&gt;</span> <span class="dt">Dec</span> <span class="dt">Choice</span> <span class="dt">Customer</span></span></code></pre></div>
<p>And <code>divised</code> works like:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a>divised</span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="ot">    ::</span> <span class="dt">Divise</span> f</span>
<span id="cb43-3"><a href="#cb43-3"></a>    <span class="ot">=&gt;</span> f a          <span class="co">-- ^ first handler</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>    <span class="ot">-&gt;</span> f b          <span class="co">-- ^ second handler</span></span>
<span id="cb43-5"><a href="#cb43-5"></a>    <span class="ot">-&gt;</span> f (a, b)     <span class="co">-- ^ merged handler</span></span>
<span id="cb43-6"><a href="#cb43-6"></a></span>
<span id="cb43-7"><a href="#cb43-7"></a>divised</span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="ot">    ::</span> <span class="dt">Divise</span> f</span>
<span id="cb43-9"><a href="#cb43-9"></a>    <span class="ot">=&gt;</span> <span class="dt">Div</span> <span class="dt">Field</span> <span class="dt">String</span>          <span class="co">-- ^ handle the cpName field</span></span>
<span id="cb43-10"><a href="#cb43-10"></a>    <span class="ot">-&gt;</span> <span class="dt">Div</span> <span class="dt">Field</span> <span class="dt">Int</span>             <span class="co">-- ^ handle the cpAge field</span></span>
<span id="cb43-11"><a href="#cb43-11"></a>    <span class="ot">-&gt;</span> <span class="dt">Div</span> <span class="dt">Field</span> (<span class="dt">String</span>, <span class="dt">Int</span>)   <span class="co">-- ^ handle both together</span></span></code></pre></div>
<h3 id="interpreting-dec">Interpreting Dec</h3>
<p>Now to write our schema serializers, we can use <code>interpret</code> again:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">interpret ::</span> <span class="dt">Divisible</span> g <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Field</span>  x <span class="ot">-&gt;</span> g x) <span class="ot">-&gt;</span> <span class="dt">Div</span> <span class="dt">Field</span>  a <span class="ot">-&gt;</span> g a</span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="ot">interpret ::</span> <span class="dt">Conclude</span> g  <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> <span class="dt">Choice</span> x <span class="ot">-&gt;</span> g x) <span class="ot">-&gt;</span> <span class="dt">Dec</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>But, what should we choose as our choice of <code>g</code>?</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>Well, how do we want to “use” a <code>Choice a</code>? Remember that <code>Schema a</code> encodes a way to serialize an <code>a</code> to an json value, a <code>Primitive a</code> is a way to serialize an <code>a</code> to a json value…a <code>Choice a</code> would be a way to serialize an <code>a</code> into a json value. We want to turn a <code>Choice a</code> into an <code>a -&gt; Aeson.Value</code>, using the <code>Value</code> type from the popular <em>aeson</em> library.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span>)</span>
<span id="cb46-2"><a href="#cb46-2"></a></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="co">-- is supposed to match up with</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>So we need to pick some <code>g</code> where <code>g a</code> is <code>a -&gt; Aeson.Value</code>. This is exactly <code>Op</code> from <em><a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Contravariant.html">Data.Functor.Contravariant</a></em>, in <em>base</em>:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">data</span> <span class="dt">Op</span> r a <span class="ot">=</span> <span class="dt">Op</span> {<span class="ot"> getOp ::</span> a <span class="ot">-&gt;</span> r }</span></code></pre></div>
<p>So, if we write</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Aeson.Value</span> a</span>
<span id="cb48-2"><a href="#cb48-2"></a></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="co">-- a newtype wrapper away from</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span></code></pre></div>
<p>then we have</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a>interpret<span class="ot"> choiceToValue ::</span> <span class="dt">Dec</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Aeson.Value</span> a</span>
<span id="cb49-2"><a href="#cb49-2"></a></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="co">-- a newtype wrapper away from</span></span>
<span id="cb49-4"><a href="#cb49-4"></a>interpret<span class="ot"> choiceToValue ::</span> <span class="dt">Dec</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span></code></pre></div>
<p>Let’s write it!</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L137-L141</span></span>
<span id="cb50-2"><a href="#cb50-2"></a></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Aeson.Value</span> a</span>
<span id="cb50-4"><a href="#cb50-4"></a>choiceToValue <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="dt">Op</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> Aeson.object</span>
<span id="cb50-5"><a href="#cb50-5"></a>    [ <span class="st">&quot;tag&quot;</span>      <span class="op">Aeson..=</span> T.pack choiceName</span>
<span id="cb50-6"><a href="#cb50-6"></a>    , <span class="st">&quot;contents&quot;</span> <span class="op">Aeson..=</span> schemaToValue choiceValue x</span>
<span id="cb50-7"><a href="#cb50-7"></a>    ]</span></code></pre></div>
<p>For the <code>RecordType</code>’s <code>Div Field a</code>, we want to build an object using <code>Aeson.object :: [Aeson.Pair] -&gt; Aeson.Value</code>, so we want to write some underlying interface</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a><span class="ot">fieldToValue ::</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Aeson.Pair</span>]</span></code></pre></div>
<p>This looks like we can just use <code>Op [Aeson.Pair]</code> as our context, so:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a><span class="ot">fieldToValue ::</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> [<span class="dt">Aeson.Pair</span>] a</span>
<span id="cb52-2"><a href="#cb52-2"></a></span>
<span id="cb52-3"><a href="#cb52-3"></a>interpret<span class="ot"> fieldToValue ::</span> <span class="dt">Div</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> [<span class="dt">Aeson.Pair</span>] a</span>
<span id="cb52-4"><a href="#cb52-4"></a></span>
<span id="cb52-5"><a href="#cb52-5"></a><span class="co">-- a newtype wrapper away from</span></span>
<span id="cb52-6"><a href="#cb52-6"></a>interpret<span class="ot"> fieldToValue ::</span> <span class="dt">Div</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Aeson.Pair</span>]</span></code></pre></div>
<p>We can go ahead and write it out actually:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L143-L145</span></span>
<span id="cb53-2"><a href="#cb53-2"></a></span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="ot">fieldToValue ::</span> <span class="dt">Field</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> [<span class="dt">Aeson.Pair</span>] a</span>
<span id="cb53-4"><a href="#cb53-4"></a>fieldToValue <span class="dt">Field</span>{<span class="op">..</span>} <span class="ot">=</span> <span class="dt">Op</span> <span class="op">$</span> \x <span class="ot">-&gt;</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>    [T.pack fieldName <span class="op">Aeson..=</span> schemaToValue fieldValue x]</span></code></pre></div>
<p>Note that this behavior relies on the fact that the <code>interpret</code> instance for <code>Div</code> (using the <code>Divise</code> instance for <code>Op r</code>) will combine the <code>[Aeson.Pair]</code> list monoidally, concatenating the results of calling <code>fieldToValue</code> on every <code>Field</code> in the <code>Div Field a</code>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>And now we should have enough to write our entire serializer:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L128-L135</span></span>
<span id="cb57-2"><a href="#cb57-2"></a></span>
<span id="cb57-3"><a href="#cb57-3"></a>schemaToValue</span>
<span id="cb57-4"><a href="#cb57-4"></a><span class="ot">    ::</span> <span class="dt">Schema</span> a</span>
<span id="cb57-5"><a href="#cb57-5"></a>    <span class="ot">-&gt;</span> a</span>
<span id="cb57-6"><a href="#cb57-6"></a>    <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span>
<span id="cb57-7"><a href="#cb57-7"></a>schemaToValue <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb57-8"><a href="#cb57-8"></a>    <span class="dt">SumType</span>    cs <span class="ot">-&gt;</span> getOp (interpret choiceToValue cs)</span>
<span id="cb57-9"><a href="#cb57-9"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> Aeson.object <span class="op">.</span> getOp (interpret fieldToValue fs)</span>
<span id="cb57-10"><a href="#cb57-10"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> primToValue p</span></code></pre></div>
<p>Running our <code>schemaToValue</code> on a sample <code>Person</code> gives the json value we expect:</p>
<pre><code>ghci&gt; Aeson.encode (schemaToValue customerSchema (CPerson &quot;Sam&quot; 40))
{&quot;tag&quot;:&quot;Person&quot;,&quot;contents&quot;:{&quot;Age&quot;:40,&quot;Name&quot;:&quot;Sam&quot;}}</code></pre>
<h3 id="backporting-documentation-1">Backporting documentation</h3>
<p>Because our new structure is pretty much the same as before (data types wrapped by functor combinators), and <code>Div</code>/<code>Dec</code> support <code>icollect</code> just like <code>Ap</code>/<code>ListF</code> did before, the implementation of <code>schemaDoc</code> is pretty much word-for-word identical as it was for our parser schema:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L98-L125</span></span>
<span id="cb59-2"><a href="#cb59-2"></a></span>
<span id="cb59-3"><a href="#cb59-3"></a>schemaDoc</span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="ot">    ::</span> <span class="dt">String</span>       <span class="co">-- ^ name</span></span>
<span id="cb59-5"><a href="#cb59-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Schema</span> x     <span class="co">-- ^ schema</span></span>
<span id="cb59-6"><a href="#cb59-6"></a>    <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb59-7"><a href="#cb59-7"></a>schemaDoc title <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb59-8"><a href="#cb59-8"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> PP.vsep [</span>
<span id="cb59-9"><a href="#cb59-9"></a>        PP.pretty (<span class="st">&quot;{&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;}&quot;</span>)</span>
<span id="cb59-10"><a href="#cb59-10"></a>      , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb59-11"><a href="#cb59-11"></a>          icollect (\fld <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span> <span class="op">PP.&lt;+&gt;</span> PP.indent <span class="dv">2</span> (fieldDoc fld)) fs</span>
<span id="cb59-12"><a href="#cb59-12"></a>      ]</span>
<span id="cb59-13"><a href="#cb59-13"></a>    <span class="dt">SumType</span> cs    <span class="ot">-&gt;</span> PP.vsep [</span>
<span id="cb59-14"><a href="#cb59-14"></a>        PP.pretty (<span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</span>
<span id="cb59-15"><a href="#cb59-15"></a>      , <span class="st">&quot;Choice of:&quot;</span></span>
<span id="cb59-16"><a href="#cb59-16"></a>      , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb59-17"><a href="#cb59-17"></a>          icollect choiceDoc cs</span>
<span id="cb59-18"><a href="#cb59-18"></a>      ]</span>
<span id="cb59-19"><a href="#cb59-19"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> PP.pretty (title <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span>)</span>
<span id="cb59-20"><a href="#cb59-20"></a>              <span class="op">PP.&lt;+&gt;</span> primDoc p</span>
<span id="cb59-21"><a href="#cb59-21"></a>  <span class="kw">where</span></span>
<span id="cb59-22"><a href="#cb59-22"></a><span class="ot">    fieldDoc ::</span> <span class="dt">Field</span> x <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb59-23"><a href="#cb59-23"></a>    fieldDoc <span class="dt">Field</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc fieldName fieldValue</span>
<span id="cb59-24"><a href="#cb59-24"></a><span class="ot">    choiceDoc ::</span> <span class="dt">Choice</span> x <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb59-25"><a href="#cb59-25"></a>    choiceDoc <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc choiceName choiceValue</span>
<span id="cb59-26"><a href="#cb59-26"></a><span class="ot">    primDoc ::</span> <span class="dt">Primitive</span> x <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> a</span>
<span id="cb59-27"><a href="#cb59-27"></a>    primDoc <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb59-28"><a href="#cb59-28"></a>      <span class="dt">PString</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;string&quot;</span></span>
<span id="cb59-29"><a href="#cb59-29"></a>      <span class="dt">PNumber</span> _ <span class="ot">-&gt;</span> <span class="st">&quot;number&quot;</span></span>
<span id="cb59-30"><a href="#cb59-30"></a>      <span class="dt">PBool</span>   _ <span class="ot">-&gt;</span> <span class="st">&quot;bool&quot;</span></span></code></pre></div>
<p>Neat!</p>
<h2 id="parsing-and-serializing-invariantly">Parsing and Serializing Invariantly</h2>
<p>At this point, we have:</p>
<ol type="1">
<li>Started with a simple ADT representing the structure we want to be able to express</li>
<li>Enhanced that simple ADT with Covariant Functor capabilities, in order to interpret it as a parser</li>
<li>Enhanced that original simple ADT with Contravariant Functor, in order to interpret it as a serializer.</li>
</ol>
<p>From this, it seems the next logical step would be to add <em>both</em> enhancements to the same structure!</p>
<p>There are some clear benefits to this — for example, we can now ensure that our “serialization” and “parsing” functions are always “in sync”. If we defined a separate process/type for serializing and a separate process/type for parsing, then it’s possible we might accidentally make errors in keeping them in sync…one might use a different tag, or we might make changes to one but not the other during refactoring.</p>
<p>Like before, the main thing we need to change at the fundamental level is <code>Primitive</code>:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L46-L49</span></span>
<span id="cb60-2"><a href="#cb60-2"></a></span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>      <span class="dt">PString</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)     (<span class="dt">String</span>     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb60-5"><a href="#cb60-5"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (a <span class="ot">-&gt;</span> <span class="dt">Scientific</span>) (<span class="dt">Scientific</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb60-6"><a href="#cb60-6"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       (<span class="dt">Bool</span>       <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span></code></pre></div>
<p>We’re just basically combining the additions we made to enable parsing with the additions we made to enable serialization. Our new <code>Primitive</code> type gives us the capability to do both!</p>
<p>We call this new <code>Primitive</code> an <a href="https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html">“Invariant” Functor</a>: these are functors that give you “both” capabilities: interpreting covariantly <em>and</em> contravariantly.</p>
<p>By now, we know the drill. We also need to change our <code>RecordType</code> and <code>SumType</code> constructors to get the right type of container.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a><span class="co">-- Covariant Schema</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L28-L32</span></span>
<span id="cb61-3"><a href="#cb61-3"></a></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb61-5"><a href="#cb61-5"></a>      <span class="dt">RecordType</span>  (<span class="dt">Ap</span> <span class="dt">Field</span> a)</span>
<span id="cb61-6"><a href="#cb61-6"></a>    <span class="op">|</span> <span class="dt">SumType</span>     (<span class="dt">ListF</span> <span class="dt">Choice</span> a)</span>
<span id="cb61-7"><a href="#cb61-7"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb61-8"><a href="#cb61-8"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb61-9"><a href="#cb61-9"></a></span>
<span id="cb61-10"><a href="#cb61-10"></a><span class="co">-- Contravariant Schema</span></span>
<span id="cb61-11"><a href="#cb61-11"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L28-L31</span></span>
<span id="cb61-12"><a href="#cb61-12"></a></span>
<span id="cb61-13"><a href="#cb61-13"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb61-14"><a href="#cb61-14"></a>      <span class="dt">RecordType</span>  (<span class="dt">Div</span> <span class="dt">Field</span> a)</span>
<span id="cb61-15"><a href="#cb61-15"></a>    <span class="op">|</span> <span class="dt">SumType</span>     (<span class="dt">Dec</span> <span class="dt">Choice</span> a)</span>
<span id="cb61-16"><a href="#cb61-16"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span></code></pre></div>
<p>For the covariant <code>RecordType</code>, we used <code>Ap Field a</code>. For the contravariant <code>RecordType</code>, we used <code>Div Field a</code>. Is there a type that combines <em>both</em> <code>Ap</code> and <code>Div</code>?</p>
<p>Ah, we’re in luck! We have <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DivAp.html">DivAp</a></em> from the <em>functor-combinatotrs</em> library…which is named to invoke the idea of having both <code>Ap</code> and <code>Div</code> capabilities, combined together.</p>
<p>For the covariant <code>SumType</code>, we used <code>ListF Choice a</code>. For the contravariant <code>SumType</code>, we used <code>Dec Choice a</code>. Is there a type that combines <em>both</em> <code>ListF</code> and <code>Dec</code>?</p>
<p>Ah hah, if we look nearby <code>DivAp</code>, we see the answer: <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DecAlt.html">DecAlt</a></em>! It combines both <code>ListF</code> and <code>Dec</code>.</p>
<p>Now let’s wire it up:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L31-L49</span></span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>      <span class="dt">RecordType</span>  (<span class="dt">DivAp</span>   <span class="dt">Field</span>  a)</span>
<span id="cb62-5"><a href="#cb62-5"></a>    <span class="op">|</span> <span class="dt">SumType</span>     (<span class="dt">DecAlt</span> <span class="dt">Choice</span> a)</span>
<span id="cb62-6"><a href="#cb62-6"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb62-7"><a href="#cb62-7"></a></span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="kw">data</span> <span class="dt">Field</span> a <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb62-9"><a href="#cb62-9"></a>    {<span class="ot"> fieldName  ::</span> <span class="dt">String</span></span>
<span id="cb62-10"><a href="#cb62-10"></a>    ,<span class="ot"> fieldValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb62-11"><a href="#cb62-11"></a>    }</span>
<span id="cb62-12"><a href="#cb62-12"></a></span>
<span id="cb62-13"><a href="#cb62-13"></a><span class="kw">data</span> <span class="dt">Choice</span> a <span class="ot">=</span> <span class="dt">Choice</span></span>
<span id="cb62-14"><a href="#cb62-14"></a>    {<span class="ot"> choiceName  ::</span> <span class="dt">String</span></span>
<span id="cb62-15"><a href="#cb62-15"></a>    ,<span class="ot"> choiceValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb62-16"><a href="#cb62-16"></a>    }</span>
<span id="cb62-17"><a href="#cb62-17"></a></span>
<span id="cb62-18"><a href="#cb62-18"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb62-19"><a href="#cb62-19"></a>      <span class="dt">PString</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)     (<span class="dt">String</span>     <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb62-20"><a href="#cb62-20"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (a <span class="ot">-&gt;</span> <span class="dt">Scientific</span>) (<span class="dt">Scientific</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb62-21"><a href="#cb62-21"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       (<span class="dt">Bool</span>       <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I’m using <code>x</code> as the name of the type variable (instead of something more traditional like <code>a</code>) to indicate that it isn’t meant to be referenced or used anywhere in any consistent way. Just remember it doesn’t mean anything special syntactically!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><code>icollect</code> function is nothing magical — it’s essentially <code>interpret</code> wrapped with <code>Const</code>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">-- essentially</span></span>
<span id="cb30-2"><a href="#cb30-2"></a>icollect f <span class="ot">=</span> getConst <span class="op">.</span> interpret (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> [f x])</span></code></pre></div>
<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn3" role="doc-endnote"><p>Note that this contravariant interpretation pattern (wrapping in <code>Op</code> and then unwrapping it again to run it) is so common that <em>functor-combinators</em> has a helper function to make things a bit neater:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a><span class="ot">iapply  ::</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> x <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dec</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="ot">ifanout ::</span> (<span class="kw">forall</span> x<span class="op">.</span> f x <span class="ot">-&gt;</span> x <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Div</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b]</span></code></pre></div>
<p>With these we could write</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a><span class="ot">choiceToValue ::</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="ot">fieldToValue  ::</span> <span class="dt">Field</span> a  <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Aeson.Pair</span>]</span></code></pre></div>
<p>And then:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a>iapply<span class="ot"> choiceToValue ::</span> <span class="dt">Dec</span> <span class="dt">Choice</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Aeson.Value</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>ifanout<span class="ot"> fieldToValue ::</span> <span class="dt">Div</span> <span class="dt">Field</span>  a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Aeson.Pair</span>]</span></code></pre></div>
<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/free.html" class="tag-a-tag">#free</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/interpreters.html" class="tag-a-tag">#interpreters</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html';
    this.page.identifier = 'functor-structures-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>