<!DOCTYPE HTML>
<html><head><title>Enhancing Functor Structures Step-By-Step (Part 1) · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="A style of Haskell programming that I’ve been pretty excited about with over the past year or so is something that I can maybe call a “functor structure” designed pattern. This is the interest that culminated in my Functor Combinatorpedia post last year and the functor-combinators library. In the blog post I called this style the “functor combinator” style because it involved building these functor structures out of small, simple pieces. This is just one way to build functor structures — you could always just make them directly from scratch, but they can get rather messy and it’s often times easier to use pre-made structures that have all the helper functions already defined for you. But I never really talked about how you would build them from scratch, and also never really explored the more exotic types of lowercase-f functors in Hask — contravariant functors and invariant functors. In this post we’re going to be exploring these different types of functor structures step-by-step, by starting with a simple useful structure and enhancing it piece by piece. This process reflects a lot of the way I personally work through these things — I normally don’t get the whole powerful structure all the way; instead I incrementally add things as I see how things fit together. We’re going build the tools to describe a json schema, in the form of an algebraic data type – sums and products. We’ll start off just building things we can use to describe the schema (by printing out documentation), and by the end of the journey we’ll also be able to parse and generate values with our schema. This series is designed for an intermediate Haskeller with familiarity in things like monadic parser combinators."><meta property="og:type" content="article"><meta property="og:title" content="Enhancing Functor Structures Step-By-Step (Part 1)"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Enhancing Functor Structures Step-By-Step (Part 1)</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/functor-structures-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/enhancing-functor-structures-step-by-step-1.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>A style of Haskell programming that I’ve been pretty excited about with over the past year or so is something that I can maybe call a “functor structure” designed pattern. This is the interest that culminated in my <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">Functor Combinatorpedia</a> post last year and the <a href="https://hackage.haskell.org/package/functor-combinators">functor-combinators</a> library. In the blog post I called this style the “functor combinator” style because it involved building these functor structures out of small, simple pieces. This is just one way to build functor structures — you could always just make them directly from scratch, but they can get rather messy and it’s often times easier to use pre-made structures that have all the helper functions already defined for you. But I never really talked about <em>how</em> you would build them from scratch, and also never really explored the more exotic types of lowercase-f functors in Hask — contravariant functors and invariant functors.</p>
<p>In this post we’re going to be exploring these different types of functor structures step-by-step, by starting with a simple useful structure and enhancing it piece by piece. This process reflects a lot of the way I personally work through these things — I normally don’t get the whole powerful structure all the way; instead I incrementally add things as I see how things fit together.</p>
<p>We’re going build the tools to describe a <em>json schema</em>, in the form of an algebraic data type – sums and products. We’ll start off just building things we can use to <em>describe</em> the schema (by printing out documentation), and by the end of the journey we’ll also be able to parse and generate values with our schema.</p>
<p>This series is designed for an intermediate Haskeller with familiarity in things like monadic parser combinators.</p>
<h2 id="the-schema">The Schema</h2>
<p>Let’s start with the simplest level of describing our schema: a plain ol’ AST describing the possibilities our schema can take.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L10-L32</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">data</span> <span class="dt">Schema</span> <span class="ot">=</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>      <span class="dt">RecordType</span>  [<span class="dt">Field</span>]</span>
<span id="cb1-5"><a href="#cb1-5"></a>    <span class="op">|</span> <span class="dt">SumType</span>     [<span class="dt">Choice</span>]</span>
<span id="cb1-6"><a href="#cb1-6"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  <span class="dt">Primitive</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">data</span> <span class="dt">Choice</span> <span class="ot">=</span> <span class="dt">Choice</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    {<span class="ot"> choiceName  ::</span> <span class="dt">String</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    ,<span class="ot"> choiceValue ::</span> <span class="dt">Schema</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    }</span>
<span id="cb1-13"><a href="#cb1-13"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="kw">data</span> <span class="dt">Field</span> <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    {<span class="ot"> fieldName  ::</span> <span class="dt">String</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    ,<span class="ot"> fieldValue ::</span> <span class="dt">Schema</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    }</span>
<span id="cb1-19"><a href="#cb1-19"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb1-20"><a href="#cb1-20"></a></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="kw">data</span> <span class="dt">Primitive</span> <span class="ot">=</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>      <span class="dt">PString</span></span>
<span id="cb1-23"><a href="#cb1-23"></a>    <span class="op">|</span> <span class="dt">PNumber</span></span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="op">|</span> <span class="dt">PBool</span></span>
<span id="cb1-25"><a href="#cb1-25"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>Our schema will either represent a record of many different fields, a sum of many different options, or a primitive value. If it’s a sum type, it’ll be described by a list of <code>Choice</code>, which describes each branch. If it’s a record type, it’ll be described by a list of <code>Field</code>, which describes each field. If it’s a primitive type, it’ll a <code>Primitive</code>, which is either a string, number, or boolean.</p>
<p>Our end goal is to be able to write a schema for a type like</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L34-L37</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">data</span> <span class="dt">Customer</span> <span class="ot">=</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>      <span class="dt">CPerson</span>   {<span class="ot"> cpName ::</span> <span class="dt">String</span>,<span class="ot"> cpAge ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="op">|</span> <span class="dt">CBusiness</span> {<span class="ot"> cbEmployees ::</span> <span class="dt">Int</span> }</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>and be able to represent documenting, parsing, and printing it all within <code>Schema</code>. For our basic <code>Schema</code> above, this looks like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L39-L53</span></span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ot">customerSchema ::</span> <span class="dt">Schema</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>customerSchema <span class="ot">=</span> <span class="dt">SumType</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>    [ <span class="dt">Choice</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Person&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>            [ <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Name&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> <span class="dt">PString</span> }</span>
<span id="cb3-9"><a href="#cb3-9"></a>            , <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Age&quot;</span> , fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> <span class="dt">PNumber</span> }</span>
<span id="cb3-10"><a href="#cb3-10"></a>            ]</span>
<span id="cb3-11"><a href="#cb3-11"></a>        }</span>
<span id="cb3-12"><a href="#cb3-12"></a>    , <span class="dt">Choice</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        { choiceName  <span class="ot">=</span> <span class="st">&quot;Business&quot;</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>        , choiceValue <span class="ot">=</span> <span class="dt">RecordType</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>            [ <span class="dt">Field</span> { fieldName <span class="ot">=</span> <span class="st">&quot;Employees&quot;</span>, fieldValue <span class="ot">=</span> <span class="dt">SchemaLeaf</span> <span class="dt">PNumber</span> } ]</span>
<span id="cb3-16"><a href="#cb3-16"></a>        }</span>
<span id="cb3-17"><a href="#cb3-17"></a>    ]</span></code></pre></div>
<p>And a value like</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="dt">PCustomer</span> { cpName <span class="ot">=</span> <span class="st">&quot;Sam&quot;</span>, cpAge <span class="ot">=</span> <span class="dv">40</span> }</span></code></pre></div>
<p>might be represented by a json value like</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode json"><code class="sourceCode json"><span id="cb5-1"><a href="#cb5-1"></a><span class="fu">{</span> <span class="dt">&quot;tag&quot;</span><span class="fu">:</span> <span class="st">&quot;Customer&quot;</span><span class="fu">,</span> </span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="dt">&quot;contents&quot;</span><span class="fu">:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="fu">{</span> <span class="dt">&quot;Name&quot;</span><span class="fu">:</span> <span class="st">&quot;Sam&quot;</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>    <span class="fu">,</span> <span class="dt">&quot;Age&quot;</span><span class="fu">:</span> <span class="fl">40.0</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="fu">}</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="fu">}</span></span></code></pre></div>
<h2 id="documentation">Documentation</h2>
<p>Using our schema type, let’s make a documentation generator. It’ll take a <code>Schema</code> and nicely formatted documentation describing what the schema itself.</p>
<p>To make our lives easier, we’ll be using the <em><a href="https://hackage.haskell.org/package/prettyprinter">prettyprinter</a></em> library, which will handle indentation, horizontal and vertical concatenation, and other printing concerns for us.</p>
<p>The structure of this will match the structure of our future schema processors — you’ll find they all look like this in some form or another!</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L55-L62</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>schemaDoc</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">    ::</span> <span class="dt">String</span>       <span class="co">-- ^ name</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    <span class="ot">-&gt;</span> <span class="dt">Schema</span>       <span class="co">-- ^ schema</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb6-7"><a href="#cb6-7"></a>schemaDoc title <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    <span class="dt">RecordType</span> fs <span class="ot">-&gt;</span> recordDoc title fs</span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="dt">SumType</span> cs    <span class="ot">-&gt;</span> sumDoc title cs</span>
<span id="cb6-10"><a href="#cb6-10"></a>    <span class="dt">SchemaLeaf</span> p  <span class="ot">-&gt;</span> leafDoc title p</span></code></pre></div>
<p>So <code>schemaDoc</code> will take the name of our type and a schema, and generate a <code>PP.Doc x</code>, the type of a text document in the <em>prettyprinter</em> library.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Nothing too fancy here other than simply matching on what type of schema we’re dealing with, and dispatching a different function for each type.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L64-L72</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">recordDoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Field</span>] <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb7-4"><a href="#cb7-4"></a>recordDoc title fs <span class="ot">=</span> PP.vsep [</span>
<span id="cb7-5"><a href="#cb7-5"></a>      PP.pretty (<span class="st">&quot;{&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;}&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>    , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>        <span class="fu">map</span> (\fld <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span> <span class="op">PP.&lt;+&gt;</span> PP.indent <span class="dv">2</span> (fieldDoc fld)) fs</span>
<span id="cb7-8"><a href="#cb7-8"></a>    ]</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="kw">where</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="ot">    fieldDoc ::</span> <span class="dt">Field</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb7-11"><a href="#cb7-11"></a>    fieldDoc <span class="dt">Field</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc fieldName fieldValue</span></code></pre></div>
<p>First, the <code>RecordType</code> handler uses <code>PP.vsep</code>, which takes a list of docs and concatenates them together vertically. The first doc is the title around curly braces, and the second doc is a <code>*</code>’d list of <code>fieldDoc</code> for each <code>fs</code>, concatenated vertically and indented two spaces.</p>
<p><code>fieldDoc</code> itself is then going to recursively call <code>schemaDoc</code> with the field name as the title and the field value as the sub-schema.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L74-L83</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ot">sumDoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Choice</span>] <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb8-4"><a href="#cb8-4"></a>sumDoc title cs <span class="ot">=</span> PP.vsep [</span>
<span id="cb8-5"><a href="#cb8-5"></a>      PP.pretty (<span class="st">&quot;(&quot;</span> <span class="op">&lt;&gt;</span> title <span class="op">&lt;&gt;</span> <span class="st">&quot;)&quot;</span>)</span>
<span id="cb8-6"><a href="#cb8-6"></a>    , <span class="st">&quot;Choice of:&quot;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    , PP.indent <span class="dv">2</span> <span class="op">.</span> PP.vsep <span class="op">$</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="fu">map</span> choiceDoc cs</span>
<span id="cb8-9"><a href="#cb8-9"></a>    ]</span>
<span id="cb8-10"><a href="#cb8-10"></a>  <span class="kw">where</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="ot">    choiceDoc ::</span> <span class="dt">Choice</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb8-12"><a href="#cb8-12"></a>    choiceDoc <span class="dt">Choice</span>{<span class="op">..</span>} <span class="ot">=</span> schemaDoc choiceName choiceValue</span></code></pre></div>
<p>The <code>SumType</code> handler is going to be doing more or less the same thing, except surrounding the title in <code>(</code> <code>)</code> parentheses. There’s another line <code>Choice of:</code>, followed by the list of each choice, vertically concatenated and indented twice.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L85-L93</span></span>
<span id="cb9-2"><a href="#cb9-2"></a></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">leafDoc ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Primitive</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb9-4"><a href="#cb9-4"></a>leafDoc title p <span class="ot">=</span> PP.pretty (title <span class="op">&lt;&gt;</span> <span class="st">&quot;:&quot;</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a>           <span class="op">PP.&lt;+&gt;</span> primDoc p</span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="ot">    primDoc ::</span> <span class="dt">Primitive</span> <span class="ot">-&gt;</span> <span class="dt">PP.Doc</span> x</span>
<span id="cb9-8"><a href="#cb9-8"></a>    primDoc <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>      <span class="dt">PString</span> <span class="ot">-&gt;</span> <span class="st">&quot;string&quot;</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>      <span class="dt">PNumber</span> <span class="ot">-&gt;</span> <span class="st">&quot;number&quot;</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>      <span class="dt">PBool</span>   <span class="ot">-&gt;</span> <span class="st">&quot;bool&quot;</span></span></code></pre></div>
<p>Finally, the <code>leafDoc</code> handler prints out the schema of a single list: it gives the name of the leaf and then either <code>"string"</code>, <code>"number"</code>, or <code>"bool"</code>.</p>
<p>Hopefully that wasn’t too bad! There were a lot of moving parts because we have a recursive data type, but in the end hopefully each specific branch was self-contained enough to understand on their own. We can test it out on <code>customerSchema</code>, taking advantage of the fact that <code>PP.Doc</code>’s <code>Show</code> instance will render the document:</p>
<pre><code>ghci&gt; schemaDoc &quot;Customer&quot; customerSchema
(Customer)
Choice of:
  {Person}
    *   Name: string
    *   Age: number
  {Business}
    *   Employees: number</code></pre>
<p>It works!</p>
<h2 id="parsing-with-covariance">Parsing with Covariance</h2>
<p>Now, let’s talk about using our <code>Schema</code> type to define a json parser. We’re going to rewrite <code>Schema</code> to take a type parameter to represent the type we want to parse into. A <code>Schema a</code> will be a schema that can be used to generate documentation <em>and</em> describe a parser of <code>a</code>s. In the end, we want <code>customerSchema :: Schema Customer</code>, and a function like</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">schemaParser ::</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> <span class="dt">Parse</span> <span class="dt">ErrType</span> a</span></code></pre></div>
<p>to generate a json parser of <code>a</code>s. We’ll be using the json parser type <code>Parse err a</code> from <em><a href="https://hackage.haskell.org/package/aeson-better-errors">aeson-better-errors</a></em> (not because of the better errors, but just because it’s closer to an actual incremental/stateful parser than other alternatives out there), which can be run with <code>parse :: Parse err a -&gt; ByteString -&gt; Either (ParseError err) a</code>. So our final interface will look like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L142-L143</span></span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="ot">parseSchema ::</span> <span class="dt">Schema</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">A.ParseError</span> <span class="dt">ErrType</span>) a</span>
<span id="cb12-4"><a href="#cb12-4"></a>parseSchema sc <span class="ot">=</span> A.parse (schemaParser sc)</span></code></pre></div>
<p>To do this, we now have to include information on “how to parse an <code>a</code>” in our schema. Remember that our actual json format is pretty fixed/structured, so we don’t need to address things like how to encode sum types within our <code>Schema</code> type itself. The only variation that our <code>Schema</code> can express can be isolated to one place: the <code>Primitive</code> type.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L43-L56</span></span>
<span id="cb13-2"><a href="#cb13-2"></a></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">data</span> <span class="dt">Primitive</span> a <span class="ot">=</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>      <span class="dt">PString</span> (<span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="op">|</span> <span class="dt">PNumber</span> (<span class="dt">Scientific</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="op">|</span> <span class="dt">PBool</span>   (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb13-7"><a href="#cb13-7"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="ot">pString ::</span> <span class="dt">Primitive</span> <span class="dt">String</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>pString <span class="ot">=</span> <span class="dt">PString</span> <span class="dt">Just</span></span>
<span id="cb13-11"><a href="#cb13-11"></a></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="ot">pInt ::</span> <span class="dt">Primitive</span> <span class="dt">Int</span></span>
<span id="cb13-13"><a href="#cb13-13"></a>pInt <span class="ot">=</span> <span class="dt">PNumber</span> toBoundedInteger</span>
<span id="cb13-14"><a href="#cb13-14"></a></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="ot">pBool ::</span> <span class="dt">Primitive</span> <span class="dt">Bool</span></span>
<span id="cb13-16"><a href="#cb13-16"></a>pBool <span class="ot">=</span> <span class="dt">PBool</span> <span class="dt">Just</span></span></code></pre></div>
<p>And that’s it! Different data types will parse these primitive values in different ways, but other than that, everything is sort of already pre-determined. Remember, our <code>Schema</code> type is only meant to express the different ways our rigidly defined structure can vary.</p>
<h3 id="finding-ap">Finding Ap</h3>
<p>However, this small change (and adding the type parameter) leaves in a predicament. What should <code>Schema</code> look like?</p>
<p>At first glance, we might think we could just write</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>      <span class="dt">RecordType</span>  [<span class="dt">Field</span> a]</span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="op">|</span> <span class="dt">SumType</span>     [<span class="dt">Choice</span> a]</span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb14-5"><a href="#cb14-5"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L31-L41</span></span>
<span id="cb14-8"><a href="#cb14-8"></a></span>
<span id="cb14-9"><a href="#cb14-9"></a><span class="kw">data</span> <span class="dt">Field</span> a <span class="ot">=</span> <span class="dt">Field</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>    {<span class="ot"> fieldName  ::</span> <span class="dt">String</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>    ,<span class="ot"> fieldValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb14-12"><a href="#cb14-12"></a>    }</span>
<span id="cb14-13"><a href="#cb14-13"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb14-14"><a href="#cb14-14"></a></span>
<span id="cb14-15"><a href="#cb14-15"></a><span class="kw">data</span> <span class="dt">Choice</span> a <span class="ot">=</span> <span class="dt">Choice</span></span>
<span id="cb14-16"><a href="#cb14-16"></a>    {<span class="ot"> choiceName  ::</span> <span class="dt">String</span></span>
<span id="cb14-17"><a href="#cb14-17"></a>    ,<span class="ot"> choiceValue ::</span> <span class="dt">Schema</span> a</span>
<span id="cb14-18"><a href="#cb14-18"></a>    }</span>
<span id="cb14-19"><a href="#cb14-19"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>But there’s a problem here: <code>RecordType</code> is a combination of <code>Field</code>s, but…each <code>Field</code> is of a different type! For example, in our <code>Customer</code> example, the <code>Person</code> branch has two fields: <code>Name</code> and <code>Age</code>. Our name schema would look like <code>nameField :: Field String</code>, and our age schema would look like <code>ageField :: Field Int</code>…and so you can’t really put that into a list like <code>[Field a]</code> since they each have different types. And further more, we want a final <code>Customer</code> (in our <code>Schema Customer</code>), a type which is different from both <code>String</code> and <code>Int</code>.</p>
<p>What we need is a way to express heterogeneous collection/sequence of <code>Field a</code>, coupled with a way of “combining” all of them to create an aggregate value of a final type. A type that says “use a bunch of <code>Field</code> of <code>x</code>s of different types to generate a final <code>a</code>”.</p>
<p>There are a couple of ways to arrive at this mystery type. One way is to recognize “combine a bunch of <code>f x</code>s of different types to create an <code>f b</code>” is essentially the MO of the <em>Applicative</em> abstraction, and so essentially we want to give <code>Field</code> some sort of <code>Applicative</code> structure. And so we can reach for “the type that gives something an <code>Applicative</code> structure”, the <a href="https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html">free applicative</a>.</p>
<p>Another way is to think about it as an enhancement along a functor combinator described in the <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">functor combinatorpedia</a>. Here we know we want to enhance <code>Field</code> in a specific way, so we can scan the list of functor combinators until there is one that we need. And scrolling down, we see:</p>
<blockquote>
<p><a href="https://blog.jle.im/entry/functor-combinatorpedia.html#ap-ap1"><strong>Ap / Ap1 </strong></a></p>
<p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html">Control.Applicative.Free</a></em> / <em><a href="https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html">Data.Functor.Apply.Free</a></em></p>
<p><strong>Enhancement</strong>: The ability to provide multiple <code>f</code>s that the interpreter <em>must</em> consume <em>all</em> of. (…)</p>
<p>While <code>ListF</code> may be considered “multiple options <em>offered</em>”, <code>Ap</code> can be considered “multiple actions all <em>required</em>”. The interpreter must consume/interpret <em>all</em> of the multiple <code>f</code>s in order to interpret an <code>Ap</code>.</p>
<p>Note that ordering is not enforced: while the consumer must handle each <code>f</code> eventually, they are free to handle it in whatever order they desire. In fact, they could even all be handled in parallel. See <code>Free</code> for a version where ordering is enforced.</p>
<p>…</p>
<p>Because this has an <code>Applicative</code> instance, you can use <code>(&lt;*&gt;) :: Ap f (a -&gt; b) -&gt; Ap f a -&gt; Ap f b</code> to sequence multiple <code>Ap f</code>s together, and <code>pure :: a -&gt; Ap f a</code> to produce a “no-op” <code>Ap</code> without any <code>f</code>s.</p>
</blockquote>
<p>That sounds like it matches to me! In order to parse a <code>RecordType</code>, we need to parse <em>every</em> <code>Field</code>. It doesn’t make any sense to skip one field or the other: they all need to be processed and parsed. This sounds like just the thing we need.</p>
<p>The description here also gives a clue for what we might want to use for <code>SumType</code> (<code>ListF</code> sounds like a good companion for the behavior we want sum type parsers to have)</p>
<p>Another way to come to this conclusion is to think about it in terms of tensoring functors: “how do we want to tensor together <em>two</em> <code>Field</code>s”?</p>
<p>Well, earlier we said that we want to combine fields of different types, while also providing a way of combining the two types together to create a final aggregate type. We can express this in Haskell with something like:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">data</span> <span class="dt">TwoFields</span> <span class="ot">=</span> <span class="kw">forall</span> x y<span class="op">.</span> <span class="dt">TwoFields</span> (<span class="dt">Field</span> x) (<span class="dt">Field</span> y) (x <span class="ot">-&gt;</span> y <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>In existential syntax, this says that <code>TwoFields a</code> consists of <code>Field x</code> and <code>Field y</code> of a “hidden” <code>x</code> and <code>y</code>, as well as a function to combine the <code>x</code> and <code>y</code> to make an <code>a</code>.</p>
<p>We can look up what type of tensor this is in the functor combinatorpedia. Scrolling down, we see:</p>
<blockquote>
<p><a href="https://blog.jle.im/entry/functor-combinatorpedia.html#day"><strong>Day</strong></a></p>
<p><strong>Origin</strong>: <em><a href="https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Day.html">Data.Functor.Day</a></em></p>
<p><strong>Mixing Strategy</strong>: “Both, together forever”: provide values from <em>both</em> functors, and the user <em>must</em> also <em>use</em> both.</p>
<p>…</p>
<p>Unlike for <code>:*:</code>, you always have to interpret <em>both</em> functor values in order to interpret a <code>Day</code>. It’s a “full mixing”.</p>
<p>The mechanism for this is interesting in and of itself. Looking at the definition of the data type:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">data</span> <span class="dt">Day</span> f g a <span class="ot">=</span> <span class="kw">forall</span> x y<span class="op">.</span> <span class="dt">Day</span> (f x) (g y) (x <span class="ot">-&gt;</span> y <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>We see that because <code>x</code> and <code>y</code> are “hidden” from the external world, we can’t directly use them without applying the “joining” function <code>x -&gt; y -&gt; a</code>. Due to how existential types work, we can’t get anything out of it that “contains” <code>x</code> or <code>y</code>. Because of this, <em>using</em> the joining function requires <em>both</em> <code>f x</code> and <code>g y</code>. If we only use <code>f x</code>, we can only get, at best,<code>f (y -&gt; a)</code>; if we only use <code>g y</code>, we can only get, at best, <code>g (x -&gt; a)</code>. In order to fully eliminate <em>both</em> existential variables, we need to get the <code>x</code> and <code>y</code> from <em>both</em> <code>f x</code> and <code>g y</code>, as if the two values held separate halves of the key.</p>
</blockquote>
<p>It seems as if our <code>TwoFields</code> is exactly <code>Day Field Field</code>, so we’re on the right track.</p>
<p>Reading further on in the <code>Day</code> section, we see that a list of “<code>f</code>s dayed with each other multiple times” is precisely <code>Ap f</code>.</p>
<h3 id="using-ap">Using Ap</h3>
<p>With this let’s write our final <code>Schema</code> type:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L25-L29</span></span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">data</span> <span class="dt">Schema</span> a <span class="ot">=</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>      <span class="dt">RecordType</span>  (<span class="dt">Ap</span> <span class="dt">Field</span> a)</span>
<span id="cb17-5"><a href="#cb17-5"></a>    <span class="op">|</span> <span class="dt">SumType</span>     (<span class="dt">ListF</span> <span class="dt">Choice</span> a)</span>
<span id="cb17-6"><a href="#cb17-6"></a>    <span class="op">|</span> <span class="dt">SchemaLeaf</span>  (<span class="dt">Primitive</span> a)</span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I’m using <code>x</code> as the name of the type variable (instead of something more traditional like <code>a</code>) to indicate that it isn’t meant to be referenced or used anywhere in any consistent way. Just remember it doesn’t mean anything special syntactically!<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/free.html" class="tag-a-tag">#free</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/interpreters.html" class="tag-a-tag">#interpreters</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html';
    this.page.identifier = 'functor-structures-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>