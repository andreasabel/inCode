<!DOCTYPE HTML>
<html><head><title>Advent of Haskell: Roll your own Holly Jolly streaming combinator library with
Free · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Hi! Welcome, if you’re joining us from the great Advent of Haskell 2020 event! Feel free to grab a hot chocolate and sit back by the fireplace. I’m honored to be able to be a part of the event this year; it’s a great initiative and harkens back to the age-old Haskell tradition of bite-sized Functional Programming “advent calendars”. I remember when I was first learning Haskell, 24 Days of Hackage was one of my favorite series that helped me really get into the exciting world of Haskell and the all the doors that functional programming can open. For my entry, in the spirit of the holidays, I decided to treat it as a chance to go reminisce about Haskell times of olde. Right now in Haskell we seem to be in an era where the great debate in the future of the language is in the best way to handle composable effects in Haskell, but if we roll back the calendar to the beginning of the decade, this big existential war was in the best way to handle constant-space effectful streaming. The dust on that debate has more or less settled (the apparent answer: it doesn’t really matter, just use whatever is more integrated with what you are already using and has a more robust relevant ecosystem built around it), but recently I had an occasion to explore the space myself. I needed a specific sort of streaming behavior that I couldn’t express cleanly exactly in any of the major options and I thought to look into what it would take to roll your own using the “modern” tools of 2020. In the end it was a fun journey, because it helped me understand things a lot better in a way I probably could not have reached on my own when I was just starting out in Haskell when this topic was “hot”. So in this post we’ll be attempting to roll our own monadic streaming effects combinators in a way that is made surprisingly (at least, to me) clean if we approach it from a composable effects sort of style — hopefully demonstrating how natural a lot of previously complex topics become if we just imagine them in the context of composable effects!"><meta property="og:type" content="article"><meta property="og:title" content="Advent of Haskell: Roll your own Holly Jolly streaming combinator library with
Free"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/holly-jolly-streaming-combinators.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/holly-jolly-streaming-combinators.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Advent of Haskell: Roll your own Holly Jolly streaming combinator library with
Free</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/streaming-combinators-free.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/holly-jolly-streaming-combinators.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/holly-jolly-streaming-combinators.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Hi! Welcome, if you’re joining us from the great <a href="https://adventofhaskell.com/">Advent of Haskell 2020</a> event! Feel free to grab a hot chocolate and sit back by the fireplace. I’m honored to be able to be a part of the event this year; it’s a great initiative and harkens back to the age-old Haskell tradition of bite-sized Functional Programming “advent calendars”. I remember when I was first learning Haskell, <a href="https://ocharles.org.uk/pages/2012-12-01-24-days-of-hackage.html">24 Days of Hackage</a> was one of my favorite series that helped me really get into the exciting world of Haskell and the all the doors that functional programming can open.</p>
<p>For my entry, in the spirit of the holidays, I decided to treat it as a chance to go reminisce about Haskell times of olde. Right now in Haskell we seem to be in an era where the great debate in the future of the language is in <a href="https://www.stephendiehl.com/posts/decade.html#algebraic-effect-systems">the best way to handle composable effects</a> in Haskell, but if we roll back the calendar to the beginning of the decade, this big existential war was in the best way to handle constant-space effectful streaming.</p>
<p>The dust on that debate has more or less settled (the apparent answer: it doesn’t <em>really</em> matter, just use whatever is more integrated with what you are already using and has a more robust relevant ecosystem built around it), but recently I had an occasion to explore the space myself. I needed a specific sort of streaming behavior that I couldn’t express cleanly exactly in any of the major options and I thought to look into what it would take to roll your own using the “modern” tools of 2020. In the end it was a fun journey, because it helped me understand things a lot better in a way I probably could not have reached on my own when I was just starting out in Haskell when this topic was “hot”.</p>
<p>So in this post we’ll be attempting to roll our own monadic streaming effects combinators in a way that is made surprisingly (at least, to me) clean if we approach it from a composable effects sort of style — hopefully demonstrating how natural a lot of previously complex topics become if we just imagine them in the context of composable effects!</p>
<h2 id="an-effectful-picture">An effectful picture</h2>
<p>The “goal” is to make a system of composable types that is “pull-based”, so we can process data as it is read in from IO only as we need it, and never do more work than we need to do up-front or leak memory when we stop using it.</p>
<p>So, the way I usually approach things like these is: “dress for the interface you want, not the one you have.” It involves:</p>
<ol type="1">
<li>Thinking of the <code>m a</code> you want and how you would want to combine it/use it.</li>
<li>Express the primitive actions of that thing</li>
<li>Use some sort of free structure or effects system to enhance that primitive with the interface you are looking for.</li>
</ol>
<p>For step 3, I’ve explored this concept in the past as <a href="https://blog.jle.im/entry/functor-combinatorpedia.html">functor combinator style</a>, but there are multiple ways to do it!</p>
<p>So, let’s make our type!</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Pipe</span> i o m a <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>where a <code>Pipe i o m a</code> represents a pipe component where:</p>
<ul>
<li><code>i</code>: the input of the pipe that it expects upstream</li>
<li><code>o</code>: the output of the pipe that it will yield downstream</li>
<li><code>m</code>: the monad that the underlying actions live in</li>
<li><code>a</code>: the overall result of the pipe once it has terminated.</li>
</ul>
<p>One nice thing about this setup is that by picking different values for the type parameters, we can already get a nice classification for interesting subtypes:</p>
<ol type="1">
<li><p>If <code>i</code> is <code>()</code> (or universally quantified) — a <code>Pipe () o m a</code> — it means that the pipe doesn’t ever expect any sort of information upstream, and so can be considered a “source” that keeps on churning out values.</p></li>
<li><p>If <code>o</code> is <code>Void</code> (or universally quantified) — a <code>Pipe i Void m a</code> — it means that the pipe will never yield anything downstream, because <code>Void</code> has no inhabitants that could possibly be yielded.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">Void</span></span></code></pre></div>
<p>This means that it acts like a “sink” that will keep on eating <code>i</code> values without ever outputting anything downstream.</p></li>
<li><p>If <code>i</code> is <code>()</code> and <code>o</code> is <code>Void</code> (or they are both universally quantified), then the pipe doesn’t expect any sort of information upstream, and also won’t ever yield anything downstream… a <code>Pipe () Void m a</code> is just an <code>m a</code>!</p></li>
<li><p>If <code>a</code> is <code>Void</code> (or universally quantified) — a <code>Pipe i o m Void</code> — it means that the pipe will never terminate, since <code>Void</code> has no inhabitants that could it could possibly produce upon termination.</p></li>
</ol>
<p>To me, I think it embodies a lot of the nice principles about the “algebra” of types that can be used to reason with inputs and outputs. Plus, it allows us to unify sources, sinks, and non-terminating pipes all in one type!</p>
<p>Now let’s think of the interface we want. We want to be able to:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- | Yield a value `o` downstream</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">yield ::</span> o <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m ()</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">-- | Await a value `i` upstream</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">await ::</span> <span class="dt">Pipe</span> i o m (<span class="dt">Maybe</span> i)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">-- | Terminate with a result value</span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m a</span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">-- | Sequence pipes one-after-another:</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">-- &quot;do this until it terminates, then that one next&quot;</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="ot">(&gt;&gt;) ::</span> <span class="dt">Pipe</span> i o m a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b</span>
<span id="cb3-13"><a href="#cb3-13"></a></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">-- | In fact let&#39;s just make it a full fledged monad, why not?  We&#39;re designing</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>our dream interface here<span class="op">.</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Pipe</span> i o m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b) <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b</span>
<span id="cb3-17"><a href="#cb3-17"></a></span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="co">-- | A pipe that simply does action in the underlying monad and terminates with</span></span>
<span id="cb3-19"><a href="#cb3-19"></a><span class="co">-- the result</span></span>
<span id="cb3-20"><a href="#cb3-20"></a><span class="ot">lift ::</span> m a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m a</span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co">-- | Compose pipes, linking the output of one to the input of the other</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="ot">(.|) ::</span> <span class="dt">Pipe</span> i j m a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> j o m b <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b</span>
<span id="cb3-24"><a href="#cb3-24"></a></span>
<span id="cb3-25"><a href="#cb3-25"></a><span class="co">-- | Finally: run it all on a pipe expecting no input and never yielding:</span></span>
<span id="cb3-26"><a href="#cb3-26"></a><span class="ot">runPipe ::</span> <span class="dt">Pipe</span> () <span class="dt">Void</span> m a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>So, these are going to be implementing “conduit-style” streaming combinators, where streaming actions are monadic, and monadic sequencing represents “do this after this one is done.” Because of this property, they seem to also be <em>pull-based</em> pipes, yields will block until a corresponding await can accept what is yielded.</p>
<h3 id="dress-for-the-interface-you-want">Dress for the interface you want</h3>
<p>“Dress for the interface you want”, they all told me. So let’s pretend we already implemented this interface…what could we do with it?</p>
<p>Well, can write simple sources like “yield the contents from a file line-by-line”:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L60-L67</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="ot">sourceHandle ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i <span class="dt">String</span> <span class="dt">IO</span> ()</span>
<span id="cb4-4"><a href="#cb4-4"></a>sourceHandle handle <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    res <span class="ot">&lt;-</span> lift <span class="op">$</span> tryJust (guard <span class="op">.</span> isEOFError) (hGetLine handle)</span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="kw">case</span> res <span class="kw">of</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>      <span class="dt">Left</span>  _   <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb4-8"><a href="#cb4-8"></a>      <span class="dt">Right</span> out <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>        yield out </span>
<span id="cb4-10"><a href="#cb4-10"></a>        sourceHandle handle</span></code></pre></div>
<p>Note that because the <code>i</code> is universally quantified, it means that we know that <code>sourceFile</code> never ever awaits or touches any input: it’s purely a source.</p>
<p>We can even write a simple sink, like “await and print the results to stdout as they come”:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L69-L76</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">sinkStdout ::</span> <span class="dt">Pipe</span> <span class="dt">String</span> o <span class="dt">IO</span> ()</span>
<span id="cb5-4"><a href="#cb5-4"></a>sinkStdout <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    inp <span class="ot">&lt;-</span> await</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="kw">case</span> inp <span class="kw">of</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb5-8"><a href="#cb5-8"></a>      <span class="dt">Just</span> x  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>        lift <span class="op">$</span> <span class="fu">putStrLn</span> x</span>
<span id="cb5-10"><a href="#cb5-10"></a>        sinkStdout</span></code></pre></div>
<p>And maybe we can write a pipe that takes input strings and converts them to all capital letters and re-yields them:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L78-L85</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">toUpperPipe ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> <span class="dt">String</span> <span class="dt">String</span> m ()</span>
<span id="cb6-4"><a href="#cb6-4"></a>toUpperPipe <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>    inp <span class="ot">&lt;-</span> await</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">case</span> inp <span class="kw">of</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb6-8"><a href="#cb6-8"></a>      <span class="dt">Just</span> x  <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>        yield (<span class="fu">map</span> <span class="fu">toUpper</span> x)</span>
<span id="cb6-10"><a href="#cb6-10"></a>        toUpperPipe</span></code></pre></div>
<p>And we can maybe write a pipe that stops as soon as it reads the line <code>STOP</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L87-L96</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">untilSTOP ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> <span class="dt">String</span> <span class="dt">String</span> m ()</span>
<span id="cb7-4"><a href="#cb7-4"></a>untilSTOP <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>    inp <span class="ot">&lt;-</span> await</span>
<span id="cb7-6"><a href="#cb7-6"></a>    <span class="kw">case</span> inp <span class="kw">of</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb7-8"><a href="#cb7-8"></a>      <span class="dt">Just</span> x</span>
<span id="cb7-9"><a href="#cb7-9"></a>        <span class="op">|</span> x <span class="op">==</span> <span class="st">&quot;STOP&quot;</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</span>
<span id="cb7-10"><a href="#cb7-10"></a>        <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>            yield x</span>
<span id="cb7-12"><a href="#cb7-12"></a>            untilSTOP</span></code></pre></div>
<p><code>untilSTOP</code> is really sort of the crux of what makes these streaming systems useful: we only pull items from the file as we need it, and <code>untilSTOP</code> will stop pulling anything as soon as we hit <code>STOP</code>, so no IO will happen anymore if the upstream sink does IO.</p>
<h3 id="our-ideal-program">Our Ideal Program</h3>
<p>Now ideally, we’d want to write a program that lets us compose the above pipes to read from a file and output its contents to stdout, until it sees a STOP line:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L98-L103</span></span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ot">sampleProgram ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o <span class="dt">IO</span> ()</span>
<span id="cb8-4"><a href="#cb8-4"></a>sampleProgram handle <span class="ot">=</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>       sourceHandle handle</span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="op">.|</span> untilSTOP</span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="op">.|</span> toUpperPipe</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="op">.|</span> sinkStdout</span></code></pre></div>
<h2 id="implementing-the-interface-you-want">Implementing the interface you want</h2>
<p>Step 2 of our plan was to identify the primitive actions we want. Looking at our interface, it seems like we can narrow things down to two:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">yield  ::</span> o <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m ()</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">await  ::</span> <span class="dt">Pipe</span> i o m (<span class="dt">Maybe</span> i)</span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">lift   ::</span> m a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m a</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="fu">return</span><span class="ot"> ::</span> a   <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m a</span></code></pre></div>
<p>However, we can note that <code>lift</code> and <code>return</code> will come from the <code>Monad</code> and <code>MonadTrans</code> instances that we wish we had:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="kw">class</span> <span class="dt">MonadTrans</span> p <span class="kw">where</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="ot">    lift ::</span> m a <span class="ot">-&gt;</span> p m a</span></code></pre></div>
<p>The effects system/functor combinator plan is to identify your true primitives, and let free structures give you the instances you need for them.</p>
<p>So this means we only need two primitives: <code>yield</code> and <code>await</code>. Then we just throw them into some machinery that gives us a free <code>Monad</code> and <code>MonadTrans</code> structure, and we’re golden :)</p>
<p>In the style of the <em><a href="https://hackage.haskell.org/package/free">free</a></em> library, we’d write base functions to get an ADT that describes the primitive actions:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L20-L25</span></span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="kw">data</span> <span class="dt">PipeF</span> i o a <span class="ot">=</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="dt">YieldF</span> o a</span>
<span id="cb11-5"><a href="#cb11-5"></a>  <span class="op">|</span> <span class="dt">AwaitF</span> (<span class="dt">Maybe</span> i <span class="ot">-&gt;</span> a)</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>               </span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="kw">type</span> <span class="dt">Pipe</span> i o <span class="ot">=</span> <span class="dt">FreeT</span> (<span class="dt">PipeF</span> i o)</span></code></pre></div>
<p>The general structure of the base functor style is to represent each primitive as a constructor: include any inputs, and then a continuation on what to do if you had the result.</p>
<p>For example:</p>
<ol type="1">
<li>For <code>YieldF</code>, you need an <code>o</code> to be able to yield. The second field should really be the continuation <code>() -&gt; a</code>, since the result is <code>()</code>, but that’s equivalent to <code>a</code> in Haskell.</li>
<li>For <code>AwaitF</code>, you don’t need any parameters to await, but the continuation is <code>Maybe i -&gt; a</code> since you need to specify how to handle the <code>Maybe i</code> result.</li>
</ol>
<p>This is specifically the structure that <em><a href="https://hackage.haskell.org/package/free">free</a></em> expects, but this principle can be ported to any algebraic effects system.</p>
<p>And now…we’re done! We can use the <code>FreeT</code> type from <em><a href="https://hackage.haskell.org/package/free/docs/Control-Monad-Trans-Free.html">Control.Monad.Trans.Free</a></em>, and now we have our pipe interface, with a <code>Monad</code> and <code>MonadTrans</code> instance!</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">type</span> <span class="dt">Pipe</span> i o <span class="ot">=</span> <span class="dt">FreeT</span> (<span class="dt">PipeF</span> i o)</span></code></pre></div>
<p>This takes our base functor and imbues it with a full <code>Monad</code> and <code>MonadTrans</code> instance:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">lift ::</span> m a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> (<span class="dt">PipeF</span> i o) m a</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">lift ::</span> m a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m a</span>
<span id="cb13-3"><a href="#cb13-3"></a></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> (<span class="dt">PipeF</span> i o) m a</span>
<span id="cb13-5"><a href="#cb13-5"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m a</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="ot">(&gt;&gt;)  ::</span> <span class="dt">Pipe</span> i o m a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b</span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Pipe</span> i o m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b) <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m b</span></code></pre></div>
<p>That’s the essence of the free structure: it <em>adds</em> to our base functor (<code>PipeF</code>) exactly the structure it needs to be able to implement the instances it is free on. And it’s all free as in beer! :D</p>
<p>Now we just need our functions to lift our primitives to <code>Pipe</code>, using <code>liftF :: f a -&gt; FreeT f m a</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/streaming-combinators-free.hs#L27-L31</span></span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> o <span class="ot">-&gt;</span> <span class="dt">Pipe</span> i o m ()</span>
<span id="cb14-4"><a href="#cb14-4"></a>yield x <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">YieldF</span> x ()</span>
<span id="cb14-5"><a href="#cb14-5"></a></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> i o m (<span class="dt">Maybe</span> i)</span>
<span id="cb14-7"><a href="#cb14-7"></a>await <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">AwaitF</span> <span class="fu">id</span></span></code></pre></div>
<p>(these things you can usually just fill in using type tetris, filling in values with typed holes into they typecheck).</p>
<p>And now, we</p></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functor-combinators.html" class="tag-a-tag">#functor combinators</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/holly-jolly-streaming-combinators.html';
    this.page.identifier = 'streaming-combinators-free';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>