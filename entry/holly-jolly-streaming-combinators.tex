\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={Advent of Haskell: Roll your own Holly Jolly streaming combinator library with},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

\title{Advent of Haskell: Roll your own Holly Jolly streaming combinator library with}

\begin{document}
\maketitle

Free \% Justin Le

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/holly-jolly-streaming-combinators.html}{in
Code}}.}

Hi! Welcome, if you're joining us from the great
\href{https://adventofhaskell.com/}{Advent of Haskell 2020} event! Feel free to
grab a hot chocolate and sit back by the fireplace. I'm honored to be able to be
a part of the event this year; it's a great initiative and harkens back to the
age-old Haskell tradition of bite-sized Functional Programming ``advent
calendars''. I remember when I was first learning Haskell,
\href{https://ocharles.org.uk/pages/2012-12-01-24-days-of-hackage.html}{24 Days
of Hackage} was one of my favorite series that helped me really get into the
exciting world of Haskell and the all the doors that functional programming can
open.

For my entry, in the spirit of the holidays, I decided to treat it as a chance
to go reminisce about Haskell times of olde. Right now in Haskell we seem to be
in an era where the great debate in the future of the language is in
\href{https://www.stephendiehl.com/posts/decade.html\#algebraic-effect-systems}{the
best way to handle composable effects} in Haskell, but if we roll back the
calendar to the beginning of the decade, this big existential war was in the
best way to handle constant-space effectful streaming.

The dust on that debate has more or less settled (the apparent answer: it
doesn't \emph{really} matter, just use whatever is more integrated with what you
are already using and has a more robust relevant ecosystem built around it), but
recently I had an occasion to explore the space myself. I needed a specific sort
of streaming behavior that I couldn't express cleanly exactly in any of the
major options and I thought to look into what it would take to roll your own
using the ``modern'' tools of 2020. In the end it was a fun journey, because it
helped me understand things a lot better in a way I probably could not have
reached on my own when I was just starting out in Haskell when this topic was
``hot''.

So in this post we'll be attempting to roll our own monadic streaming effects
combinators in a way that is made surprisingly (at least, to me) clean if we
approach it from a composable effects sort of style --- hopefully demonstrating
how natural a lot of previously complex topics become if we just imagine them in
the context of composable effects!

\hypertarget{an-effectful-picture}{%
\section{An effectful picture}\label{an-effectful-picture}}

The ``goal'' is to make a system of composable types that is ``pull-based'', so
we can process data as it is read in from IO only as we need it, and never do
more work than we need to do up-front or leak memory when we stop using it.

So, the way I usually approach things like these is: ``dress for the interface
you want, not the one you have.'' It involves:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Thinking of the \texttt{m\ a} you want and how you would want to combine
  it/use it.
\item
  Express the primitive actions of that thing
\item
  Use some sort of free structure or effects system to enhance that primitive
  with the interface you are looking for.
\end{enumerate}

For step 3, I've explored this concept in the past as
\href{https://blog.jle.im/entry/functor-combinatorpedia.html}{functor combinator
style}, but there are multiple ways to do it!

So, let's make our type!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Pipe}\NormalTok{ i o m a }\OtherTok{=} \OperatorTok{...}
\end{Highlighting}
\end{Shaded}

where a \texttt{Pipe\ i\ o\ m\ a} represents a pipe component where:

\begin{itemize}
\tightlist
\item
  \texttt{i}: the input of the pipe that it expects upstream
\item
  \texttt{o}: the output of the pipe that it will yield downstream
\item
  \texttt{m}: the monad that the underlying actions live in
\item
  \texttt{a}: the overall result of the pipe once it has terminated.
\end{itemize}

One nice thing about this setup is that by picking different values for the type
parameters, we can already get a nice classification for interesting subtypes:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  If \texttt{i} is \texttt{()} (or universally quantified) --- a
  \texttt{Pipe\ ()\ o\ m\ a} --- it means that the pipe doesn't ever expect any
  sort of information upstream, and so can be considered a ``source'' that keeps
  on churning out values.
\item
  If \texttt{o} is \texttt{Void} (or universally quantified) --- a
  \texttt{Pipe\ i\ Void\ m\ a} --- it means that the pipe will never yield
  anything downstream, because \texttt{Void} has no inhabitants that could
  possibly be yielded.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Void}
\end{Highlighting}
\end{Shaded}

  This means that it acts like a ``sink'' that will keep on eating \texttt{i}
  values without ever outputting anything downstream.
\item
  If \texttt{i} is \texttt{()} and \texttt{o} is \texttt{Void} (or they are both
  universally quantified), then the pipe doesn't expect any sort of information
  upstream, and also won't ever yield anything downstream\ldots{} a
  \texttt{Pipe\ ()\ Void\ m\ a} is just an \texttt{m\ a}!
\item
  If \texttt{a} is \texttt{Void} (or universally quantified) --- a
  \texttt{Pipe\ i\ o\ m\ Void} --- it means that the pipe will never terminate,
  since \texttt{Void} has no inhabitants that could it could possibly produce
  upon termination.
\end{enumerate}

To me, I think it embodies a lot of the nice principles about the ``algebra'' of
types that can be used to reason with inputs and outputs. Plus, it allows us to
unify sources, sinks, and non-terminating pipes all in one type!

Now let's think of the interface we want. We want to be able to:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} | Yield a value \textasciigrave{}o\textasciigrave{} downstream}
\OtherTok{yield ::}\NormalTok{ o }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m ()}

\CommentTok{{-}{-} | Await a value \textasciigrave{}i\textasciigrave{} upstream}
\OtherTok{await ::} \DataTypeTok{Pipe}\NormalTok{ i o m (}\DataTypeTok{Maybe}\NormalTok{ i)}

\CommentTok{{-}{-} | Terminate with a result value}
\FunctionTok{return}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m a}

\CommentTok{{-}{-} | Sequence pipes one{-}after{-}another:}
\CommentTok{{-}{-} "do this until it terminates, then that one next"}
\OtherTok{(>>) ::} \DataTypeTok{Pipe}\NormalTok{ i o m a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b}

\CommentTok{{-}{-} | In fact let\textquotesingle{}s just make it a full fledged monad, why not?  We\textquotesingle{}re designing}
\NormalTok{our dream interface here}\OperatorTok{.}
\OtherTok{(>>=) ::} \DataTypeTok{Pipe}\NormalTok{ i o m a }\OtherTok{{-}>}\NormalTok{ (a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b) }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b}

\CommentTok{{-}{-} | A pipe that simply does action in the underlying monad and terminates with}
\CommentTok{{-}{-} the result}
\OtherTok{lift ::}\NormalTok{ m a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m a}

\CommentTok{{-}{-} | Compose pipes, linking the output of one to the input of the other}
\OtherTok{(.|) ::} \DataTypeTok{Pipe}\NormalTok{ i j m a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ j o m b }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b}

\CommentTok{{-}{-} | Finally: run it all on a pipe expecting no input and never yielding:}
\OtherTok{runPipe ::} \DataTypeTok{Pipe}\NormalTok{ () }\DataTypeTok{Void}\NormalTok{ m a }\OtherTok{{-}>}\NormalTok{ m a}
\end{Highlighting}
\end{Shaded}

So, these are going to be implementing ``conduit-style'' streaming combinators,
where streaming actions are monadic, and monadic sequencing represents ``do this
after this one is done.'' Because of this property, they seem to also be
\emph{pull-based} pipes, yields will block until a corresponding await can
accept what is yielded.

\hypertarget{dress-for-the-interface-you-want}{%
\subsection{Dress for the interface you
want}\label{dress-for-the-interface-you-want}}

``Dress for the interface you want'', they all told me. So let's pretend we
already implemented this interface\ldots what could we do with it?

Well, can write simple sources like ``yield the contents from a file
line-by-line'':

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L60{-}L67}

\OtherTok{sourceHandle ::} \DataTypeTok{Handle} \OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i }\DataTypeTok{String} \DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{sourceHandle handle }\OtherTok{=} \KeywordTok{do}
\NormalTok{    res }\OtherTok{<{-}}\NormalTok{ lift }\OperatorTok{$}\NormalTok{ tryJust (guard }\OperatorTok{.}\NormalTok{ isEOFError) (hGetLine handle)}
    \KeywordTok{case}\NormalTok{ res }\KeywordTok{of}
      \DataTypeTok{Left}\NormalTok{  \_   }\OtherTok{{-}>} \FunctionTok{return}\NormalTok{ ()}
      \DataTypeTok{Right}\NormalTok{ out }\OtherTok{{-}>} \KeywordTok{do}
\NormalTok{        yield out }
\NormalTok{        sourceHandle handle}
\end{Highlighting}
\end{Shaded}

Note that because the \texttt{i} is universally quantified, it means that we
know that \texttt{sourceFile} never ever awaits or touches any input: it's
purely a source.

We can even write a simple sink, like ``await and print the results to stdout as
they come'':

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L69{-}L76}

\OtherTok{sinkStdout ::} \DataTypeTok{Pipe} \DataTypeTok{String}\NormalTok{ o }\DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{sinkStdout }\OtherTok{=} \KeywordTok{do}
\NormalTok{    inp }\OtherTok{<{-}}\NormalTok{ await}
    \KeywordTok{case}\NormalTok{ inp }\KeywordTok{of}
      \DataTypeTok{Nothing} \OtherTok{{-}>} \FunctionTok{pure}\NormalTok{ ()}
      \DataTypeTok{Just}\NormalTok{ x  }\OtherTok{{-}>} \KeywordTok{do}
\NormalTok{        lift }\OperatorTok{$} \FunctionTok{putStrLn}\NormalTok{ x}
\NormalTok{        sinkStdout}
\end{Highlighting}
\end{Shaded}

And maybe we can write a pipe that takes input strings and converts them to all
capital letters and re-yields them:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L78{-}L85}

\OtherTok{toUpperPipe ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=>} \DataTypeTok{Pipe} \DataTypeTok{String} \DataTypeTok{String}\NormalTok{ m ()}
\NormalTok{toUpperPipe }\OtherTok{=} \KeywordTok{do}
\NormalTok{    inp }\OtherTok{<{-}}\NormalTok{ await}
    \KeywordTok{case}\NormalTok{ inp }\KeywordTok{of}
      \DataTypeTok{Nothing} \OtherTok{{-}>} \FunctionTok{pure}\NormalTok{ ()}
      \DataTypeTok{Just}\NormalTok{ x  }\OtherTok{{-}>} \KeywordTok{do}
\NormalTok{        yield (}\FunctionTok{map} \FunctionTok{toUpper}\NormalTok{ x)}
\NormalTok{        toUpperPipe}
\end{Highlighting}
\end{Shaded}

And we can maybe write a pipe that stops as soon as it reads the line
\texttt{STOP}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L87{-}L96}

\OtherTok{untilSTOP ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=>} \DataTypeTok{Pipe} \DataTypeTok{String} \DataTypeTok{String}\NormalTok{ m ()}
\NormalTok{untilSTOP }\OtherTok{=} \KeywordTok{do}
\NormalTok{    inp }\OtherTok{<{-}}\NormalTok{ await}
    \KeywordTok{case}\NormalTok{ inp }\KeywordTok{of}
      \DataTypeTok{Nothing} \OtherTok{{-}>} \FunctionTok{pure}\NormalTok{ ()}
      \DataTypeTok{Just}\NormalTok{ x}
        \OperatorTok{|}\NormalTok{ x }\OperatorTok{==} \StringTok{"STOP"} \OtherTok{{-}>} \FunctionTok{pure}\NormalTok{ ()}
        \OperatorTok{|} \FunctionTok{otherwise}   \OtherTok{{-}>} \KeywordTok{do}
\NormalTok{            yield x}
\NormalTok{            untilSTOP}
\end{Highlighting}
\end{Shaded}

\texttt{untilSTOP} is really sort of the crux of what makes these streaming
systems useful: we only pull items from the file as we need it, and
\texttt{untilSTOP} will stop pulling anything as soon as we hit \texttt{STOP},
so no IO will happen anymore if the upstream sink does IO.

\hypertarget{our-ideal-program}{%
\subsection{Our Ideal Program}\label{our-ideal-program}}

Now ideally, we'd want to write a program that lets us compose the above pipes
to read from a file and output its contents to stdout, until it sees a STOP
line:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L98{-}L103}

\OtherTok{sampleProgram ::} \DataTypeTok{Handle} \OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o }\DataTypeTok{IO}\NormalTok{ ()}
\NormalTok{sampleProgram handle }\OtherTok{=}
\NormalTok{       sourceHandle handle}
    \OperatorTok{.|}\NormalTok{ untilSTOP}
    \OperatorTok{.|}\NormalTok{ toUpperPipe}
    \OperatorTok{.|}\NormalTok{ sinkStdout}
\end{Highlighting}
\end{Shaded}

\hypertarget{implementing-the-interface-you-want}{%
\section{Implementing the interface you
want}\label{implementing-the-interface-you-want}}

Step 2 of our plan was to identify the primitive actions we want. Looking at our
interface, it seems like we can narrow things down to two:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{yield  ::}\NormalTok{ o }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m ()}
\OtherTok{await  ::} \DataTypeTok{Pipe}\NormalTok{ i o m (}\DataTypeTok{Maybe}\NormalTok{ i)}
\OtherTok{lift   ::}\NormalTok{ m a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m a}
\FunctionTok{return}\OtherTok{ ::}\NormalTok{ a   }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m a}
\end{Highlighting}
\end{Shaded}

However, we can note that \texttt{lift} and \texttt{return} will come from the
\texttt{Monad} and \texttt{MonadTrans} instances that we wish we had:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Monad}\NormalTok{ m }\KeywordTok{where}
\OtherTok{    return ::}\NormalTok{ a }\OtherTok{{-}>}\NormalTok{ m a}

\KeywordTok{class} \DataTypeTok{MonadTrans}\NormalTok{ p }\KeywordTok{where}
\OtherTok{    lift ::}\NormalTok{ m a }\OtherTok{{-}>}\NormalTok{ p m a}
\end{Highlighting}
\end{Shaded}

The effects system/functor combinator plan is to identify your true primitives,
and let free structures give you the instances you need for them.

So this means we only need two primitives: \texttt{yield} and \texttt{await}.
Then we just throw them into some machinery that gives us a free \texttt{Monad}
and \texttt{MonadTrans} structure, and we're golden :)

In the style of the \emph{\href{https://hackage.haskell.org/package/free}{free}}
library, we'd write base functions to get an ADT that describes the primitive
actions:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L20{-}L25}

\KeywordTok{data} \DataTypeTok{PipeF}\NormalTok{ i o a }\OtherTok{=}
    \DataTypeTok{YieldF}\NormalTok{ o a}
  \OperatorTok{|} \DataTypeTok{AwaitF}\NormalTok{ (}\DataTypeTok{Maybe}\NormalTok{ i }\OtherTok{{-}>}\NormalTok{ a)}
    \KeywordTok{deriving} \DataTypeTok{Functor}
               
\KeywordTok{type} \DataTypeTok{Pipe}\NormalTok{ i o }\OtherTok{=} \DataTypeTok{FreeT}\NormalTok{ (}\DataTypeTok{PipeF}\NormalTok{ i o)}
\end{Highlighting}
\end{Shaded}

The general structure of the base functor style is to represent each primitive
as a constructor: include any inputs, and then a continuation on what to do if
you had the result.

For example:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  For \texttt{YieldF}, you need an \texttt{o} to be able to yield. The second
  field should really be the continuation \texttt{()\ -\textgreater{}\ a}, since
  the result is \texttt{()}, but that's equivalent to \texttt{a} in Haskell.
\item
  For \texttt{AwaitF}, you don't need any parameters to await, but the
  continuation is \texttt{Maybe\ i\ -\textgreater{}\ a} since you need to
  specify how to handle the \texttt{Maybe\ i} result.
\end{enumerate}

This is specifically the structure that
\emph{\href{https://hackage.haskell.org/package/free}{free}} expects, but this
principle can be ported to any algebraic effects system.

And now\ldots we're done! We can use the \texttt{FreeT} type from
\emph{\href{https://hackage.haskell.org/package/free/docs/Control-Monad-Trans-Free.html}{Control.Monad.Trans.Free}},
and now we have our pipe interface, with a \texttt{Monad} and
\texttt{MonadTrans} instance!

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{type} \DataTypeTok{Pipe}\NormalTok{ i o }\OtherTok{=} \DataTypeTok{FreeT}\NormalTok{ (}\DataTypeTok{PipeF}\NormalTok{ i o)}
\end{Highlighting}
\end{Shaded}

This takes our base functor and imbues it with a full \texttt{Monad} and
\texttt{MonadTrans} instance:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{lift ::}\NormalTok{ m a }\OtherTok{{-}>} \DataTypeTok{FreeT}\NormalTok{ (}\DataTypeTok{PipeF}\NormalTok{ i o) m a}
\OtherTok{lift ::}\NormalTok{ m a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m a}

\FunctionTok{return}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{FreeT}\NormalTok{ (}\DataTypeTok{PipeF}\NormalTok{ i o) m a}
\FunctionTok{return}\OtherTok{ ::}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m a}

\OtherTok{(>>)  ::} \DataTypeTok{Pipe}\NormalTok{ i o m a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b}
\OtherTok{(>>=) ::} \DataTypeTok{Pipe}\NormalTok{ i o m a }\OtherTok{{-}>}\NormalTok{ (a }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b) }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m b}
\end{Highlighting}
\end{Shaded}

That's the essence of the free structure: it \emph{adds} to our base functor
(\texttt{PipeF}) exactly the structure it needs to be able to implement the
instances it is free on. And it's all free as in beer! :D

Now we just need our functions to lift our primitives to \texttt{Pipe}, using
\texttt{liftF\ ::\ f\ a\ -\textgreater{}\ FreeT\ f\ m\ a}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/misc/streaming{-}combinators{-}free.hs\#L27{-}L31}

\OtherTok{yield ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=>}\NormalTok{ o }\OtherTok{{-}>} \DataTypeTok{Pipe}\NormalTok{ i o m ()}
\NormalTok{yield x }\OtherTok{=}\NormalTok{ liftF }\OperatorTok{$} \DataTypeTok{YieldF}\NormalTok{ x ()}

\OtherTok{await ::} \DataTypeTok{Monad}\NormalTok{ m }\OtherTok{=>} \DataTypeTok{Pipe}\NormalTok{ i o m (}\DataTypeTok{Maybe}\NormalTok{ i)}
\NormalTok{await }\OtherTok{=}\NormalTok{ liftF }\OperatorTok{$} \DataTypeTok{AwaitF} \FunctionTok{id}
\end{Highlighting}
\end{Shaded}

(these things you can usually just fill in using type tetris, filling in values
with typed holes into they typecheck).

And now, we

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
