<!DOCTYPE HTML>
<html><head><title>Shake: Task Automation and Scripting in Haskell · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="As someone who comes from a background in ruby and rake, I&#39;m used to powerful task management systems with expressive dependency. Make is a favorite tool of mine when I&#39;m working on projects with people who don&#39;t use ruby, and when I&#39;m working on ruby projects I never go far without starting a good Rakefile. The two tools provided a perfect DSL for setting up systems of tasks that had complicated file and task dependencies. As I was starting to learn Haskell and building larger-scale Haskell projects, I began to look for alternatives in Haskell. Was there a Haskell counterpart to Ruby&#39;s rake, Node&#39;s jake? (Not to mention the tools of slightly different philosophy grunt and ant) It turns out that by far the most established answer is a library known as Shake (maintained by the prolific Neil Mitchell of hoogle fame and much more). So far it&#39;s served me pretty well. Its documentation is written from the perspective of chiefly using it as a build tool (more &quot;make&quot; than &quot;rake&quot;), so if you&#39;re looking to use it as a task management system, you might have to do some digging. Hopefully this post can help you get started. I also go over the core concepts of a task management system, so I assume no knowledge of make; this post therefore should also be a good introduction to starting with any sort of task management system."><meta property="og:type" content="article"><meta property="og:title" content="Shake: Task Automation and Scripting in Haskell"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/shake-task-automation-and-scripting-in-haskell.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/shake-task-automation-and-scripting-in-haskell.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Shake: Task Automation and Scripting in Haskell</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2013-09-17T16:23:11Z" pubdate="" class="pubdate">Tuesday September 17, 2013</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/shake.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/shake-task-automation-and-scripting-in-haskell.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/shake-task-automation-and-scripting-in-haskell.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category" title="Technical tutorials/walkthroughs on specific programming processes and problems
that I&#39;ve struggled through in the past.">Tutorials</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>As someone who comes from a background in ruby and <em>rake</em>, I'm used to powerful task management systems with expressive dependency. <em>Make</em> is a favorite tool of mine when I'm working on projects with people who don't use ruby, and when I'm working on ruby projects I never go far without starting a good Rakefile. The two tools provided a perfect DSL for setting up systems of tasks that had complicated file and task dependencies.</p>
<p>As I was starting to learn Haskell and building larger-scale Haskell projects, I began to look for alternatives in Haskell. Was there a Haskell counterpart to Ruby's <a href="http://rake.rubyforge.org/"><em>rake</em></a>, Node's <a href="https://github.com/mde/jake"><em>jake</em></a>? (Not to mention the tools of slightly different philosophy <a href="http://gruntjs.com/"><em>grunt</em></a> and <a href="http://ant.apache.org/"><em>ant</em></a>)</p>
<p>It turns out that by far the most established answer is a library known as <a href="http://hackage.haskell.org/package/shake"><em>Shake</em></a> (maintained by the prolific Neil Mitchell of <a href="http://haskell.org/hoogle"><em>hoogle</em></a> fame and much more). So far it's served me pretty well. Its documentation is written from the perspective of chiefly using it as a build tool (more &quot;make&quot; than &quot;rake&quot;), so if you're looking to use it as a task management system, you might have to do some digging. Hopefully this post can help you get started.</p>
<p>I also go over the core concepts of a task management system, so I assume no knowledge of <em>make</em>; this post therefore should also be a good introduction to starting with any sort of task management system.</p>
<h2>Our Sample Project</h2>
<p>Our sample project is going to be a report build system that builds reports written in markdown with <a href="http://johnmacfarlane.net/pandoc/">pandoc</a> into html, pdf, and doc formats. This is honestly one of my most common use cases for <em>make</em>, so porting it all to <em>shake</em> will be something useful for me.</p>
<p>The final directory structure will look like this:</p>
<blockquote>
<ul>
<li>img
<ul>
<li>img1.jpg</li>
<li>img2.jpg</li>
</ul></li>
<li>out
<ul>
<li>report.doc</li>
<li>report.html</li>
<li>report.pdf</li>
</ul></li>
<li>src
<ul>
<li>report.md</li>
</ul></li>
<li>css
<ul>
<li>report.css</li>
</ul></li>
<li>Shakefile</li>
</ul>
</blockquote>
<p>When we run <code>shake</code>, we want to build <code>report.doc</code> and <code>report.pdf</code> if <code>report.md</code> or any of the images have changed, and <code>report.html</code> if <code>report.md</code>, <code>report.css</code>, or any of the images have changed.</p>
<p>Furthermore, <code>img2.jpg</code> actually comes from online, and requires us to re-download it every time we compile to make sure it is up to date.</p>
<h2>Setup</h2>
<h3>Installing Shake</h3>
<p>Installing <em>shake</em> is as simple as installing any other cabal package:</p>
<p>~~~bash $ cabal update $ cabal install shake ~~~</p>
<p>I'll will be using <code>shake-0.10.6</code> for this post.</p>
<h3>Setting up the Shakefile</h3>
<p>We set up our Shakefile with a simple scaffold:</p>
<p>~~~haskell -- Shakefile</p>
<p>import Development.Shake</p>
<p>opts = shakeOptions { shakeFiles = &quot;.shake/&quot; } -- 1</p>
<p>(~&gt;) = phony -- 2 -- (obsolete)</p>
<p>main :: IO () main = shakeArgs opts $ do want []</p>
<pre><code>&quot;clean&quot; ~&gt; removeFilesAfter &quot;.shake&quot; [&quot;//*&quot;]</code></pre>
<p>~~~</p>
<p>On my machine I've set this up to be generated by a <a href="https://gist.github.com/mstksg/6588764">bash script</a> called &quot;shakeup&quot;, so I can start a project up on a Shakefile by simply typing <code>shakeup</code> at the project root.</p>
<p>Some notes:</p>
<ol>
<li>Store shake's metadata files to the folder <code>.shake/</code>. This differs from the default behavior, where all files would be saved to the root directory with <code>.shake</code> as a filename prefix.</li>
<li><p>I've aliased the operator <code>~&gt;</code> for <code>phony</code> to allow for a more expressive infix notation --- more on this later. I've submitted a patch to the project and it should be included in the next cabal release.</p>
<p><strong>Edit</strong>: As of the 0.10.7 release of <em>Shake</em>, this is no longer needed, as <code>~&gt;</code> is included in the library.</p></li>
</ol>
<h2>What is a Rule?</h2>
<p>If you haven't used <em>make</em> before, it is important that you understand the key concepts before moving on.</p>
<p>A task management system/build system is a system that works to ensure that all files in the project are &quot;up to date&quot;. In our case, our system will ensure that the files in the <code>out</code> directory are up to date.</p>
<p>In order to do this, files are given &quot;rules&quot;. Rules specify:</p>
<ol>
<li><p>What other files/rules this file &quot;depends&quot; on</p></li>
<li><p>Instructions to execute to make this file up to date (or to create the file), if it is not already up to date or created.</p></li>
</ol>
<p>A file or rule is out of date if any of its dependencies are out of date <strong>or</strong> if the file it indicates is either not created or has been updated since the last time the task management system has run. When this happens, the guilty dependencies are updated using their own rules. Afterwards, the file's own instructions are executed.</p>
<p>If a file has no rule, &quot;out of date&quot; simply means that it has been updated or changed since the last time the task management system has run, or it does not exist. If it has, then all files or rules that depend on it are also out of date.</p>
<p>A good task management system is smart enough to keep track of what is up to date and what isn't. If multiple rules all have one dependency, that dependency might be checked and updated every single time. For example, all of our builds in this sample project require <code>img2.jpg</code> to be downloaded afresh from online. A naive build system might re-download <code>img2.jpg</code> for every single build, instead of once for all three.</p>
<h2>File Rules</h2>
<p>Let's set up <code>src/report.md</code> with a simple markdown document on our new project:</p>
<p>~~~markdown &lt;!-- src/report.md --&gt;</p>
<h1>Report</h1>
<p>This is a report. Render me!</p>
<p><img src="img/img1.jpg" alt="first image" /> <img src="img/img2.jpg" alt="second image" /> ~~~</p>
<p>Our project tree should look like this at this point:</p>
<blockquote>
<ul>
<li>img
<ul>
<li>img1.jpg</li>
<li>img2.jpg</li>
</ul></li>
<li>out</li>
<li>src
<ul>
<li>report.md</li>
</ul></li>
<li>template</li>
<li>Shakefile</li>
</ul>
</blockquote>
<p>Let's set up our first rule -- rendering <code>out/report.doc</code> if <code>report.md</code> has changed.</p>
<p>~~~haskell &quot;out/report.doc&quot; *&gt; \f -&gt; do need [&quot;src/report.md&quot;,&quot;img/img1.jpg&quot;,&quot;img/img2.jpg&quot;] cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f ] ~~~</p>
<p>This is equivalent to the Makefile rule:</p>
<p>~~~makefile out/report.doc: src/report.md pandoc src/report.md -o out/report.doc ~~~</p>
<p>The operator <code>*&gt;</code> attaches an <a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html#t:Action"><code>Action</code></a> (with a parameter) to a <a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html#t:FilePattern"><code>FilePattern</code></a> (a string) -- that is, when <em>shake</em> decides that it needs that specified file on the left hand side to be up to date, it runs the action on the right hand side with that filename as a parameter.</p>
<p>To be clear, the right hand side is of type:</p>
<p>~~~haskell rightHandSide :: FilePattern -&gt; Action () ~~~</p>
<p>where the <code>FilePattern</code> is the filename of the file that is being &quot;needed&quot;.</p>
<p>The <code>need</code> function specifies all of the dependencies of that action. If <em>shake</em> decides it needs <code>out/report.doc</code> to be up to date, <code>need</code> tells it that it first needs <code>src/report.md</code> and the images to be up to date -- or rather, that <code>out/report.doc</code> is only out of date if <code>src/report.md</code> or the images are out of date, or have changed since the last build.</p>
<p>With this in mind, let us write the rest of our file rules:</p>
<p>~~~haskell -- Shakefile</p>
<p>&quot;out/report.doc&quot; *&gt; \f -&gt; do need [&quot;src/report.md&quot;,&quot;img/img1.jpg&quot;,&quot;img/img2.jpg&quot;] cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f ]</p>
<p>&quot;out/report.pdf&quot; *&gt; \f -&gt; do need [&quot;src/report.md&quot;,&quot;img/img1.jpg&quot;,&quot;img/img2.jpg&quot;] cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f, &quot;-V&quot;, &quot;links-as-notes&quot; ]</p>
<p>&quot;out/report.html&quot; *&gt; \f -&gt; do need [ &quot;src/report.md&quot; , &quot;img/img1.jpg&quot; , &quot;img/img2.jpg&quot; , &quot;css/report.css&quot; ] cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f, &quot;-c&quot;, &quot;css/report.css&quot;, &quot;-S&quot; ]</p>
<p>&quot;img/img2.jpg&quot; *&gt; \f -&gt; do cmd &quot;wget&quot; [ &quot;http://example.com/img2.jpg&quot;, &quot;-O&quot;, f ] ~~~</p>
<p>And that is it!</p>
<h2>Running Shake</h2>
<p>How do we tell <em>shake</em> what file it is that we want to be up to date? We specify this by modifying the line <code>want []</code>:</p>
<p>~~~haskell want [&quot;out/report.doc&quot;,&quot;out/report.pdf&quot;,&quot;out/report.html&quot;] ~~~</p>
<p>That tells <em>shake</em> that when we run <code>main</code> with no arguments, we want those three files to be checked to be up to date.</p>
<p>Now, to wrap it all together, we run:</p>
<p>~~~bash $ runhaskell Shakefile ~~~</p>
<p>And let the magic happen!</p>
<p>I run this enough times that I like to alias this:</p>
<p>~~~bash</p>
<h1>in ~/.bashrc</h1>
<p>alias shake=runhaskell Shakefile ~~~</p>
<p>Note that <code>want</code> specifies the <strong>default</strong> &quot;wants&quot;. You can specify your own collection by passing a parameter:</p>
<p>~~~bash $ runhaskell Shakefile out/report.doc ~~~</p>
<h2>Wildcards</h2>
<p>You may have noticed that even though we had multiple images in the <code>img</code> folder, we required them all explicitly. This could cause problems. What if in the future, our documents used more images?</p>
<p>We can define wildcards using <em>shake</em>'s <code>getDirectoryFiles</code>, which returns results of a wildcard search in an <code>Action</code> monad. <code>getDirectoryFiles</code> takes a directory base and a list of wildcards.</p>
<p>~~~haskell -- Shakefile</p>
<p>srcFiles :: Action [FilePath] srcFiles = getDirectoryFiles &quot;&quot; [ &quot;src/report.md&quot; , &quot;img/*.jpg&quot; ]</p>
<p>main :: IO () main = shakeArgs opts $ do want [&quot;out/report.doc&quot;,&quot;out/report.pdf&quot;,&quot;out/report.html&quot;]</p>
<pre><code>&quot;out/report.doc&quot; *&gt; \f -&gt; do
    deps &lt;- srcFiles
    need deps
    cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f ]

&quot;out/report.pdf&quot; *&gt; \f -&gt; do
    deps &lt;- srcFiles
    need deps
    cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f, &quot;-V&quot;, &quot;links-as-notes&quot; ]

&quot;out/report.html&quot; *&gt; \f -&gt; do
    deps &lt;- srcFiles
    need $ &quot;css/report.css&quot; : deps
    cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f, &quot;-c&quot;, &quot;css/report.css&quot;, &quot;-S&quot; ]

&quot;img/img2.jpg&quot; *&gt; \f -&gt; do
    cmd &quot;wget&quot; [ &quot;http://example.com/img2.jpg&quot;, &quot;-O&quot;, f ]

&quot;clean&quot; ~&gt; removeFilesAfter &quot;.shake&quot; [&quot;//*&quot;]</code></pre>
<p>~~~</p>
<p>If you are comfortable with applicative style, you can make it all happen on one line:</p>
<p>~~~haskell &quot;out/report.doc&quot; *&gt; \f -&gt; do need &lt;$&gt; srcFiles ~~~</p>
<p>(You'll need to import <code>&lt;$&gt;</code> from <code>Control.Applicative</code>, and GHC will complain about the discarded value unless you use <code>void</code> or enable <code>-fno-warn-wrong-do-bind</code>)</p>
<h2>Phony Rules</h2>
<p>Now, you might sometimes want rules that are &quot;just tasks&quot; that don't relate to creating a specific file. That is, they still depend on other files or rules and are triggered to update when their dependencies are out of date, but they just aren't about building files.</p>
<p>For example, what if you wanted a task <code>build-some</code>, which builds only <code>report.pdf</code> and <code>report.doc</code>, and outputs a proverb to the command line?</p>
<p>One thing you can do is to simply use a rule with a name that does not correspond to any file:</p>
<p>~~~haskell -- Bad &quot;build-some&quot; *&gt; _ -&gt; do need [&quot;out/report.pdf&quot;,&quot;out/report.doc&quot;] cmd &quot;fortune&quot; [&quot;&quot;] ~~~</p>
<p>However, this is kind of an inelegant solution. There really actually is not a file <code>build-some</code>. Also, if someone ever decides to create a file called <code>build-some</code>, you'll find that this rule never gets run.</p>
<p>The best way is to create a &quot;phony&quot; rule, which is a rule that is not tied to a file. This is the reason for the alias I specified at the beginning of the post:</p>
<p>~~~haskell -- Good &quot;build-some&quot; ~&gt; do need [&quot;out/report.pdf&quot;,&quot;out/report.doc&quot;] cmd &quot;fortune&quot; [&quot;&quot;] ~~~</p>
<p>And voilà!</p>
<h3>Cleanup</h3>
<p>You might have noticed the phony rule in the scaffold Shakefile:</p>
<p>~~~haskell &quot;clean&quot; ~&gt; removeFilesAfter &quot;.shake&quot; [&quot;//*&quot;] ~~~</p>
<p>If you run <code>shake clean</code>, it will remove all files in the <code>.shake/</code> directory after the rule has completed its execution. <code>removeFilesAfter</code> removes the files in the given base directory (<code>.shake</code>) matching the given wildcards (<code>[&quot;//*&quot;]</code>) after all rules have completed their course.</p>
<p>This is useful for cleaning up <em>shake</em>'s metadata files after you are done with your build, or if you want to run the task management system on a clean start.</p>
<h2>Completed File</h2>
<p>~~~haskell -- Shakefile {-# OPTIONS_GHC -fno-warn-wrong-do-bind #-}</p>
<p>import Control.Applicative ((&lt;$&gt;)) import Development.Shake</p>
<p>opts = shakeOptions { shakeFiles = &quot;.shake/&quot; }</p>
<p>main :: IO () main = shakeArgs opts $ do want [&quot;out/report.doc&quot;,&quot;out/report.pdf&quot;,&quot;out/report.html&quot;]</p>
<pre><code>&quot;build-some&quot; ~&gt; do
    need [&quot;out/report.pdf&quot;,&quot;out/report.doc&quot;]
    cmd &quot;fortune&quot; [&quot;&quot;]

&quot;out/report.doc&quot; *&gt; \f -&gt; do
    need &lt;$&gt; srcFiles
    cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f ]

&quot;out/report.pdf&quot; *&gt; \f -&gt; do
    need &lt;$&gt; srcFiles
    cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f, &quot;-V&quot;, &quot;links-as-notes&quot; ]

&quot;out/report.html&quot; *&gt; \f -&gt; do
    deps &lt;- srcFiles
    need $ &quot;css/report.css&quot; : deps
    cmd &quot;pandoc&quot; [ &quot;src/report.md&quot;, &quot;-o&quot;, f, &quot;-c&quot;, &quot;css/report.css&quot;, &quot;-S&quot; ]

&quot;img/img2.jpg&quot; *&gt; \f -&gt; do
    cmd &quot;wget&quot; [ &quot;http://example.com/img2.jpg&quot;, &quot;-O&quot;, f ]

&quot;clean&quot; ~&gt; removeFilesAfter &quot;.shake&quot; [&quot;//*&quot;]</code></pre>
<p>srcFiles :: Action [FilePath] srcFiles = getDirectoryFiles &quot;&quot; [ &quot;src/report.md&quot; , &quot;img/*.jpg&quot; ] ~~~</p>
<h2>Wrapping Up</h2>
<p>If you look at the <a href="http://hackage.haskell.org/packages/archive/shake/0.10.6/doc/html/Development-Shake.html">Shake Documentation</a>, you will find a lot of ways you can build complex networks of dependencies.</p>
<p>Hopefully there are enough use cases here to be useful in general applications.</p>
<h3>Monadic Tricks</h3>
<p>Because everything is Haskell, you can easily generate rules using your basic monad iterators by taking advantage of Haskell's extensive standard library of monad functions. For example, if you want to generate multiple reports, you can use <code>forM_</code>:</p>
<p>~~~haskell let reports = [&quot;report1&quot;, &quot;report2&quot;, &quot;report3&quot;]</p>
<p>want $ (\s f -&gt; &quot;out/&quot; ++ s ++ &quot;.&quot; ++ f) &lt;$&gt; [&quot;report1&quot;,&quot;report2&quot;,&quot;report3&quot;] &lt;*&gt; [&quot;doc&quot;,&quot;pdf&quot;,&quot;html&quot;]</p>
<p>forM_ [&quot;report1&quot;,&quot;report2&quot;,&quot;report3&quot;] $ \reportName -&gt; do let outBase = &quot;out/&quot; ++ reportName srcName = &quot;src/&quot; ++ reportName ++ &quot;.md&quot;</p>
<pre><code>outBase ++ &quot;.doc&quot; *&gt; \f -&gt; do
    need &lt;$&gt; srcFiles
    cmd &quot;pandoc&quot; [ srcName, &quot;-o&quot;, f ]

outBase ++ &quot;.pdf&quot; *&gt; \f -&gt; do
    need &lt;$&gt; srcFiles
    cmd &quot;pandoc&quot; [ srcName, &quot;-o&quot;, f, &quot;-V&quot;, &quot;links-as-notes&quot; ]

outBase ++ &quot;.html&quot; *&gt; \f -&gt; do
    deps &lt;- srcFiles
    need $ &quot;css/report.css&quot; : deps
    cmd &quot;pandoc&quot; [ srcName, &quot;-o&quot;, f, &quot;-c&quot;, &quot;css/report.css&quot;, &quot;-S&quot; ]</code></pre>
<p>~~~</p>
<p>Note however that you can get the same thing by just using wildcards (with <code>takeFileName</code>). But this is just an example, feel free to let your imagination roam!</p>
<h3>Looking Forward</h3>
<p>We've seen how <em>Shake</em> is good at setting up systems for managing and executing dependencies. This is good for running simple system commands. However, there is a lot more about scripting and task automation than managing dependencies.</p>
<p>For example, almost everything we've done can be done with a simple Makefile. What does Haskell offer to the scripting scene?</p>
<h4>Strong Typing</h4>
<p>As you'll know, one of the magical things about Haskell is that because of its expressive strong typing system, you leave the debugging to the compiler. If it compiles, it works exactly the way you want!</p>
<p>This is pretty lacking in the bare-bones system we have in place now. Right now we are just firing off arbitrary system commands that are basically specified in strings with no type of typing. We can compile anything, whether there are bugs in it or not.</p>
<p>Luckily <em>Shake</em> is very good at integrating seamlessly with any kind of framework. We can leave this up to other frameworks.</p>
<p>One popular framework for this that is gaining in maturity is <a href="http://hackage.haskell.org/package/shelly"><em>Shelly</em></a> (A fork of an older project that is an <a href="http://www.yesodweb.com/blog/2012/03/shelly-for-shell-scripts">ongoing</a> Yesod Project <a href="http://www.yesodweb.com/blog/2012/07/shelly-update">experiment</a>), but you are welcome to using your own. At the present Haskell is still developing and growing in this aspect. I hope to eventually write an article about <em>Shelly</em> integration with <em>Shake</em>.</p>
<h4>Other</h4>
<p>These are just some ways to think about using <em>Shake</em> in new more creative ways. Let me know if you think of any clever integrations in the comments!</p></div><footer><ul class="entry-series"></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/scripting.html" class="tag-a-tag">#scripting</a></li><li><a href="https://blog.jle.im/entries/tagged/shake.html" class="tag-a-tag">#shake</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@tutorials.html" class="tag-a-category">@TUTORIALS</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/the-hamster-hotel-an-introduction-to-control-theory.html">The Hamster Hotel: An Introduction to Control Theory (Part 1)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/shake-task-automation-and-scripting-in-haskell.html';
    this.page.identifier = 'shake1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>