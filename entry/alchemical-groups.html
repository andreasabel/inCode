<!DOCTYPE HTML>
<html><head><title>Alchemical Groups: Advent of Code with Free Groups · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Hi all! If you don’t already know, Advent of Code is in full swing this year! If you’re participating, you’re welcome to join us at glguy’s semi-official Haskell Leaderboard (join code 43100-84040706)! There are also Haskellers on freenode ##adventofcode, and also #adventofcode on the Functional Programming slack. My daily reflections are online, where I talk about how I approach each problem and what insight purely typed Functional Programming gives us for each problem. Every once in a while I’ll find a challenge that I think can be pulled out as a short blog post, so I’ll bring them onto the blog for a more long-term sort of longevity! In this one, I’ll talk about using group theory to solve the Day 5 challenge. Spoilers for those who have not solved it yet!"><meta property="og:type" content="article"><meta property="og:title" content="Alchemical Groups: Advent of Code with Free Groups"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/alchemical-groups.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/alchemical-groups.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Alchemical Groups: Advent of Code with Free Groups</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2018-12-05T19:20:51Z" pubdate="" class="pubdate">Wednesday December 5, 2018</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/advent-free-group.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/alchemical-groups.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/alchemical-groups.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Hi all! If you don’t already know, <em><a href="https://adventofcode.com/2018">Advent of Code</a></em> is in full swing this year! If you’re participating, you’re welcome to join us at <a href="https://twitter.com/glguy">glguy</a>’s semi-official <a href="https://adventofcode.com/2017/leaderboard/private">Haskell Leaderboard</a> (join code <code>43100-84040706</code>)! There are also Haskellers on freenode ##adventofcode, and also #adventofcode on the Functional Programming slack.</p>
<p>My <a href="https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md">daily reflections</a> are online, where I talk about how I approach each problem and what insight purely typed Functional Programming gives us for each problem.</p>
<p>Every once in a while I’ll find a challenge that I think can be pulled out as a short blog post, so I’ll bring them onto the blog for a more long-term sort of longevity!<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p>In this one, I’ll talk about using group theory to solve the <em>Day 5</em> challenge. Spoilers for those who have not solved it yet!</p>
<h2 id="part-1">Part 1</h2>
<blockquote>
<p>You’ve managed to sneak in to the prototype suit manufacturing lab. The Elves are making decent progress, but are still struggling with the suit’s size reduction capabilities.</p>
<p>While the very latest in 1518 alchemical technology might have solved their problem eventually, you can do better. You scan the chemical composition of the suit’s material and discover that it is formed by extremely long <a href="https://en.wikipedia.org/wiki/Polymer">polymers</a> (one of which is <span title="I&#39;ve always wanted a polymer!">available</span> as your puzzle input).</p>
<p>The polymer is formed by smaller <em>units</em> which, when triggered, react with each other such that two adjacent units of the same type and opposite polarity are destroyed. Units’ types are represented by letters; units’ polarity is represented by capitalization. For instance, <code>r</code> and <code>R</code> are units with the same type but opposite polarity, whereas <code>r</code> and <code>s</code> are entirely different types and do not react.</p>
<p>For example:</p>
<ul>
<li>In <code>aA</code>, <code>a</code> and <code>A</code> react, leaving nothing behind.</li>
<li>In <code>abBA</code>, <code>bB</code> destroys itself, leaving <code>aA</code>. As above, this then destroys itself, leaving nothing.</li>
<li>In <code>abAB</code>, no two adjacent units are of the same type, and so nothing happens.</li>
<li>In <code>aabAAB</code>, even though <code>aa</code> and <code>AA</code> are of the same type, their polarities match, and so nothing happens.</li>
</ul>
<p>Now, consider a larger example, <code>dabAcCaCBAcCcaDA</code>:</p>
<pre><code>dabAcCaCBAcCcaDA  The first &#39;cC&#39; is removed.
dabAaCBAcCcaDA    This creates &#39;Aa&#39;, which is removed.
dabCBAcCcaDA      Either &#39;cC&#39; or &#39;Cc&#39; are removed (the result is the same).
dabCBAcaDA        No further actions can be taken.</code></pre>
<p>After all possible reactions, the resulting polymer contains <em>10 units</em>.</p>
<p><em>How many units remain after fully reacting the polymer you scanned?</em></p>
</blockquote>
<p>Now, I feel like this problem might have been deliberately written to obscure this fact, but what it is describing is <em>exactly</em> the behavior of a <a href="https://en.wikipedia.org/wiki/Free_group">Free Group</a>, from group theory!</p>
<p>A fully reacted polymer is an element of the free group generated by the set of 26 letters of the alphabet, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?F%2826%29" alt="F(26)" title="F(26)" />. Basically, we can talk about interpeting the string <code>dabAcCaCBAcCcaDA</code> as <code>d &lt;&gt; a &lt;&gt; b &lt;&gt; A &lt;&gt; c &lt;&gt; C &lt;&gt; a &lt;&gt; C &lt;&gt; B &lt;&gt; etc.</code>, where <code>&lt;&gt;</code> is the group action (“mappend”, in Haskell-speak) and <code>A</code> stands for “<code>a</code> inverse”.</p>
<p>We can use <em><a href="https://hackage.haskell.org/package/free-algebras/docs/Data-Group-Free.html">Data.Group.Free</a></em> from the <em><a href="https://hackage.haskell.org/package/free-algebras">free-algebras</a></em> library, which offers a free group type <code>FreeGroupL</code>, to let us write:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Group.Free</span> <span class="kw">as</span> <span class="dt">FG</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">interpret ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">FG.FreeGroupL</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">interpret <span class="fu">=</span> foldMap inject</a></code></pre></div>
<p>where <code>inject :: Char -&gt; FreeGroupL Char</code> takes a <code>Char</code> and turns it into the element of our free group. We can do this by using the library’s <code>returnFree</code> and <code>invert</code> (from the <code>Group</code> typeclass):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span>           <span class="dt">Data.Algebra.Free</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">import</span>           <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Group</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">inject ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">FG.FreeGroupL</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">inject c</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">|</span> isAlpha c <span class="fu">&amp;&amp;</span> isLower c <span class="fu">=</span> returnFree c</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="fu">|</span> isAlpha c <span class="fu">&amp;&amp;</span> isUpper c <span class="fu">=</span> invert <span class="fu">$</span> returnFree (toLower c)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    <span class="fu">|</span> otherwise              <span class="fu">=</span> mempty       <span class="co">-- group identity element</span></a></code></pre></div>
<p>We can now use the “length” property of the free group (accessed by <code>length . FG.toList</code>) to solve Part 1:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">day05a ::</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">day05a <span class="fu">=</span> length <span class="fu">.</span> FG.toList <span class="fu">.</span> foldMap inject</a></code></pre></div>
<p>Was this problem actually deliberately written to obscure the fact that we have a group action? We can’t say for sure, but it definitely seems to paint an “imperative”, step-by-step picture. Most implementations might scan the list for things to replace, and iterate over things until there is no more change. The problem is also written to maybe imply the fact that ordering of reduction of different items across the string <em>might</em> matter (is it left to right, or right to left?).</p>
<p>However, we know that ordering of reduction <em>can’t</em> matter, because we have a <em>group action</em> <code>&lt;&gt;</code>, which we know from group theory is, by definition, associative. Knowing that we have a group, we can immediately throw away any thought of caring about things like sequential, imperative order, and the complications that might come from it.</p>
<p>I think that these useful properties about the reduction process are <em>not</em> obvious from an initial reading. Being able to recognize that we have a group is the key to unlocking all of these insights, <em>for free</em>!</p>
<h2 id="part-2">Part 2</h2>
<blockquote>
<p>Time to improve the polymer.</p>
<p>One of the unit types is causing problems; it’s preventing the polymer from collapsing as much as it should. Your goal is to figure out which unit type is causing the most problems, remove all instances of it (regardless of polarity), fully react the remaining polymer, and measure its length.</p>
<p>For example, again using the polymer <code>dabAcCaCBAcCcaDA</code> from above:</p>
<ul>
<li>Removing all <code>A</code>/<code>a</code> units produces <code>dbcCCBcCcD</code>. Fully reacting this polymer produces <code>dbCBcD</code>, which has length 6.</li>
<li>Removing all <code>B</code>/<code>b</code> units produces <code>daAcCaCAcCcaDA</code>. Fully reacting this polymer produces <code>daCAcaDA</code>, which has length 8.</li>
<li>Removing all <code>C</code>/<code>c</code> units produces <code>dabAaBAaDA</code>. Fully reacting this polymer produces <code>daDA</code>, which has length 4.</li>
<li>Removing all <code>D</code>/<code>d</code> units produces <code>abAcCaCBAcCcaA</code>. Fully reacting this polymer produces <code>abCBAc</code>, which has length 6.</li>
</ul>
<p>In this example, removing all <code>C</code>/<code>c</code> units was best, producing the answer <em>4</em>.</p>
<p><em>What is the length of the shortest polymer you can produce</em> by removing all units of exactly one type and fully reacting the result?</p>
</blockquote>
<p>Even the problem again seems to be written to obscure this fact, we can see that Part 2 is basically describing a <em>group homomorphism</em>. That is, it talks about functions that map <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?F%2826%29" alt="F(26)" title="F(26)" /> (the free group on the 26 letters of the alphabet) to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?F%2825%29" alt="F(25)" title="F(25)" /> (the free group on the letters of the alphabet excluding some cleaned letter).</p>
<p>Luckily, the free group <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?F%28S%29" alt="F(S)" title="F(S)" /> comes equipped with a free group homomorphism:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">foldMapFree</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Group</span> b</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="ot">-&gt;</span> (<span class="dt">FreeGroupL</span> a <span class="ot">-&gt;</span> b)     <span class="co">-- the group homomorphism</span></a></code></pre></div>
<p>That is, given any <code>a -&gt; b</code> for a group <code>b</code>, we get a group homormohpsim from <code>FreeGroupL a</code> to <code>b</code>. We can write a function from the <em>generators</em> of our group (in this case, <code>Char</code>), and it’ll give us a group homomorphism on the <em>free group</em> on our generators.</p>
<p>We can use this to write our <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?F%2826%29%20%5Crightarrow%20F%2825%29" alt="F(26) \rightarrow F(25)" title="F(26) \rightarrow F(25)" /> group homomorphism</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">foldMapFree</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">    ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">FreeGroupL</span> <span class="dt">Char</span>)  <span class="co">-- map letters to letters-minus-some-letter</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="ot">-&gt;</span> <span class="dt">FreeGroupL</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">FreeGroupL</span> <span class="dt">Char</span></a></code></pre></div>
<p>(Note that this type signature looks a lot like <code>=&lt;&lt;</code>, for monads. Coincidence?)</p>
<p>We can now create a “cleaned” version of our reaction by using:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">clean</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">Char</span>                                     <span class="co">-- ^ given a letter to clean</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="ot">-&gt;</span> (<span class="dt">FreeGroupL</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">FreeGroupL</span> <span class="dt">Char</span>)     <span class="co">-- ^ return a group homomorphism</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">clean c <span class="fu">=</span> foldMapFree <span class="fu">$</span> \d <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">        <span class="kw">if</span> d <span class="fu">==</span> c</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">          <span class="kw">then</span> mempty</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">          <span class="kw">else</span> returnFree d</a></code></pre></div>
<p>And so that’s part 2! We just need <code>clean</code> and this next function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">day05b (foldMap inject <span class="ot">-&gt;</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="fu">=</span> minimum [ length <span class="fu">$</span> FG.toList (clean c xs)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">              <span class="fu">|</span> c <span class="ot">&lt;-</span> [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>]</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">              ]</a></code></pre></div>
<p>Basically, we find the minimum of all of the possible “cleaned” lengths.</p>
<p>The best part about this, I think, is that we actually introduced a <em>large optimization</em>, completely <em>by accident</em>, thanks to group theory.</p>
<p>Because we recognize that this is a group homomorphism, we know the properties of group homomorphisms apply. Namely, the most important one: “Aggregating, then cleaning” is the <em>same</em> as “cleaning, then aggregating”.</p>
<p>That’s because all group homomorphisms necessarily obey the law:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">f x <span class="fu">&lt;&gt;</span> f y <span class="fu">==</span> f (x <span class="fu">&lt;&gt;</span> y)</a></code></pre></div>
<p>This means that we are free to either “clean first, then aggregate”, or “aggregate first, then clean”.</p>
<h2 id="whats-in-a-group">What’s in a Group?</h2>
<p>Now, I don’t know about you, but I definitely feel that this choice we have is <em>definitely not obvious</em> just from reading the problem immediately. Indeed, it seems like the problem might be written to obscure this choice from us: it’s implying that “cleaning, then reacting” is the only correct way, and “reacing, then cleaning” is not something that is even mentioned.</p>
<p>But, thanks to group theory, we know that these are equivalent, so we can substitute which ever version is more efficient!</p>
<p>This is, I believe, at the heart of what people say is the advantage of “using monoids”, “using monads”, “using functors”, etc. in Haskell. That’s because if we state our programs in terms of monoids, monads, groups, functors, etc., then we get <em>the entire body of group theory</em> (or monad theory, or functor theory, etc.) to help us make program reductions that aren’t immediately obviously legal but that have already been proven to be equivalent by mathematicians. We hijack their work!</p>
<p>We get program optimizations and reductions and substitutions for free, by “stealing” from the large body of such things that mathematicians have spent centuries collecting.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>These short posts won’t be counted as “paid” Patreon posts.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Advent of Code&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series" title="+Advent of Code"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/advent-of-code.html" class="tag-a-tag">#advent of code</a></li><li><a href="https://blog.jle.im/entries/tagged/algebra.html" class="tag-a-tag">#algebra</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series">+Advent of Code</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/introduction-to-singletons-4.html">Introduction to Singletons (Part 4)</a> (Previous)</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/alchemical-groups.html';
    this.page.identifier = 'advent-free-group';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>