<!DOCTYPE HTML>
<html><head><title>Practical Fun with Monads --- Introducing: MonadPlus! · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta property="og:site_name" content="in Code"><meta property="og:description" content="Monads. Haskell&#39;s famous for them, but they are one of the most ill-understood concepts to the public. They are mostly shrouded in mystery because of their association with how Haskell models I/O. This reputation is undeserved. Monads don&#39;t have anything to do with I/O. This series is a part of a global effort to pull away the shroud of mystery behind monads and show that they are fun! And exciting! And really just a way of chaining together functions that allow for new ways of approaching puzzles. The first sub-series (chapter?) will be on a specific class/family of monads known as MonadPlus. At the end of it all, we are going to be solving the classic logic puzzle, as old as time itself, using only the List monad instance, and no loops, queues, or fancy stuff like that: A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can&#39;t leave the wolf alone with the goat, or the wolf will eat the goat. He can&#39;t leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters? Let us enter a brave new world!"><meta property="og:type" content="article"><meta property="og:title" content="Practical Fun with Monads --- Introducing: MonadPlus!"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Practical Fun with Monads --- Introducing: MonadPlus!</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2013-12-09T10:09:26Z" pubdate="" class="pubdate">Monday December 9, 2013</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/monad-plus-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/practical-fun-with-monads-introducing-monadplus.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a>, <a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category" title="My slight ramblings on subjects of interest (to me and hopefully to you too!).
Lots of surveys and introducts to new subjects.">Ramblings</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>Monads. Haskell's famous for them, but they are one of the most ill-understood concepts to the public. They are mostly shrouded in mystery because of their association with how Haskell models I/O. This reputation is undeserved. Monads don't have anything to do with I/O.</p>
<p>This series is a part of a global effort to pull away the shroud of mystery behind monads and show that they are fun! And exciting! And really just a way of chaining together functions that allow for new ways of approaching puzzles.</p>
<p>The first sub-series (chapter?) will be on a specific class/family of monads known as <em>MonadPlus</em>. At the end of it all, we are going to be solving the classic logic puzzle, as old as time itself, using <strong>only</strong> the List monad instance, and no loops, queues, or fancy stuff like that:</p>
<blockquote>
<p>A farmer has a wolf, a goat, and a cabbage that he wishes to transport across a river. Unfortunately, his boat can carry only one thing at a time with him. He can't leave the wolf alone with the goat, or the wolf will eat the goat. He can't leave the goat alone with the cabbage, or the goat will eat the cabbage. How can he properly transport his belongings to the other side one at a time, without any disasters?</p>
</blockquote>
<p>Let us enter a brave new world!</p>
<h3>A quick review of monads</h3>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Note</strong></p>
<p>This article is written for both beginners --- people who have a fuzzy idea of monads and a minimal understanding of functional programming principles, but who have some experience in Object-Oriented Programming in a language like Java or C++ --- and intermediate Haskell users --- people who have a somewhat firm grasp on monads, but want to know about monads on a broader context (in particular, the MonadPlus typeclass).</p>
<p>Intermediate Haskell users will most likely find this post to be review, and I'll put a link in this paragraph when the next part is up so we can get to &quot;real&quot; Haskelling. However, this post might be beneficial if you read it while asking, at every point, &quot;How can this be abstracted and generalized?&quot;. It's a fun exercise!</p>
<p>This article attempts to explain all Haskell syntax that might be foreign to beginners. That being said, if you ever run into anything you can't understand, feel free to either read the articles above, give <a href="http://learnyouahaskell.com/">Learn You A Haskell</a> a quick read (you won't regret it!), or leave a comment --- I'd love to answer your questions or hear your responses!</p>
<p>This first post will cover the basics of MonadPlus with the simplest MonadPlus of all; the second part will explore the List MonadPlus, and the third will finally tackle the Wolf/Goat/Cabbage puzzle with our combined knowledge. &lt;/div&gt;</p>
<p>Okay, so as a Haskell blogger, I'm actually not allowed to write any monad tutorials. Luckily for you, however, I don't need too --- there are a wealth of great ones. <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Adit provides a great concise one</a>, and, if you want, <a href="http://www.haskell.org/haskellwiki/All_About_Monads">a more in depth one</a> is on the haskell.org wiki about all sorts of monads and using them in real life.</p>
<p>Remember --- different monads do not actually have any non-superficial relationship to one another. When we say monads, we just mean objects for which we have defined a way to chain together functions &quot;inside&quot; wrappers, containers, or contexts.</p>
<h2>Maybe, maybe not</h2>
<p>Monads are very useful when you are dealing with objects that are containers. Let's look at the most obvious container -- a <code>Maybe a</code>. A <code>Maybe a</code> is a container that can either be <code>Just x</code> (representing a successful result <code>x</code> of type <code>a</code>) or a <code>Nothing</code> (representing a failed result).</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<p>Hi! These &quot;Welcome to Haskell&quot; asides are going to be for you readers that are unfamiliar with Haskell syntax. Feel free to ignore them if you already feel comfortable.</p>
<p>Anyways, if you've ever done any object-oriented programming, you might be able to think of <code>Maybe a</code> as an abstract/virtual superclass with templates/generics --- <code>Maybe&lt;a&gt;</code>, kinda. And that superclass has two subclasses: <code>Just&lt;a&gt;</code>, which has one public instance variable <code>x</code> of type <code>a</code>, and <code>Nothing</code>, which contains no instance variables. &lt;/div&gt;</p>
<p>Often times you'll have functions that fail, and you want to chain them. The easiest way is that any function that is chained onto a failed value will be skipped; a failure is the final result.</p>
<p>Consider the <code>halve</code> function, which returns <code>Just (x `div` 2)</code> on a successful halving, or <code>Nothing</code> on an unsuccessful halving:</p>
<p>~~~haskell halve :: Int -&gt; Maybe Int -- 1 halve x | even x = Just (x <code>div</code> 2) -- 2 | otherwise = Nothing -- 3 ~~~</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<p>Hi again! There are some quick syntax features here.</p>
<ol>
<li>This first line declares that the type of the function <code>halve</code> is <code>Int -&gt; Maybe Int</code>, which means that it takes in an <code>Int</code> and returns a <code>Maybe Int</code> --- an integer wrapped in a &quot;Maybe&quot; container.</li>
<li>This says that if x is even, then return a successful <code>Just (x `div` 2)</code>. <code>x `div` 2</code> is x divided by two, in case you couldn't guess already.</li>
<li>Otherwise, return <code>Nothing</code> --- a failure.</li>
</ol>
<p>&lt;/div&gt;</p>
<p>Because Maybe comes built-in as a monad, we can now chain <code>halve</code>s on results of other <code>halves</code>, and have any failures automatically propagate to the end and short circuit your entire computation:</p>
<p>~~~haskell ghci&gt; halve 8 Just 4 ghci&gt; halve 7 Nothing ghci&gt; halve 8 &gt;&gt;= halve Just 2 ghci&gt; halve 7 &gt;&gt;= halve Nothing -- 1 ghci&gt; halve 6 &gt;&gt;= halve Nothing ghci&gt; halve 6 &gt;&gt;= halve &gt;&gt;= halve Nothing ghci&gt; halve 32 &gt;&gt; Nothing Nothing -- 2 ghci&gt; halve 32 &gt;&gt;= halve &gt;&gt;= halve &gt;&gt;= halve Just 2 ghci&gt; halve 32 &gt;&gt; Nothing &gt;&gt;= halve &gt;&gt;= halve &gt;&gt;= halve Nothing -- 3 ~~~</p>
<p>You can play with this yourself by <a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/Halve.hs">loading up the function yourself</a>.</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<p>In this article, code that begins with <code>ghci&gt;</code> represents commands to be entered at the interactive prompt, ghci. Code that doesn't is actual source code. &lt;/div&gt;</p>
<p>Remember, <code>&gt;&gt;=</code> means &quot;use the results of the last thing to calculate this next thing&quot; --- it &quot;chains&quot; the functions.</p>
<p>How does this work, exactly? That's not really in the scope of this article (any monad tutorial will explain this in more detail). But here are some interesting points:</p>
<ol>
<li>Note that this command doesn't even bother with the second <code>halve</code>. It knows that the end result will be <code>Nothing</code> no matter what (because <code>halve 7</code> is <code>Nothing</code>), so it just skips right past the second <code>halve</code>.</li>
<li><code>&gt;&gt;</code> is a special variation of <code>&gt;&gt;=</code>. <code>&gt;&gt;=</code> says &quot;take the result of the last thing and use it on this&quot;, while <code>&gt;&gt;</code> says &quot;ignore the result of the last thing and always return this&quot;. So <code>&gt;&gt; Nothing</code> means &quot;I don't care what the last thing succeeded with, I'm going to fail right here.&quot;</li>
<li>Disastrous! Even though halving 32 four times usually is fine (giving <code>Just 2</code>), having just one failure along the way means that the entire thing is a failure. <code>halve 32 &gt;&gt; Nothing</code> is <code>Nothing</code>, so the whole thing is just <code>(Nothing) &gt;&gt;= halve &gt;&gt;= halve &gt;&gt;= halve</code>.</li>
</ol>
<p>You can think of this failing phenomenon like this: At every step, Haskell attempts to apply <code>halve</code> to the result of the previous step. However, you can't <code>halve</code> a <code>Nothing</code> because a <code>Nothing</code> has no value to halve!</p>
<h3>Do notation</h3>
<p>Haskell provides a convenient way of writing chained <code>&gt;&gt;=</code>'s called do notation; here are a few samples matched with their equivalent <code>&gt;&gt;=</code> form:</p>
<p>~~~haskell ghci&gt; half 8 Just 4 ghci&gt; do half 8 Just 4</p>
<p>ghci&gt; halve 8 &gt;&gt;= halve Just 2 ghci&gt; do x &lt;- halve 8 | halve x Just 2</p>
<p>ghci&gt; halve 32 &gt;&gt;= halve &gt;&gt;= halve &gt;&gt;= halve Just 2 ghci&gt; do x &lt;- halve 32 | y &lt;- halve x | z &lt;- halve y | halve z Just 2</p>
<p>ghci&gt; halve 32 &gt;&gt; Nothing &gt;&gt;= halve &gt;&gt;= halve Nothing ghci&gt; do x &lt;- halve 32 | Nothing | y &lt;- halve x | z &lt;- halve y | halve z Nothing ~~~</p>
<p>In this notation, <code>x</code>, <code>y</code>, and <code>z</code>'s do not contain the <code>Just</code>/<code>Nothing</code>'s --- they represent the actual <strong>Ints inside them</strong>, so we can so something like <code>halve x</code> (where <code>halve</code> only takes Ints, not <code>Maybe Int</code>'s)</p>
<p>It kind of feels very imperative-y --- &quot;do <code>halve 32</code> and assign the result (16) to <code>x</code>...do <code>halve x</code> and assign the result (8) to <code>y</code>...&quot; --- but remember, it's still just a bunch of chained <code>&gt;&gt;=</code>s in the end.</p>
<h2>Failure is an option</h2>
<p>The important thing to note here is that &quot;do&quot; notation basically builds up one &quot;giant&quot; object. Remember the last two examples --- the second to last one, all of those lines were in an effort to build one giant <code>Just 2</code> value. In the last example, all of those lines were in an effort to build one giant <code>Nothing</code> value. That's why one <code>Nothing</code> &quot;ruined&quot; the whole thing. The entire computation is one big <code>Maybe a</code>. If at any point in your attempt to build that <code>Maybe a</code>, you fail, then you have <code>Nothing</code>.</p>
<p>Now, remember, saying &quot;x is a monad&quot; just means &quot;we have defined a way of chaining functions/operations on x&quot;. Just like how we can now chain multiple functions that return Maybe's (that don't take Maybe's as input). However, given any object, there is probably more than one way to meaningfully define this &quot;chaining&quot;.</p>
<p>Sometimes, it's useful to base your definition of chaining on the idea of a failure/success process. Sometimes it's useful to define chaining as &quot;We are building up either a success or a failure...and if at any point I fail, the whole thing is a failure&quot;.</p>
<p>There is a special name for this design pattern. In Haskell, we call something like this a &quot;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus">MonadPlus</a>&quot;[^disclaimer] [^either].</p>
<p>I know, it's an embarrassingly bad name, and it's like this is for historical reasons (related to the footnote above). The name doesn't even hint at a fail/succeedness. But we're stuck with it for pretty much the entire foreseeable future, so when you chose to adopt a success/failure model for your chaining process, you have a <em>MonadPlus</em>.</p>
<p>There is a vocabulary we can use so we can talk about all MonadPlus's in a general way:</p>
<ul>
<li>We call a success a &quot;return&quot;. Yeah...the name is super confusing because of how the word &quot;return&quot; is used in almost every other context in computer science. But hey. Oh well.</li>
<li>We call a failure an &quot;mzero&quot;. Yes, this name is pretty lame too.</li>
</ul>
<p>For Maybe, a &quot;return&quot; with the value <code>x</code> is <code>Just x</code>, and an &quot;mzero&quot; is a <code>Nothing</code>.</p>
<p>Something cool about Haskell is that if we type <code>return x</code>, it'll interpret it as an auto-success of value <code>x</code>. If we type <code>mzero</code>, it'll be an &quot;alias&quot; of whatever your failure is.</p>
<p>That means that for Maybe, <code>return x</code> is the same as <code>Just x</code>, and <code>mzero</code> is an alias for <code>Nothing</code>.</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<p>If you are familiar with object oriented languages like Java, MonadPlus is really like an <strong>interface</strong>. That is, if something is a MonadPlus, there is a &quot;guarantee&quot; that that something will implement/define <code>return</code> and <code>mzero</code> for that particular object. In this way, <code>return</code> and <code>mzero</code> are <em>polymorphic functions</em> that change their behavior based on what type you are talking about, and you can write code that works with all MonadPlus's generically without worrying about their actual type by using only <code>return</code> and <code>mzero</code> (instead of say, <code>Just</code> and <code>Nothing</code>).</p>
<p>In Haskell, the term we use (instead of &quot;interface&quot;) is &quot;<strong>typeclass</strong>&quot;. There are some subtle differences --- typeclasses are in general more powerful of a tool than interfaces --- but the two concepts provide similar roles in their respective languages. &lt;/div&gt;</p>
<p>As a small note, the term/command &quot;return&quot;/<code>return</code> is shared by all monads. However, monads don't ascribe any (general) conceptual &quot;meaning&quot; or &quot;purpose&quot; to return. For any old monad, it can mean whatever you want it to mean for that specific monad. However, in the context of MonadPlus, &quot;return&quot; has a very specific meaning: <em>succeed</em>. Because of this, &quot;return&quot; and &quot;succeed&quot; will be treated as synonyms in this article.</p>
<h3>MonadPlus examples</h3>
<p>To see this in action, let's revisit the last do block and make it more generic, and just rephrase it in a form that we are going to be encountering more when we solve our problem with the List monad (which is (spoilers) also a MonadPlus):</p>
<p>~~~haskell halveThriceOops :: Int -&gt; Maybe Int halveThriceOops n = do -- call with n = 32 x &lt;- halve n -- Just 16 -- 1 mzero -- Nothing -- 2 y &lt;- halve x -- (skip) -- 3 z &lt;- halve y -- (skip) return z -- (skip) -- 4 ~~~</p>
<p>Note that I've also included a line-by-line 'trace' of the do block with what the monad &quot;is&quot; at that point. It is what is calculated on that line, and it would be the value returned if you just exited at that step.</p>
<ol>
<li>Business as usual. Halve <code>n</code> if possible and place the reuslt in <code>x</code>. If <code>n</code> is 32, then <code>x</code> will be 16.</li>
<li>The failure. Remember, <code>mzero</code> means &quot;fail here automatically&quot;, which, in a Maybe object, means <code>Nothing</code>.</li>
<li>Now from here on, nothing else even matters...the entire block is a failure!</li>
<li>If possible, succeed with the value in <code>z</code>. This is supposed to be a <code>Just</code> with the value of <code>z</code>. Unfortunately, the entire block failed a long time ago. So sad!</li>
</ol>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Diversion</strong></p>
<p>A small diversion.</p>
<p>This is a little nicety, but there is the common library monad function <code>sequence :: Monad m =&gt; [m a] -&gt; m [a]</code>, which turns a <code>[Maybe a]</code> into a <code>Maybe [a]</code>. Conceptually, <code>sequence</code> turns a list of monads into a monad containing a list.</p>
<p>In the context of MonadPlus, it would be turning a list of Success/Failures into a succesful or failed list. It builds a succesful/failed list.</p>
<p>From what we have learned, if any part of that building process is a failure, the entire thing is necessarily a failure. This is reflected in <code>sequence</code>:</p>
<p>~~~haskell ghci&gt; sequence [Just 1, Just 4, Just 6] Just [1,4,6] ghci&gt; sequence [Just 1, Nothing, Just 6] Nothing ~~~</p>
<p>If you already know a few other common library monad functions (like <code>replicateM</code>, <code>forM</code>, etc.), try reasoning about how they would work on Maybe's and MonadPlus's in general --- they aren't just for IO! &lt;/div&gt;</p>
<h3>Guards</h3>
<p>It feels like just slapping in <code>mzero</code> willy-nilly is not that useful, because then things just fail always no matter what. Wouldn't it be handy to have a function that says &quot;fail right...here, if this condition is not met&quot;? Like <code>mzero</code>, but instead of always failing, fails on certain conditions.</p>
<p>Luckily, Haskell gives us one in the standard library:</p>
<p>~~~haskell guard :: MonadPlus m =&gt; Bool -&gt; m () -- 1 guard True = return () guard False = mzero ~~~</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<ol>
<li><p>This is a type signature, like before. We say that <code>guard</code> is a function that takes a <code>Bool</code> and returns a <code>m ()</code> --- a monad containing <code>()</code>. But we say that <code>m</code>, the monad, must be a MonadPlus.</p>
<p>For example, if we applied this to Maybe, the concrete signature would be <code>guard :: Bool -&gt; Maybe ()</code></p></li>
</ol>
<p>&lt;/div&gt;</p>
<p>So <code>guard</code> will make sure a condition is met, or else it fails the entire thing. If the condition is met, then it succeeds and places a <code>()</code> in the value.</p>
<p>We can use this to re-implement <code>halve</code>, using do notation, aware of Maybe's MonadPlus-ness:</p>
<p>~~~haskell halve :: Int -&gt; Maybe Int halve n = do -- &lt;halve 8&gt; &lt;halve 7&gt; guard $ even n -- Just () Nothing return $ n <code>div</code> 2 -- Just 4 (skip) ~~~</p>
<p>&lt;div class=&quot;note&quot;&gt; <strong>Welcome to Haskell!</strong></p>
<p><code>guard $ even n</code> seems confusing, but it is just shorthand for <code>guard (even n)</code>. We just don't like writing all those parentheses out. &lt;/div&gt;</p>
<p>So, first, <code>halve</code> is <code>Just ()</code> (succeeds with a blank value <code>()</code>) if <code>n</code> is even, or else <code>Nothing</code> (fails automatically) otherwise. Finally, if it has not yet failed, it attempts to succeed with <code>n `div` 2</code>.</p>
<p>You can trust me when I say this works the exact same way! You can <a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/HalveGuard.hs">try it out yourself</a>!</p>
<p>As a friendly reminder, this entire block is &quot;compiled&quot;/desugared to:</p>
<p>~~~haskell halve n :: Int -&gt; Maybe Int halve n = guard (even n) &gt;&gt; return (n <code>div</code> 2) ~~~</p>
<h2>A practical use</h2>
<p>We aren't where we need to be to begin tackling that Wolf/Goat/Cabbage puzzle yet...so to let this article not be a complete anticlimax (as a result of my bad planning --- I had originally intended to do the entire three-part series as one article), let's look at a practical problem that you can solve using the Maybe monad.</p>
<p>The obvious examples are situations where it is useful to be able to chain failable operations such as retrieving things from a database or a network connection or applying partial functions (functions that only work on some values, like our <code>halve</code>).</p>
<p>However, here is a neat one.</p>
<p>Let's say we are making a game where you can lose health by being hit or gain health by picking up powerups. We want to calculate the final health at the end of the game. It seems a bit easy: just add up all the losses and gains! Unfortunately, it's not so simple --- it needs to be implemented such that if your health ever dips below 0, you are dead. Forever. No powerups will ever help you.</p>
<p>Think about how you would implement this normally. You might have a state object that stores the current health as well as a flag with the current dead/alive state, and at every step, check if the health is 0 or lower; if it is, swap the flag to be dead and ignore all other updates.</p>
<p>But let's try doing this instead with the Maybe monad:</p>
<p>~~~haskell -- source: https://github.com/mstksg/inCode/tree/master/code-samples/monad-plus/MaybeGame.hs#L26-51 -- die or fail immediately die :: Maybe Int die = mzero -- or die = mzero</p>
<p>-- if not dead, sets the health to the given level setHealth :: Int -&gt; Maybe Int setHealth n = return n -- or setHealth n = return n</p>
<p>-- damage the player (from its previous health) and check for death hit :: Int -&gt; Maybe Int hit currHealth = do let newHealth = currHealth - 1 guard $ newHealth &gt; 0 -- fail/die immediately unless newHealth -- is positive return newHealth -- succeed with newHealth if not already -- dead</p>
<p>-- an alternative but identical definition of <code>hit</code>, using &gt;&gt;= and &gt;&gt; hit' :: Int -&gt; Maybe Int hit' currHealth = guard (newHealth &gt; 0) &gt;&gt; return newHealth where newHealth = currHealth - 1</p>
<p>-- increase the player's health from its previous health powerup :: Int -&gt; Maybe Int powerup currHealth = return $ currHealth + 1 ~~~</p>
<p>~~~haskell ghci&gt; setHealth 2 &gt;&gt;= hit &gt;&gt;= powerup &gt;&gt;= hit &gt;&gt;= powerup &gt;&gt;= powerup Just 3 ghci&gt; setHealth 2 &gt;&gt;= hit &gt;&gt;= powerup &gt;&gt;= hit &gt;&gt;= hit &gt;&gt;= powerup Nothing ghci&gt; setHealth 10 &gt;&gt;= powerup &gt;&gt; die &gt;&gt;= powerup &gt;&gt;= powerup Nothing ghci&gt; do h0 &lt;- setHealth 2 -- Just 2 | h1 &lt;- hit h0 -- Just 1 | h2 &lt;- powerup h1 -- Just 2 | h3 &lt;- hit h2 -- Just 1 | h4 &lt;- hit h3 -- Nothing | h5 &lt;- powerup h4 -- (skip) | h6 &lt;- powerup h5 -- (skip) | return h6 -- (skip) Nothing ~~~</p>
<p>And voilà! <a href="https://github.com/mstksg/inCode/blob/master/code-samples/monad-plus/MaybeGame.hs">Fire it up yourself</a> if you want to test it out in person!</p>
<p>You can think of the last do block conceptually this way: remember, <code>h3</code> does not represent the <code>Just 1</code> value --- <code>h3</code> represents the number <em>inside</em> the <code>Just 1</code> --- the 1. So <code>h4</code> is supposed to represent the number inside its value, too. But because <code>hit h3</code> results in <code>Nothing</code>; <code>Nothing</code> has no value &quot;inside&quot;, so <code>h4</code> doesn't even have a value! So obviously it doesn't even make sense to call <code>powerup h4</code>...therefore <code>h5</code> has no value either! It's therefore meaningless to call <code>powerup h5</code>, so meaningless to <code>return h6</code>...the entire thing is a beautiful disaster. A fiasco. Mission accomplished!</p>
<p>The whole thing works as expected; you can even die suddenly with <code>die</code>, which ignores your current health.</p>
<p>Interestingly enough, we could actually eliminate all references to Maybe altogether by always using <code>return</code> and <code>mzero</code> instead of <code>Just</code> and <code>Nothing</code>. And if we make our type signatures generic enough, we could use this with <em>any</em> MonadPlus! But that is for another day.</p>
<h2>Looking forward</h2>
<p>Wow, who knew you could spend so much time talking about failure. Anyways, this is a good place to stop before we move onto how List is also a MonadPlus. Okay, so what have we learned?</p>
<ul>
<li>Monads are just a way of chaining functions on objects, and of course, every object's chaining process is different. In fact there might be even more than one way to meaningfully chain functions on an object!</li>
<li>One useful &quot;chaining approach&quot; is to model things as success-failure chains, where you are building something from successes, but if you fail once in the process, the entire process fails. An object that uses this approach/design pattern is called a MonadPlus.</li>
<li>The Maybe object is one such example. We can define 'chaining' failable functions as functions that continue if the previous function succeeded, or propagate a failure if the previous function fails. A failable function, for a Maybe object, is a function <code>:: a -&gt; Maybe b</code> or even <code>:: Maybe b</code>.</li>
<li>There is a common vocabulary for talking about MonadPlus concepts --- &quot;return&quot; means &quot;succeed with this value&quot;, and &quot;mzero&quot; means &quot;fail now&quot;.</li>
<li>Due to Haskell's polymorphism, we can &quot;forget&quot; we are using Maybe and in fact talk about/write for &quot;general&quot; MonadPlus's, with <code>return x</code> and <code>mzero</code> resulting in the appropriate success/fail objects.</li>
</ul>
<p>For the mean time, think about how it might make sense to chain operations on lists (ie, repeatedly applying functions <code>:: a -&gt; [b]</code> to lists).</p>
<p>By this, I mean, given a function that turns a value into a list of values <code>f :: a -&gt; [b]</code>, find a way to meaningfully &quot;chain&quot; that function to a previous list and get a new list:</p>
<p>~~~haskell ghci&gt; oldList &gt;&gt;= f newList -- a new list based on old list; f &quot;chained&quot; to <code>oldList</code>. ~~~</p>
<p>Is there more than one way to think about chaining them, even? And in what ways we can define this &quot;chaining&quot; to represent success/failure? Until next time!</p></div><footer><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;MonadPlus: Success/Failure Monads&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+monadplus-success-failure-monads.html" class="tag-a-series" title="Short series on the abstractions and uses of the MonadPlus typeclass --- objects
whose monad instance represent success/failure."> series history</a>.</div></li><li><div>This entry is a part of a series called <b>&quot;Practical Monads&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+practical-monads.html" class="tag-a-series" title="Ongoing series exploring interesting objects and their curious monad instances."> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/monads.html" class="tag-a-tag">#monads</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/category/@ramblings.html" class="tag-a-category">@RAMBLINGS</a></li><li><a href="https://blog.jle.im/entries/series/+monadplus-success-failure-monads.html" class="tag-a-series">+MonadPlus: Success/Failure Monads</a></li><li><a href="https://blog.jle.im/entries/series/+practical-monads.html" class="tag-a-series">+Practical Monads</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/a-brief-primer-on-classical-and-quantum-mechanics.html">A Brief Primer on Classical and Quantum Mechanics for Numerical Techniques</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/the-list-monadplus-practical-fun-with-monads-part.html">The List MonadPlus --- Practical Fun with Monads (Part 2 of 3)</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus.html';
    this.page.identifier = 'monad-plus-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2016 Justin Le</div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="https://coinbase.com/mstksg">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>