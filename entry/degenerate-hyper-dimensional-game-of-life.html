<!DOCTYPE HTML>
<html><head><title>Degenerate Hyper-Dimensional Game of Life · in Code</title><meta name="description" content="Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
"><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="tldr: Over the course of a month, we were able to successive new mathematical properties of a “degenerate” hyper-dimensional game of life&quot; to take a “10 dimensions may just barely be possible on a supercomputer” to “10 dimensions is easy enough to be run on any modern browser, and 40 dimensions can be reached with a compiled language”. Includes interactive visualizations and simulations! This is a story about breaking the degenerate hyper-dimensional game of life by exploratory visualizations and math! Let’s travel back in time: t’was the night before Thursday, December 17, 2020, The release of “Conway Cubes”, day 17 of the “Advent of Code” (fun little coding puzzles building up to Christmas). One part about Advent of Code I’ve always found especially fun is that, because the problems are so self-contained and tidy, they are often open-ended in the interesting ways you can solve them or expand them. On the surface, Day 17 seemed to essentially be a straightforward extension of Conway’s Game Of Life (“GoL”). GoL is a simulation played out on a 2d grid, where cells are “on” and “off”, and at each step of the simulation, the on/off cells spread and propagate in fascinating ways based on the state of their neighbors. The twist of the Advent of Code puzzle is it asks what would happen if we played out the rules of GoL in 3d, and then 4d! The “starting conditions” are a 8x8 2D grid picked out for each participant, and the puzzle solution is the number of live cells after six steps. My personal starting conditions were: #####..# #..###.# ###..... .#.#.#.. ##.#..#. ######.. .##..### ###.#### I submitted my answer with a direct implementation (scoring the 66th spot on the leader board for that day)…and that was that for the “competitive” part. But the real fun always starts after! When discussing with some friends, we started talking about the trade-offs of different implementations and realized that the extra dimensionality was no joke…as you upped the number of dimensions, the number of points you have to consider grow as O((2t+6)^d), and the number of neighbors of each point to check grows as O(3^d). So for 4D it’s definitely possible to solve naively…but anything higher is going to strain. My naive solution on 6D took three minutes, and 7D in a reasonable amount of time (612,220,032 points with 2,186 neighbors each) seemed impossible on commercial consumer hardware because of the sheer number of points in 7D space. But I thought…what if a breakthrough in optimization was possible? I set my goal as 10D (3,570,467,226,624 points with 59,048 neighbors each), not knowing if it was possible."><meta property="og:type" content="article"><meta property="og:title" content="Degenerate Hyper-Dimensional Game of Life"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/d3@6.5.0"></script><script type="text/javascript" src="https://blog.jle.im/purescript/gol.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/d3-simple-slider@1.10.3"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><li><a href="https://cv.jle.im">cv</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><div class="unposted-banner">Unposted entry</div><h1 id="title">Degenerate Hyper-Dimensional Game of Life</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/advent-gol.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/degenerate-hyper-dimensional-game-of-life.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>tldr: Over the course of a month, we were able to successive new mathematical properties of a “degenerate” hyper-dimensional game of life" to take a “10 dimensions may just barely be possible on a supercomputer” to “10 dimensions is easy enough to be run on any modern browser, and 40 dimensions can be reached with a compiled language”. Includes interactive visualizations and simulations!</p>
<p>This is a story about breaking the degenerate hyper-dimensional game of life by exploratory visualizations and math! Let’s travel back in time: t’was the night before Thursday, December 17, 2020, The release of <a href="https://adventofcode.com/2020/day/17">“Conway Cubes”</a>, day 17 of the “Advent of Code” (fun little coding puzzles building up to Christmas). One part about Advent of Code I’ve always found especially fun is that, because the problems are so self-contained and tidy, they are often <em>open-ended</em> in the interesting ways you can solve them or expand them.</p>
<p>On the surface, Day 17 seemed to essentially be a straightforward extension of <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Conway’s Game Of Life</a> (“GoL”). GoL is a simulation played out on a 2d grid, where cells are “on” and “off”, and at each step of the simulation, the on/off cells spread and propagate in fascinating ways based on the state of their neighbors.</p>
<p>The twist of the Advent of Code puzzle is it asks what would happen if we played out the rules of GoL in 3d, and then 4d! The “starting conditions” are a 8x8 2D grid picked out for each participant, and the puzzle solution is the number of live cells after six steps. My personal starting conditions were:</p>
<pre><code>#####..#
#..###.#
###.....
.#.#.#..
##.#..#.
######..
.##..###
###.####</code></pre>
<p>I submitted my answer with a direct implementation (scoring the 66th spot on the leader board for that day)…and that was that for the “competitive” part. But the real fun always starts after! When discussing with some friends, we started talking about the trade-offs of different implementations and realized that the extra dimensionality was no joke…as you upped the number of dimensions, the number of points you have to consider grow as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%28%282t%2B6%29%5Ed%29" alt="O((2t+6)^d)" title="O((2t+6)^d)" />, and the number of neighbors of each point to check grows as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%283%5Ed%29" alt="O(3^d)" title="O(3^d)" />. So for 4D it’s definitely possible to solve naively…but anything higher is going to strain. My naive solution on 6D took three minutes, and 7D in a reasonable amount of time (612,220,032 points with 2,186 neighbors each) seemed <em>impossible</em> on commercial consumer hardware because of the sheer number of points in 7D space. But I thought…what if a breakthrough in optimization was possible? I set my goal as 10D (3,570,467,226,624 points with 59,048 neighbors each), not knowing if it was possible.</p>
<p>And soon…a breakthrough did come! Someone brought up that if we look at the 3d version, we see there’s actually a <em>mirror symmetry</em>! That is, because everything starts off on the xy plane, with z=0, the resulting progression must be symmetrical on both sides (positive and negative z).</p>
<figure>
<img src="/img/entries/advent-gol/life3d.gif" title="d=3 animation u/ZuBsPaCe" alt="" /><figcaption>d=3 animation by <a href="https://www.reddit.com/r/adventofcode/comments/kfa3nr/2020_day_17_godot_cubes_i_think_i_went_a_bit_too/">u/ZuBsPaCe</a></figcaption>
</figure>
<p>In the end that means we only have to simulate one of the “halves”/“quadrants” of the higher-dimensional space, since all “quadrants” are identical! This saves down the number of points by a factor of two for each extra dimension (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%282%5E%7Bd-2%7D%29" alt="O(2^{d-2})" title="O(2^{d-2})" />). My 7D implementation completed in 6 minutes! 8D still hung forever, though.</p>
<p>Well, it didn’t get us to d=10…but this discovery completely changed how we saw this puzzle. With one breakthrough down, we began to believe that there would be more just around the corner, made possible by our problem’s special degeneracy (that is, that we start on a 2d slice).</p>
<p>Such a dream (as posed in <a href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/">this reddit thread I started</a>) turned into a month-long quest of breakthrough after breakthrough, exploiting different aspects of this degeneracy! It was a long, harrowing journey full of sudden twists and turns and bursts of excitement when new innovations came. And in the end, the hopeful question “What if d=10 was possible?” turned into “d=10 in 100ms, d=40 in eight minutes.” I even got d=10 fast enough to run on easily any modern browser — this post includes those simulations! Furthermore, the whole journey became an adventure in the power of visualization combined with abstract thinking.</p>
<p>So, let’s take a deep dive — deeper than you probably ever expected to dive into any particular degenerate starting conditions of a hyper-dimensional game of life :D</p>
<p>There will be python code samples here and there, but just for context, my actual solvers I developed along the way were written in Haskell, and all of the solving logic embedded in this post was written in Purescript and compiled to Javascript.</p>
<h2 id="starting-off">Starting Off</h2>
<p>First of all, let’s meet our friend for the rest of this journey. In the drawer below, you can draw (with your mouse) the 8x8 grid you want to simulate for the rest of this post. As you draw, the rest of the visualizations will update to use this as their initial conditions.</p>
<div id="golDrawer">
<p>Please enable Javascript</p>
</div>
<p>And for fun, here’s a 2D vanilla game of life implementation (for six time steps) to test out your creation. I recommend trying out some of the <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Examples_of_patterns">interesting well-known patterns</a>!</p>
<div id="gol2D">
<p>Please enable Javascript</p>
</div>
<p>Now that that’s there, let’s start at the beginning: what’s the naive, baseline solution?</p>
<p>A reasonable initial thought would be:</p>
<ol type="1">
<li>Keep a 2D (or 3D, or 4D, etc.) array of booleans.</li>
<li>At each step:
<ol type="a">
<li>Make a fresh copy of the entire space (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%28n%5Ed%29" alt="O(n^d)" title="O(n^d)" />).</li>
<li>Loop over each item in your array (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%28n%5Ed%29" alt="O(n^d)" title="O(n^d)" />). Count all of the neighbors (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%283%5Ed%29" alt="O(3^d)" title="O(3^d)" />) that are <code>true</code> (“alive”), and write to the new array based on the rules table of GoL (2 or 3 neighbors for a live cell stays alive, 3 neighbors for a dead cell turns alive).</li>
</ol></li>
<li>You have a new array! Loop again six times.</li>
</ol>
<p>Sounds reasonable enough! And this does work for the 2D case pretty well (like in the <a href="https://adventofcode.com/2020/day/11">Day 11 puzzle</a>). However, there are some clear issues when moving into higher dimensions. The size of your array grows exponentially on your dimension, and so does the number of neighbors you’d have to check. And the <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality">curse of dimensionality</a> assures us that more and more of that array would become wasted as the proportion of “on” points shrinks to zero for higher dimensions.</p>
<p>Oh, but what’s that? The percentage of “on” points shrinks to zero for higher dimensions? That actually sounds like something we can use to our advantage! The…<em>blessing of dimensionality</em>, I daresay? Because we know the vast majority of our points will be “off”, there’s another method.</p>
<ol type="1">
<li>Keep a <em>set</em> of points that are “on”.</li>
<li>At each step:
<ol type="a">
<li><p>Initialize a dynamic map (key-value store) of points to integers. This map associates each point to the number of live neighbors it has.</p></li>
<li><p>For each step, iterate over each of your “on” points, expand all of their neighbors <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n_i" alt="n_i" title="n_i" /> (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%28O%283%5Ed%29%29" alt="(O(3^d))" title="(O(3^d))" />), and increment the value associated with <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n_i" alt="n_i" title="n_i" /> in your dynamic map.</p>
<p>For example, if the point <code>&lt;2,3&gt;</code> is in your set of live points, you would add increment the map’s values at keys <code>&lt;1,2&gt;</code>, <code>&lt;2,2&gt;</code>, <code>&lt;3,2&gt;</code>, etc.: all 8 neighbors of <code>&lt;2,3&gt;</code>.</p></li>
<li><p>Collect your new set of on points: keep all of the keys in your dynamic map corresponding to live points if their integers are 2 or 3, and keep all of the keys in your dynamic map corresponding to dead points if their integers are 3.</p></li>
</ol></li>
<li>You have a new set! Loop again six times!</li>
</ol>
<p>I discuss this algorithm much more deeply with actual code in <a href="https://github.com/mstksg/advent-of-code-2020/blob/master/reflections-out/day17.md">my solutions write-up in my Advent of Code reflections journal</a>.</p>
<p>This method nets us a huge advantage because we now only have to loop over the number of items that we know are alive! Any points far away from our set of alive points can be properly ignored. This narrows down our huge iteration space, and the benefits compound with every dimension due to the blessing of dimensionality!</p>
<p>The nice thing about this method is that it’s easy enough to generalize to any dimension: instead of, say, keeping <code>[x,y]</code> in your set for 2D, just keep <code>[x,y,z]</code> for 3D, or any length array of coordinates. One minor trick you need to think through is generating all <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?3%5Ed-1" alt="3^d-1" title="3^d-1" /> neighbors, but but that’s going to come down to a d-ary <a href="https://observablehq.com/@d3/d3-cross">cartesian product</a> of <code>[-1,0,1]</code> to itself.</p>
<p>Here’s a version of the set-based implementation, using a nice trick I learned from <a href="https://twitter.com/phaazon_">phaazon</a> to get the right neighbors by doing a cartesian product against <code>[0,-1,1]</code>, which leaves the first item as the <code>&lt;0,0&gt;</code> “original point” we want to exclude:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="im">from</span> itertools <span class="im">import</span> islice, product</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">def</span> mk_neighbs(point):</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">&quot;&quot;&quot;Return neighboring points, each equally weighted</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="co">    (1,2)</span></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">    =&gt; [(1, 1), (1, 3), (0, 2), (0, 1), (0, 3), (2, 2), (2, 1), (2, 3)]</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    gen <span class="op">=</span> product(<span class="op">*</span>[[x, x<span class="dv">-1</span>, x<span class="op">+</span><span class="dv">1</span>] <span class="cf">for</span> x <span class="kw">in</span> point])</span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="co"># skip the first item, the original point</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="bu">next</span>(gen)</span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="cf">return</span> gen</span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="kw">def</span> step(pts):</span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="co">&quot;&quot;&quot;Takes a set of points (tuples) and steps them in the simulation</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    neighbs <span class="op">=</span> Counter()</span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="cf">for</span> point <span class="kw">in</span> pts:</span>
<span id="cb2-20"><a href="#cb2-20"></a>        neighbs <span class="op">+=</span> Counter(mk_neighbs(point))</span>
<span id="cb2-21"><a href="#cb2-21"></a></span>
<span id="cb2-22"><a href="#cb2-22"></a>    <span class="kw">def</span> validate(point, ncount):</span>
<span id="cb2-23"><a href="#cb2-23"></a>        <span class="cf">if</span> point <span class="kw">in</span> pts:</span>
<span id="cb2-24"><a href="#cb2-24"></a>            <span class="cf">return</span> ncount <span class="op">==</span> <span class="dv">2</span> <span class="kw">or</span> ncount <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>        <span class="cf">else</span>:</span>
<span id="cb2-26"><a href="#cb2-26"></a>            <span class="cf">return</span> ncount <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb2-27"><a href="#cb2-27"></a></span>
<span id="cb2-28"><a href="#cb2-28"></a>    <span class="cf">return</span> [p <span class="cf">for</span> p, n <span class="kw">in</span> neighbs.items() <span class="cf">if</span> validate(p, n)]</span></code></pre></div>
<h2 id="three-dimensions">Three Dimensions</h2>
<p>Let’s see how this looks for the 3D case! To make things easier to see, we can render things in “slices” in 3D space: each grid represents a slice at a different z level (ie, the z=0 square represents all squares <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%3Cx%2Cy%2C0%3E" alt="&lt;x,y,0&gt;" title="&lt;x,y,0&gt;" />). Press “Play” to have the simulation cycle through 6 time steps!</p>
<div id="gol3D">
<p>Please enable Javascript</p>
</div>
<p>In “reality”, each of those 13 slices above are stacked on top of each other in 3D space. You’ll see that most initial conditions will spread out from the center z=0 point, which means they are actually spreading “up and down” the z axis.</p>
<p>If you mouse over (or tap) any individual tiny <code>&lt;x,y&gt;</code> cell, you’ll see the all of the 26 (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?3%5Ed-1" alt="3^d-1" title="3^d-1" />) <code>&lt;x,y,z&gt;</code> 3D neighbors of the point you’re hovering over highlighted in blue — these 26 points form a 3D cube around your mouse once everything is stacked correctly. You can use this cube to help see how the simulation progresses. If your mouse is hovering over a live cell, and there are 2 or 3 live cells highlighted in your cube, it’ll stay alive in the next time step. If your mouse is hovering over a dead cell and there are exactly 3 live cells highlighted in your cube, it will come alive in the next step.</p>
<h3 id="axis-reflection-symmetry">Axis Reflection Symmetry</h3>
<p>Try playing around with different initial conditions to see how they evolve! See any patterns?</p>
<p>Well, the yellow highlight might have given given things away, but…note that the entire thing has reflection symmetry across z=0! z=1 is always the same as z=-1, z=2 is always the same as z=-2, etc. Fundamentally, this is because our starting solution has z-plane symmetry: the initial 2D slice is symmetric with reflections across z, because z=0. This is the first “degeneracy” that this blog post’s title is referring to. The negative and positive directions are interchangeable! This is reflected in the yellow highlight on hover: when you mouse-over a z square, its corresponding reflected twin is highlighted, and will always be identical.</p>
<p>This means that we actually only need to simulate <em>positive</em> z’s…and for our final answer we just “un-reflect” to get the total number.</p>
<p>This is exactly what freenode IRC user sim642 noticed late into the night of December 16th:</p>
<blockquote>
<p>I wanted to ask this before but forgot: did anyone try to take advantage of the symmetry, e.g. in z axis in part 1? Should halve the amount of calculations you have to do.</p>
<p>Only some extra work at the end to differentiate z=0 and z&gt;0 positions to know which to count twice And in part 2 I feel like you could also exploit the symmetry in w axis simultaneously</p>
</blockquote>
<p>Wow, let’s do this! Apparently the picture is slightly more complicated than simply halving the points. We also need to change how to distribute neighbors. That’s because, once we commit to only keeping the positive z’s, some cells need to be double-counted as neighbors. In particular, any <code>z=0</code> cell would previously had a neighbor at both <code>z=-1</code> and <code>z=1</code>…but now if we only keep the positive z’s, it would have <code>z=1</code> as a neighbor <em>twice</em>.</p>
<p>The following interactive demo lets you explore what this looks like:</p>
<div id="golSyms3DForward">
<p>Please enable Javascript</p>
</div>
<p>Each square represents an entire “slice” of z. When you mouse-over or tap a z-cell, its z-neighbors are highlighted with how many times that neighbor has to be counted, and the green bar tells you from what direction that neighborship arose from. For example, mousing over z=3, z=2 and z=4 get highlighted with the values “1” because they are neighbors of 3, on the left and right side (respectively). Note that one neat property for all squares (except for z=6, which goes off the scale) is that the “total” higher-dimensional neighbors is always 2 (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?3%5E%28d-2%29-1" alt="3^(d-2)-1" title="3^(d-2)-1" />), it’s just that where those neighbors fall is re-arranged slightly.</p>
<p>The tricky square is now z=0: if you mouse-over it, you’ll see that it has a single neighbor z=1 that is counted twice, as a neighbor from both the left and right side.</p>
<p>We can compute the above diagram by expanding z=0 to its neighbors (z=-1, and z=1), applying the absolute value function, and seeing how points double-up. This gives us the “forward neighbors”, and we can directly use it for the original “keep the full array” GoL implementation.</p>
<p>However, for the “keep active points and expand their neighbors” GoL implementation…we have to find the opposite. Remember that to build our “neighbors map” (the map of points to how many active neighbors they have), we have each cell “pro-actively” add its contributions to all of its neighbors. <code>&lt;1,2,3&gt;</code> is a neighbor to <code>&lt;1,3,4&gt;</code> once, so when we expand <code>&lt;1,2,3&gt;</code> we would increment the value in the map at <code>&lt;1,3,4&gt;</code> by 1 because <code>&lt;1,2,3&gt;</code> is a neighbor of <code>&lt;1,3,4&gt;</code> once.</p>
<p>Now, how do we count <code>&lt;1,3,1&gt;</code> expanding into <code>&lt;1,3,0&gt;</code>? Well, normally, <code>&lt;1,3,1&gt;</code> is a neighbor of <code>&lt;1,3,0&gt;</code> once. However, if we only keep the normalized z values, <code>&lt;1,3,1&gt;</code> is a neighbor of <code>&lt;1,3,0&gt;</code>…twice! To compute the total neighbor count of <code>&lt;1,3,0&gt;</code>, we have to count the contribution from <code>&lt;1,3,1&gt;</code> twice (once for <code>&lt;1,3,1&gt;</code> and once for <code>&lt;1,3,-1&gt;</code>, which was normalized away).</p>
<p>That means we have to follow the rules in the previous demo <em>backwards</em>, like:</p>
<div id="golSyms3DReverse">
<p>Please enable Javascript</p>
</div>
<p>These are the “reverse neighbors”: how much times a given point counts as a neighbor for its surrounding points. Here, mousing over z=1 shows that it counts as a neighbor for z=0 twice, from both the left and the right. It also counts as a neighbor for z=2 once (from the left side).</p>
<p>We can account for this by hard-coding the rules into our step algorithm: if our z goes from <code>1</code> to <code>0</code>, increment its value twice in the neighbor map. Otherwise, simply increment by 1 as normal.</p>
<p>This rule is relatively easy to implement, and as a result we now halved our total number of points we need to keep and check for 3D! It’s also simple enough to generalize (just do the <code>1 -&gt; 0</code> check for every “higher dimension” and double its contribution for each <code>1 -&gt; 0</code> transition is seen)…and that means we reduce the number of 4D points we need to track by a factor of four, the number of 5D points by a factor of eight, the number of 6D points by a factor of 16… now our total points to check only grows as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%28n%5Ed%20%2F%202%5E%7Bd-2%7D%29" alt="O(n^d / 2^{d-2})" title="O(n^d / 2^{d-2})" /> instead of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%28n%5Ed%29" alt="O(n^d)" title="O(n^d)" />!</p>
<p>This discovery late in the Tuesday night of the 16th was what inspired us to believe and dream that more breakthroughs might be possible to bring things down even further.</p>
<p>And those breakthroughs soon came…</p>
<h2 id="four-dimensions">Four Dimensions</h2>
<p>Let’s look at how the 4 dimensions works! We can visualize this by taking “z-w” slices at different x-y planes as well. The labels in these boxes are the <code>&lt;z,w&gt;</code> of each slice. The very center is <code>&lt;z,w&gt; = &lt;0,0&gt;</code> the row in the middle from the top is <code>w=0</code>, and the column in the very middle from the left is <code>z=0</code>. It’s basically taking the 3D visualization above and expanding it in an extra dimension. Press “Play” to run your initial conditions!</p>
<div id="gol4D">
<p>Please enable Javascript</p>
</div>
<p>We get something interesting as well: most initial conditions will spread out from the center <code>&lt;z,w&gt; = &lt;0,0&gt;</code> point radially, spreading outwards into positive and negative z and w. Mouse-over or tap any individual tiny <code>&lt;x.y&gt;</code> cell and you’ll see each of its 80 (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?3%5Ed-1" alt="3^d-1" title="3^d-1" />) <code>&lt;x,y,z,w&gt;</code> 4D neighbors highlighted in blue, forming a little 3x3x3 “tesseract” (4D cube, or hypercube). Like in the 3D case, you can use this little hypercube to track how the simulation progresses: if your mouse if hovering over a live cell with 2 or 3 live cells in its hypercube, it’ll stay alive in the next step, if it’s hovering over a dead cell with 3 live cells in its hypercube, it’ll come alive in the next step.</p>
<h3 id="diagonal-reflection-symmetry">Diagonal Reflection Symmetry</h3>
<p>Play around and explore how simulations evolve! You will notice that the axis reflection symmetry is still preserved, but four ways (the slice at <code>&lt;z,w&gt; = &lt;3,4&gt;</code> is always going to be identical to the slice at <code>&lt;-3,4&gt;</code>, <code>&lt;3,-4&gt;</code>, and <code>&lt;-3,-4&gt;</code>). These are reflected in the “deep yellow” highlights above when you mouse over a zw square. (Ignore the lighter yellow highlights for now!)</p>
<p>And now, for the next big breakthrough. I think this situation shows the power of visualization well, because this exact visualization was what reddit user <em>u/cetttbycett</em> was looking at when <a href="https://www.reddit.com/r/adventofcode/comments/kfjhwh/year_2020_day_17_part_2_using_symmetry_in_4d_space/">they made this post</a> late Thursday the 17th/early Friday the 18th…and everything changed <em>forever</em>.</p>
<blockquote>
<p>I noticed that the expansion of active cubes for part 2 is symmetric with respect to two hyperplanes in 4d space: These hyperplanes can be described by w = 0 and w-z = 0.</p>
<p>Using these symmetries could make the code nearly eight times as fast.I was wondering if anyone tried that.</p>
</blockquote>
<p>What <em>u/cetttbycettt</em> saw is what you can see now in the demo above: it’s all of the <em>light yellow</em> highlighted squares when you mouse-over. In addition to the z=0 and w=0 lines (the two lines down the middle, up-down and left-right), we also have another line of symmetry: z=w and w=z, the diagonal lines!</p>
<p>That’s right, a zw slice at <code>&lt;z,w&gt;=&lt;3,4&gt;</code> is <em>identical</em> to the one at <code>&lt;4,3&gt;</code>, and so also <code>&lt;-3,4&gt;</code>, <code>&lt;3,-4&gt;</code>, <code>&lt;-3,-4&gt;</code>, <code>&lt;-4,3&gt;</code>, <code>&lt;4,-3&gt;</code>, and <code>&lt;-4,-3&gt;</code>! Each slice is potentially repeated <em>eight</em> times! The exceptions are the points on the lines of symmetry themselves, which are each repeated four times, and also <code>&lt;z,w&gt;=&lt;0,0&gt;</code>, which is in its own class.</p>
<p>So, our first breakthrough meant that we only have to simulate <em>positive</em> coordinates (a single quadrant)…our next breakthrough means that we only have to simulate coordinates on a single “wedge” half-quadrant…and then duplicate those eight times at the end.</p>
<p>Arbitrarily, let’s say we only simulate the north-by-northeast wedge, because it’s easy to normalize/compact all points onto that wedge: they’re the points <code>&lt;z,w&gt;</code> where both components are positive and in non-decreasing order. So, <code>&lt;4,-3&gt;</code> gets “normalized” to <code>&lt;3,4&gt;</code>.</p>
<p>Okay, so we found a new symmetry…but we ran into the same issue as before. How do we propagate neighbors? To help us, see what’s going on, let’s look at the map of neighbors between different <code>&lt;z,w&gt;</code> squares, for the single zw wedge we are simulating.</p>
<div id="golSyms4DForward">
<p>Please enable Javascript</p>
</div>
<p>These are the “forward neighbors”; we can compute them by expanding a point to its neighbors, and then normalizing our points and seeing how they double (or quadruple) up.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">def</span> normalize(point):</span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="co">&quot;&quot;&quot;Normalize a point by sorting the absolute values</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">    (2, -1)</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">    =&gt; (1, 2)</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="cf">return</span> <span class="bu">tuple</span>(<span class="bu">sorted</span>([<span class="bu">abs</span>(x) <span class="cf">for</span> x <span class="kw">in</span> point]))</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="kw">def</span> forward_neighbs(point):</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="co">&quot;&quot;&quot;Generate the forward neighbors of a point</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">    (0, 1)</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">    =&gt; {(0, 1): 2, (1, 2): 2, (1, 1): 2, (0, 0): 1, (0, 2): 1}</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>    <span class="cf">return</span> Counter([normalize(neighb) <span class="cf">for</span> neighb <span class="kw">in</span> mk_neighbs(point)])</span></code></pre></div>
<p>For example, mouse over <code>&lt;z,w&gt;=&lt;3,3&gt;</code> and see it has eight total higher-dimensional neighbors (like all points should, though this visualization leaves out points at w&gt;6). It’s <em>supposed</em> to have a neighbor at <code>&lt;4,3&gt;</code>, but that gets reflected back onto <code>&lt;3,4&gt;</code> during our normalization process, so you see that the point <code>&lt;3,3&gt;</code> has a neighbor at <code>&lt;3,4&gt;</code> “double-counted”. The green squares (in the north and west positions) at <code>&lt;3,4&gt;</code> when you hover over <code>&lt;3,3&gt;</code> show that <code>&lt;3,4&gt;</code> is a neighbor of <code>&lt;3,3&gt;</code> both to its north and to its west.</p>
<p>Also, we have something really odd show up for the first time. Mouse over a point like <code>&lt;z,w&gt;=&lt;2,3&gt;</code> and see that it has a neighbor in…itself? What’s going on here? Well, it is <em>supposed</em> to have a neighbor at <code>&lt;3,2&gt;</code> but that gets normalized/reflected back onto <code>&lt;2,3&gt;</code> — it reflects onto itself! The green square in the Southeast means that <code>&lt;2,3&gt;</code>’s southeast neighbor is…itself!</p>
<p>The “forward neighbors” are useful for understanding what’s going on, but to actually run our simulation we again need to find the “reverse neighbors”: from a given point A, how many times is that point a neighbor of another point B?</p>
<p>We can compute this in brute-force using a cache: iterate over each point, expand all its neighbors <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?a_i" alt="a_i" title="a_i" />, normalize that neighbor, and then set <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?a_i" alt="a_i" title="a_i" /> in the cache to the multiplicity after normalization.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">def</span> reverse_neighbs_table(t_max):</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="co">&quot;&quot;&quot;Tabulate the reverse neighbors of all zw slices reachable before t_max</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    weights <span class="op">=</span> {}</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(t_max):</span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, t_max):</span>
<span id="cb4-8"><a href="#cb4-8"></a>            <span class="cf">for</span> neighb, ncount <span class="kw">in</span> forward_neighbs((i, j)).items():</span>
<span id="cb4-9"><a href="#cb4-9"></a>                <span class="cf">if</span> neighb <span class="kw">in</span> weights:</span>
<span id="cb4-10"><a href="#cb4-10"></a>                    weights[neighb][(i, j)] <span class="op">=</span> ncount</span>
<span id="cb4-11"><a href="#cb4-11"></a>                <span class="cf">else</span>:</span>
<span id="cb4-12"><a href="#cb4-12"></a>                    weights[neighb] <span class="op">=</span> {(i, j): ncount}</span>
<span id="cb4-13"><a href="#cb4-13"></a></span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="cf">return</span> weights</span></code></pre></div>
<p>This seems pretty expensive and wasteful, so we’d like to maybe find a formula to be able to do this using mathematical operations. So, let’s explore!</p>
<div id="golSyms4DReverse">
<p>Please enable Javascript</p>
</div>
<p>After exploring this interactively, we can maybe think of some rules we can apply.</p>
<ol type="1">
<li>If we have a point <code>&lt;z,z&gt;</code> directly on the z=w diagonal, just use its five normal left/up neighbors with weight 1 each.</li>
<li>If we have a point <code>&lt;z,z+1&gt;</code> on the “inner-er” diagonal, use its five normal left/up neighbors with weight 1, but its south and west neighbors have weight 2, and the point reflects onto <em>itself</em> with weight 1.</li>
<li>If we’re on <code>z=1</code> and we move into <code>z=0</code>, double that count (phew, the same rule as in the 3D case earlier)</li>
<li>If we’re on w=1 and we move into w=0, double that count (same as before)</li>
<li>And…I guess <code>&lt;0,1&gt;</code> reflects onto itself <em>twice</em>? I guess that technically falls under a combination of rule 2 and rule 4, but we don’t directly observe the motion into w=0 before it gets reflected so it has to be special-cased.</li>
</ol>
<p>Okay, those rules are <em>sliiightly</em> more complicated than our 3D rules (“if we go from z=1 to z=0, double-count it”)…but they’re at least mechanical enough to code in, even if not beautiful. You can probably foresee that it might be tough to generalize, but…we’ll tackle that when we get there :)</p>
<p>For now, we have a super-fast implementation of 4D GoL with our special degeneracy! The runtime gets reduced by a factor of 8!</p>
<p>Now, onward to 5D!</p>
<h2 id="breaking-through">Breaking Through</h2>
<p>By stepping into looking at 5D, we’ve stepped into a brand new territory — we’re now past what the original question was asking about, and into simply exploring a personal curiosity for fun. No longer are we “super-optimizing” the puzzle — we’re now warping the original challenge to levels it was never designed to handle.</p>
<p>It’s difficult to visualize how things look in 5 dimensions, so this is where it gets a little tricky to make any progress, mentally. The first thing we need to figure out is how exactly we can generalize the “z=w” symmetry from 4D to be able to take advantage of it in 5D…and hopefully in a way that can generalize to arbitrary dimensions. Along the way we’d also like to get rid of our hacky 4D neighbor multiplicity rules and get something a little cleaner.</p>
<p>I struggled with for a while without making too much headway…but on the morning of Friday, December 18th, arguably one of the biggest revelations of the entire journey was dropped by Michal Marsalek on u/cetttbycettt’s reddit thread. It was a big deal, because not only did it allow us to generalize our symmetries to higher dimensions, but it also <em>proved</em> a specific degeneracy that allowed 10D simulation to be definitely 100% <em>solvable</em>.</p>
<h3 id="permutation-symmetry">Permutation Symmetry</h3>
<p>Here was Michal’s <a href="https://www.reddit.com/r/adventofcode/comments/kfjhwh/year_2020_day_17_part_2_using_symmetry_in_4d_space/gg9vr6m/">historic post</a>:</p>
<blockquote>
<p>Yes, all the higher dimensions are interchangeable, there’s nothing that distinquishes them. That is, if there’s an active cell at position (x,y, a,b,c,d,e,f,g) then, there’s also one at (x,y, c,d,g,e,f,a) and at all other permutations, of coordinates a-g). That is the number of cells that one need to track can be reduced by factor of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%28d-2%29%21%20%5Ctimes%202%5E%7Bd-2%7D" alt="(d-2)! \times 2^{d-2}" title="(d-2)! \times 2^{d-2}" /> (at least if time goes to infinity).</p>
<p>…we can use symmetries coming from permutations, to only track cells where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%7Cx_0%7C%20%3C%2013%2C%5C%2C%20%7Cx_1%7C%20%3C%2013%2C%5C%2C%200%20%5Cleq%20x_2%20%5Cleq%20x_3%20%5Cleq%5C%2C%5Cldots%5C%2C%20%5Cleq%20x_%7Bd-1%7D%20%5Cleq%20t_max" alt="|x_0| &lt; 13,\, |x_1| &lt; 13,\, 0 \leq x_2 \leq x_3 \leq\,\ldots\, \leq x_{d-1} \leq t_max" title="|x_0| &lt; 13,\, |x_1| &lt; 13,\, 0 \leq x_2 \leq x_3 \leq\,\ldots\, \leq x_{d-1} \leq t_max" />. There’s <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?20%5E2%20%5Ctimes%20%5Csum_%7Bk%3D0%7D%5E%7Bt_max%7D%20%7B%20%7Bd-3%2Bk%7D%20%5Cchoose%20%7Bk%7D%20%7D" alt="20^2 \times \sum_{k=0}^{t_max} { {d-3+k} \choose {k} }" title="20^2 \times \sum_{k=0}^{t_max} { {d-3+k} \choose {k} }" /> such cells.</p>
</blockquote>
<p><em>(equations slightly modified)</em></p>
<p>And boy was this exciting to read. First of all, it gave a way to generalize the z=w symmetry: it’s just permutation symmetry for all higher-dimensional coordinates! But the big kicker here: See that last formula? Let’s look at it more closely, using <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7Bd%7D" alt="\hat{d}" title="\hat{d}" /> to represent <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?d-2" alt="d-2" title="d-2" />, the number of higher dimensions:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A20%5E2%20%5Ctimes%20%5Csum_%7Bk%3D0%7D%5E%7Bt_max%7D%20%7B%20%7B%5Chat%7Bd%7D-1%2Bk%7D%5Cchoose%7Bk%7D%20%7D%0A" alt="
20^2 \times \sum_{k=0}^{t_max} { {\hat{d}-1+k}\choose{k} }
" title="
20^2 \times \sum_{k=0}^{t_max} { {\hat{d}-1+k}\choose{k} }
" /><br /></p>
<p>That sum has only the amount of terms fixed with the maximum timestamp! That means we only ever have 6 terms to expand, no matter how high the dimensions are — at 10D and even 100D! Furthermore, we can simplify the above using properties of the binomial distribution to get</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A20%5E2%20%5Ctimes%20%7B%20%7B%5Chat%7Bd%7D%2B6%7D%5Cchoose%7B6%7D%20%7D%0A" alt="
20^2 \times { {\hat{d}+6}\choose{6} }
" title="
20^2 \times { {\hat{d}+6}\choose{6} }
" /><br /></p>
<p>This binomial coefficient is actually polynomial on <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7Bd%7D" alt="\hat{d}" title="\hat{d}" /> — it’s <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B6%21%7D%20%5Cprod_%7Bk%3D1%7D%5E6%20%28%5Chat%7Bd%7D%2Bk%29" alt="\frac{1}{6!} \prod_{k=1}^6 (\hat{d}+k)" title="\frac{1}{6!} \prod_{k=1}^6 (\hat{d}+k)" /> — a sixth degree polynomial (leading term <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B6%21%7D%20x%5E6" alt="\frac{1}{6!} x^6" title="\frac{1}{6!} x^6" />), in fact. This means that we have turned the number of points we potentially need to track from exponential (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%2813%5E%7B%5Chat%7Bd%7D%7D%29" alt="O(13^{\hat{d}})" title="O(13^{\hat{d}})" />) to slightly smaller exponential with the negative/positive simplification (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%286%5E%7B%5Chat%7Bd%7D%7D%29" alt="O(6^{\hat{d}})" title="O(6^{\hat{d}})" />) to now <em>polynomial</em> <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?O%28%5Chat%7Bd%7D%5E6%29" alt="O(\hat{d}^6)" title="O(\hat{d}^6)" />!</p>
<p>So, not only did we figure out a way to generalize/compute our symmetries, we also now know that this method lets us keep our point set <em>polynomial</em> on the dimension, instead of exponential.</p>
<p>To put a concrete number for context, for that dream of d=10, here are only <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%7B%20%7B8%2B6%7D%20%5Cchoose%206%20%7D" alt="{ {8+6} \choose 6 }" title="{ {8+6} \choose 6 }" />, or 3003 potential unique <code>&lt;z,w,...&gt;</code> points, once you factor out symmetries! The number went down from <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?13%5E8" alt="13^8" title="13^8" /> (815,730,721) potential unique <code>&lt;z,w,...&gt;</code> points to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?6%5E8" alt="6^8" title="6^8" /> (1,679,616) potential unique points with positive/negative symmetry to just 3003 with permutation symmetry.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> Furthermore, because of the blessing of dimensionality mentioned earlier, we can expect more and more of those to be empty as we increase our dimensions.</p>
<p>And in a flash, 10D didn’t feel like a dream anymore. It felt like an inevitability. And now, it was a race to see who could get there first.</p>
<h3 id="reaching-10d">Reaching 10D</h3>
<p>Unfortunately, the exact record of who reached and posted 10D first is a bit lost to history due to reddit’s editing records. A few people maintained and updated their posts to prevent clutter, but the record and time stamp of when they first hit 10D is lost. If any of them happens to read this and can more accurately verify their times, I’d be happy to update!</p>
<p>For me, I’m sure I was not the first one, but in my chat logs I chimed into freenode’s <code>##adventofcode-spoilers</code> channel in excitement in the wee morning hours (PST) Saturday December 19th:</p>
<pre><code>2020-12-19 02:32:42       jle`    d=10 in 9m58s
2020-12-19 02:33:05       jle`    hooray my goal :)
2020-12-19 02:33:08       jle`    time to sleep now
2020-12-19 02:33:12       xerox_  goodnight
2020-12-19 02:33:35       jle`    xerox_: thanks :)</code></pre>
<p>Pure joy! :D</p>
<p><a href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ggaaqsy/">Peter Tseng</a> made a post on Thursday night with times, but I can’t remember if it incorporated all the symmetries or originally included d=10. <a href="https://www.reddit.com/r/adventofcode/comments/kfb6zx/day_17_getting_to_t6_at_for_higher_spoilerss/ggsx9e9/">Michal Marsalek</a> was apparently able to implement the idea that they originally proposed by the following Wednesday (December 23rd) in Nim to blow everyone’s time out of the water: 3.0 seconds!</p>
<p>At that point, it was pretty unbelievable to me that what started out as a dream goal that we couldn’t have completed on a supercomputer had, through successive revelations and insights building on each other one by one, could now be done in 3 seconds.</p>
<p>But hey, I promised 100ms in the introduction, and a fast d=40, right?</p>
<p>With our goal completed, it was now time to dig in a little deeper and see how far this baby could go.</p>
<h3 id="diving-deeper-terminology">Diving Deeper: Terminology</h3>
<p>Before we go any further, let’s take a break to clarify and introduce some terminology we’ll be using for the rest of this post.</p>
<ul>
<li><p>I’ve been using the word <strong>slice</strong> to talk about a 2D grid representing a single higher-dimensional <code>&lt;z,w...&gt;</code> coordinate — they’re the 13 grids in the 3D simulation and the 169 grids in the 4D simulation.</p></li>
<li><p>I’ve also been using <strong>cell</strong> to refer to an exact specific <code>&lt;x,y,z,w,..&gt;</code> spot — they are the tiny squares inside each grid in the simulations above.</p></li>
<li><p>I’ll start using the word <strong><a href="https://www.youtube.com/watch?v=Dp8sYTlLQRY">coset</a></strong> to refer the set of all of the duplicates of an <code>&lt;x,y&gt;</code> across all permutations and negations of <code>&lt;z,w,q,..&gt;</code>, since they all behave the same (they are either all on or all off together). So <code>&lt;x,y,1,2&gt;</code>, <code>&lt;x,y,2,1&gt;</code>, <code>&lt;x,y,-1,2&gt;</code>, <code>&lt;x,y,1,-2&gt;</code>, <code>&lt;x,y,-1,-2&gt;</code>, <code>&lt;x,y,-2,1&gt;</code>, <code>&lt;x,y,2,-1&gt;</code>, and <code>&lt;x,y,-2,-1&gt;</code> are all a part of the same coset, represented by the normalized form <code>&lt;x,y,1,2&gt;</code>. Now, during our simulation, we only need to simulate one member from each coset, because every member is identically present or not present. For the sake of implementation, we simulate the arbitrary <em>normalized</em> (positive and sorted) member only. Because of this, we’ll sometimes refer to the normalized item and the coset it represents as the same thing.</p></li>
<li><p>I’ll also start using <strong>slice coset</strong> to talk about the set of all <code>&lt;z,w,...&gt;</code> slices) across its permutations and negations. The slices at z-w coordinates of <code>&lt;1,2&gt;</code>, <code>&lt;2,1&gt;</code>, <code>&lt;-1,2&gt;</code>, <code>&lt;1,-2&gt;</code>, <code>&lt;-1,-2&gt;</code>, <code>&lt;-2,1&gt;</code>, <code>&lt;2,-1&gt;</code>, and <code>&lt;-2,-1&gt;</code> are all a part of the same coset, represented by the normalized form <code>&lt;1,2&gt;</code>. All of the slices at each of those zw coordinates will always be identical, so we can talk the state of a single slice at <code>&lt;1,2&gt;</code> as representing the state of its entire coset.</p>
<p>Slice cosets are what are being highlighted on mouseovers for the 3D and 4D simulations. They are also what the big squares represent for the forward and backward neighbor demos of each: each slice stands in for their entire slice coset, and we show the amount of times each normalized slice coset element is a neighbor of the other.</p></li>
</ul>
<h2 id="tackling-the-neighbor-problem">Tackling the Neighbor Problem</h2>
<p>My initial d=10 time clocked in at just under 10 minutes initially, but as early as next Wednesady we knew that a sub-5 second time was possible. So where was the gap?</p>
<p>Well, I didn’t really know what to do about the neighbor multiplicity problem. I was still brute-forcing by way of forward neighbors + normalizing (as in the sample 4D python code snippet earlier). The naive brute-force method requires computing <em>all</em> <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?3%5E%7B%20%7B%5Chat%7Bd%7D%7D%20%7D%20-%201" alt="3^{ {\hat{d}} } - 1" title="3^{ {\hat{d}} } - 1" /> higher-dimensional neighbors…so even though the number of points I’d have to track grows polynomially, I still had that pesky exponential factor in building my neighbor map. And at high dimensions, that exponential factor dominates over everything.</p>
<p>So put on your hard hats and working boots … we’re going to dive deep into the world of hyper-dimensional symmetries!</p>
<h3 id="five-dimensions">Five Dimensions</h3>
<p>First, let’s start visualizing how things look like in 5 dimensions, now that we know what our slice coset/representative structure looks like.</p>
<p>It’s a bit difficult to duplicate the same forward/reverse neighbor demos for 4D as we had for 4D, so here’s a different representation. Here is a demo of all of the <code>&lt;z,w,q&gt;</code> slice cosets (the wedge of normalized points we track for our implementation) and both their forward and reverse neighbor weights of each other (computable using the method we used for 4D). The <code>q</code> axis is represented as stacked zw sections from left to right.</p>
<div id="golSyms5D">
<p>Please enable Javascript</p>
</div>
<p>As you mouse-over a slice coset representative (a single square), all of its neighbors will be highlighted, including reflections. The red dot on the left is the “forward” neighbor (how many times that other slice is a neighbor of the hovered slice) and the blue dot on the left is the “reverse” neighbor (how many times the hovered slice is a neighbor of the other slice). For example, if you hover over <code>&lt;z,w,q&gt;=&lt;1,3,4&gt;</code>, you can see that <code>&lt;0,3,4&gt;</code> is its neighbor twice, and <code>&lt;1,3,4&gt;</code> is <code>&lt;0,3,4&gt;</code>’s neighbor four times. These four times come from the non-normalized reflections of <code>&lt;1,3,4&gt;</code> at <code>&lt;1,3,4&gt;</code>, <code>&lt;1,4,3&gt;</code>, <code>&lt;-1,3,4&gt;</code>, and <code>&lt;-1,4,3&gt;</code>. Some squares are also neighbors to themselves (like <code>&lt;1,4,5&gt;</code>) and some are not (like <code>&lt;1,3,5&gt;</code>). <a href="https://www.youtube.com/watch?v=rSfebOXSBOE">Mind bottling</a>!</p>
<p>Anyway, you can explore this a little bit and try to come up with a set of ad-hoc rules like we did for 4D…but I think we’ve reached the limits of how far that method can go. We can generate these values simply enough using the expand-normalize-tabulate method we did for 4D, but there should be a way to compute these weights <em>directly</em>, in a clean fashion that doesn’t require branching special cases and patterns. It’s clear that we are limited until we can find this method.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<h3 id="go-with-the-flow">Go with the Flow</h3>
<div id="golTreeForward">
<p>Please enable Javascript</p>
</div>
<div id="golTreeReverse">
<p>Please enable Javascript</p>
</div>
<h2 id="stacks-on-stacks-visualizting-arbitrary-dimensions">Stacks On Stacks: Visualizting Arbitrary Dimensions</h2>
<div id="golFlat">
<p>Please enable Javascript</p>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For dramatic effect, I’ve omitted the fact that while there are only 3003 possible higher-dimensional points, there are <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?20%5E2%20%5Ctimes%203003" alt="20^2 \times 3003" title="20^2 \times 3003" /> actual unique points possible factoring in the 20x20 x-y grid. Still, it’s a pretty big improvement over the original situation (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?20%5E2%20%5Ctimes%20815730721" alt="20^2 \times 815730721" title="20^2 \times 815730721" />).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Okay, so this is a sliiight deviation from what actually happened. We were actually able to pretty much immediately hit d=10 with the explicit brute-force neighbor tabulation done for 4D. But I’m stretching this out a bit to draw out the narrative :)<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im" class="email">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Advent of Code&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series" title="+Advent of Code"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/advent-of-code.html" class="tag-a-tag">#advent of code</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+advent-of-code.html" class="tag-a-series">+Advent of Code</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/introducing-in-code.html">Introducing &quot;in Code&quot;!</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/degenerate-hyper-dimensional-game-of-life.html';
    this.page.identifier = 'advent-gol';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2020 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/justin_l">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>