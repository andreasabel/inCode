\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{€}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{fancyvrb}
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Justin Le},
            pdftitle={Enhancing Functor Structures Step-By-Step (Part 1)},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
% Make links footnotes instead of hotlinks:
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}
\VerbatimFootnotes % allows verbatim text in footnotes

\title{Enhancing Functor Structures Step-By-Step (Part 1)}
\author{Justin Le}

\begin{document}
\maketitle

\emph{Originally posted on
\textbf{\href{https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html}{in
Code}}.}

A style of Haskell programming that I've been pretty excited about with over the
past year or so is something that I can maybe call a ``functor structure''
designed pattern. This is the interest that culminated in my
\href{https://blog.jle.im/entry/functor-combinatorpedia.html}{Functor
Combinatorpedia} post last year and the
\href{https://hackage.haskell.org/package/functor-combinators}{functor-combinators}
library. In the blog post I called this style the ``functor combinator'' style
because it involved building these functor structures out of small, simple
pieces. This is just one way to build functor structures --- you could always
just make them directly from scratch, but they can get rather messy and it's
often times easier to use pre-made structures that have all the helper functions
already defined for you. But I never really talked about \emph{how} you would
build them from scratch, and also never really explored the more exotic types of
lowercase-f functors in Hask --- contravariant functors and invariant functors.

In this post we're going to be exploring these different types of functor
structures step-by-step, by starting with a simple useful structure and
enhancing it piece by piece. This process reflects a lot of the way I personally
work through these things --- I normally don't get the whole powerful structure
all the way; instead I incrementally add things as I see how things fit
together.

We're going build the tools to describe a \emph{json schema}, in the form of an
algebraic data type -- sums and products. We'll start off just building things
we can use to \emph{describe} the schema (by printing out documentation), and by
the end of the journey we'll also be able to parse and generate values with our
schema.

This series is designed for an intermediate Haskeller with familiarity in things
like monadic parser combinators.

\hypertarget{the-schema}{%
\section{The Schema}\label{the-schema}}

Let's start with the simplest level of describing our schema: a plain ol' AST
describing the possibilities our schema can take.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/doc.hs\#L11{-}L33}

\KeywordTok{data} \DataTypeTok{Schema} \OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  [}\DataTypeTok{Field}\NormalTok{]}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     [}\DataTypeTok{Choice}\NormalTok{]}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}  \DataTypeTok{Primitive}
  \KeywordTok{deriving} \DataTypeTok{Show}

\KeywordTok{data} \DataTypeTok{Field} \OtherTok{=} \DataTypeTok{Field}
\NormalTok{    \{}\OtherTok{ fieldName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ fieldValue ::} \DataTypeTok{Schema}
\NormalTok{    \}}
  \KeywordTok{deriving} \DataTypeTok{Show}

\KeywordTok{data} \DataTypeTok{Choice} \OtherTok{=} \DataTypeTok{Choice}
\NormalTok{    \{}\OtherTok{ choiceName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ choiceValue ::} \DataTypeTok{Schema}
\NormalTok{    \}}
  \KeywordTok{deriving} \DataTypeTok{Show}

\KeywordTok{data} \DataTypeTok{Primitive} \OtherTok{=}
      \DataTypeTok{PString}
    \OperatorTok{|} \DataTypeTok{PNumber}
    \OperatorTok{|} \DataTypeTok{PBool}
  \KeywordTok{deriving} \DataTypeTok{Show}
\end{Highlighting}
\end{Shaded}

Our schema will either represent a record of many different fields, a sum of
many different options, or a primitive value. If it's a sum type, it'll be
described by a list of \texttt{Choice}, which describes each branch. If it's a
record type, it'll be described by a list of \texttt{Field}, which describes
each field. If it's a primitive type, it'll a \texttt{Primitive}, which is
either a string, number, or boolean.

Our end goal is to be able to write a schema for a type like

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/doc.hs\#L35{-}L38}

\KeywordTok{data} \DataTypeTok{Customer} \OtherTok{=}
      \DataTypeTok{CPerson}\NormalTok{   \{}\OtherTok{ cpName ::} \DataTypeTok{String}\NormalTok{,}\OtherTok{ cpAge ::} \DataTypeTok{Int}\NormalTok{ \}}
    \OperatorTok{|} \DataTypeTok{CBusiness}\NormalTok{ \{}\OtherTok{ cbEmployees ::} \DataTypeTok{Int}\NormalTok{ \}}
  \KeywordTok{deriving} \DataTypeTok{Show}
\end{Highlighting}
\end{Shaded}

and be able to represent documenting, parsing, and printing it all within
\texttt{Schema}. For our basic \texttt{Schema} above, this looks like:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/doc.hs\#L40{-}L54}

\OtherTok{customerSchema ::} \DataTypeTok{Schema}
\NormalTok{customerSchema }\OtherTok{=} \DataTypeTok{SumType}
\NormalTok{    [ }\DataTypeTok{Choice}
\NormalTok{        \{ choiceName  }\OtherTok{=} \StringTok{"Person"}
\NormalTok{        , choiceValue }\OtherTok{=} \DataTypeTok{RecordType}
\NormalTok{            [ }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Name"}\NormalTok{, fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf} \DataTypeTok{PString}\NormalTok{ \}}
\NormalTok{            , }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Age"}\NormalTok{ , fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf} \DataTypeTok{PNumber}\NormalTok{ \}}
\NormalTok{            ]}
\NormalTok{        \}}
\NormalTok{    , }\DataTypeTok{Choice}
\NormalTok{        \{ choiceName  }\OtherTok{=} \StringTok{"Business"}
\NormalTok{        , choiceValue }\OtherTok{=} \DataTypeTok{RecordType}
\NormalTok{            [ }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Employees"}\NormalTok{, fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf} \DataTypeTok{PNumber}\NormalTok{ \} ]}
\NormalTok{        \}}
\NormalTok{    ]}
\end{Highlighting}
\end{Shaded}

And a value like

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{PCustomer}\NormalTok{ \{ cpName }\OtherTok{=} \StringTok{"Sam"}\NormalTok{, cpAge }\OtherTok{=} \DecValTok{40}\NormalTok{ \}}
\end{Highlighting}
\end{Shaded}

might be represented by a json value like

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{\{} \DataTypeTok{"tag"}\FunctionTok{:} \StringTok{"Customer"}\FunctionTok{,}
  \DataTypeTok{"contents"}\FunctionTok{:}
    \FunctionTok{\{} \DataTypeTok{"Name"}\FunctionTok{:} \StringTok{"Sam"}
    \FunctionTok{,} \DataTypeTok{"Age"}\FunctionTok{:} \FloatTok{40.0}
    \FunctionTok{\}}
\FunctionTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{documentation}{%
\section{Documentation}\label{documentation}}

Using our schema type, let's make a documentation generator. It'll take a
\texttt{Schema} and nicely formatted documentation describing what the schema
itself.

To make our lives easier, we'll be using the
\emph{\href{https://hackage.haskell.org/package/prettyprinter}{prettyprinter}}
library, which will handle indentation, horizontal and vertical concatenation,
and other printing concerns for us.

Let's build things up by defining documentation generators for our individual
types, so they'll be easier to assemble.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/doc.hs\#L56{-}L81}

\NormalTok{schemaDoc}
\OtherTok{    ::} \DataTypeTok{String}       \CommentTok{{-}{-} \^{} name}
    \OtherTok{{-}>} \DataTypeTok{Schema}       \CommentTok{{-}{-} \^{} schema}
    \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}

\OtherTok{fieldDoc ::} \DataTypeTok{Field} \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}

\OtherTok{choiceDoc ::} \DataTypeTok{Choice} \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}

\OtherTok{primDoc ::} \DataTypeTok{Primitive} \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

So \texttt{schemaDoc} will take the name of our type and a schema, and generate
a \texttt{PP.Doc\ x}, the type of a text document in the \emph{prettyprinter}
library.\footnote{I'm using \texttt{x} as the name of the type variable (instead
  of something more traditional like \texttt{a}) to indicate that it isn't meant
  to be referenced or used anywhere in any consistent way. Just remember it
  doesn't mean anything special syntactically!} And \texttt{fieldDoc},
\texttt{choiceDoc}, and \texttt{primDoc} just generate the documentation for
each individual field or constructor.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/doc.hs\#L75{-}L85}

\OtherTok{fieldDoc ::} \DataTypeTok{Field} \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}
\NormalTok{fieldDoc }\DataTypeTok{Field}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ schemaDoc fieldName fieldValue}

\OtherTok{choiceDoc ::} \DataTypeTok{Choice} \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}
\NormalTok{choiceDoc }\DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ schemaDoc choiceName choiceValue}

\OtherTok{primDoc ::} \DataTypeTok{Primitive} \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}
\NormalTok{primDoc }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{PString} \OtherTok{{-}>} \StringTok{"string"}
  \DataTypeTok{PNumber} \OtherTok{{-}>} \StringTok{"number"}
  \DataTypeTok{PBool}   \OtherTok{{-}>} \StringTok{"bool"}
\end{Highlighting}
\end{Shaded}

Nothing too fancy here --- since \texttt{Field} and \texttt{Choice} just have a
name and a sub-schema, we can have them call \texttt{schemaDoc}.
\texttt{primDoc} requires making our leaf documentation, so we can just print
what type they have.

We tie it all together with \texttt{schemaDoc}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/doc.hs\#L56{-}L73}

\NormalTok{schemaDoc}
\OtherTok{    ::} \DataTypeTok{String}       \CommentTok{{-}{-} \^{} name}
    \OtherTok{{-}>} \DataTypeTok{Schema}       \CommentTok{{-}{-} \^{} schema}
    \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ x}
\NormalTok{schemaDoc title }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}>}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"\{"} \OperatorTok{<>}\NormalTok{ title }\OperatorTok{<>} \StringTok{"\}"}\NormalTok{)}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
          \FunctionTok{map}\NormalTok{ (\textbackslash{}fld }\OtherTok{{-}>} \StringTok{"*"} \OperatorTok{PP.<+>}\NormalTok{ PP.indent }\DecValTok{2}\NormalTok{ (fieldDoc fld)) fs}
\NormalTok{      ]}
    \DataTypeTok{SumType}\NormalTok{ cs    }\OtherTok{{-}>}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"("} \OperatorTok{<>}\NormalTok{ title }\OperatorTok{<>} \StringTok{")"}\NormalTok{)}
\NormalTok{      , }\StringTok{"Choice of:"}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
          \FunctionTok{map}\NormalTok{ choiceDoc cs}
\NormalTok{      ]}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}>}\NormalTok{ PP.pretty (title }\OperatorTok{<>} \StringTok{":"}\NormalTok{)}
              \OperatorTok{PP.<+>}\NormalTok{ primDoc p}
\end{Highlighting}
\end{Shaded}

Here we use \texttt{PP.vsep}, which takes a list of docs and concatenates them
vertically, \texttt{PP.\textless{}+\textgreater{}} which concatenates two docs
horizontally, and \texttt{PP.indent} which indents things before going down a
level. We appropriately call \texttt{fieldDoc}, \texttt{choiceDoc}, and
\texttt{primDoc} when we actually need to print one of them.

Hopefully that wasn't too bad! There were a lot of moving parts because we have
a recursive data type, but in the end hopefully each specific branch was
self-contained enough to understand on their own. In the end the important thing
to take away isn't the mechanics of document generation, but rather how the data
flows. Make sure you at least understand how the functions call each other, and
how --- this pattern is going to be very consistent across all the schema
processors we write!

We can test out our function on \texttt{customerSchema}, taking advantage of the
fact that \texttt{PP.Doc}'s \texttt{Show} instance will render the document:

\begin{verbatim}
ghci> schemaDoc "Customer" customerSchema
(Customer)
Choice of:
  {Person}
    *   Name: string
    *   Age: number
  {Business}
    *   Employees: number
\end{verbatim}

It works!

\hypertarget{parsing-with-covariance}{%
\section{Parsing with Covariance}\label{parsing-with-covariance}}

Now, let's talk about using our \texttt{Schema} type to define a json parser.
We're going to rewrite \texttt{Schema} to take a type parameter to represent the
type we want to parse into. A \texttt{Schema\ a} will be a schema that can be
used to generate documentation \emph{and} describe a parser of \texttt{a}s. In
the end, we want \texttt{customerSchema\ ::\ Schema\ Customer}, and a function
like

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{schemaParser ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{Parse} \DataTypeTok{ErrType}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

to generate a json parser of \texttt{a}s. We'll be using the json parser type
\texttt{Parse\ err\ a} from
\emph{\href{https://hackage.haskell.org/package/aeson-better-errors}{aeson-better-errors}}
(not because of the better errors, but just because it's closer to an actual
incremental/stateful parser than other alternatives out there), which can be run
with
\texttt{parse\ ::\ Parse\ err\ a\ -\textgreater{}\ ByteString\ -\textgreater{}\ Either\ (ParseError\ err)\ a}.
So our final interface will look like:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L157{-}L158}

\OtherTok{parseSchema ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{ByteString} \OtherTok{{-}>} \DataTypeTok{Either}\NormalTok{ (}\DataTypeTok{A.ParseError} \DataTypeTok{ErrType}\NormalTok{) a}
\NormalTok{parseSchema sc }\OtherTok{=}\NormalTok{ A.parse (schemaParser sc)}
\end{Highlighting}
\end{Shaded}

To do this, we now have to include information on ``how to parse an \texttt{a}''
in our schema. Remember that our actual json format is pretty fixed/structured,
so all our \texttt{Schema} has to express are variations within that structure.
The only variation that our \texttt{Schema} can express are how sums/products
are structured, and also how to parse primitive types. And so, the main thing we
need to modify is just \texttt{Primitive}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L46{-}L50}

\KeywordTok{data} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{PString}\NormalTok{ (}\DataTypeTok{String} \OtherTok{{-}>} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PNumber}\NormalTok{ (}\DataTypeTok{Scientific} \OtherTok{{-}>} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PBool}\NormalTok{   (}\DataTypeTok{Bool} \OtherTok{{-}>} \DataTypeTok{Maybe}\NormalTok{ a)}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\end{Highlighting}
\end{Shaded}

A \texttt{Primitive\ a} will be a way to parse a json primitive --- it can be
\texttt{PString}, \texttt{PNumber}, or \texttt{PBool}. To create a ``String
Parser'', you need to use \texttt{PString} with a function on ``what to do with
the string you get''. To create a ``Bool parser'', you need \texttt{PBool} with
a function on what to do with the bool you get.

We can write some helper primitives:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L52{-}L59}

\OtherTok{pString ::} \DataTypeTok{Primitive} \DataTypeTok{String}
\NormalTok{pString }\OtherTok{=} \DataTypeTok{PString} \DataTypeTok{Just}

\OtherTok{pInt ::} \DataTypeTok{Primitive} \DataTypeTok{Int}
\NormalTok{pInt }\OtherTok{=} \DataTypeTok{PNumber}\NormalTok{ toBoundedInteger}

\OtherTok{pBool ::} \DataTypeTok{Primitive} \DataTypeTok{Bool}
\NormalTok{pBool }\OtherTok{=} \DataTypeTok{PBool} \DataTypeTok{Just}
\end{Highlighting}
\end{Shaded}

\texttt{pString\ ::\ Primitive\ String} is the most basic way to parse a
primitive json string: just return the \texttt{String} itself. \texttt{pInt}
needs to reject any non-integer numbers, so
\texttt{toBoundedInteger\ ::\ Scientific\ -\textgreater{}\ Maybe\ Int} works
well.

\hypertarget{deducing-ap}{%
\subsection{Deducing Ap}\label{deducing-ap}}

However, this small change (and adding the type parameter) leaves in a
predicament. What should \texttt{Schema} look like?

At first glance, we might think we could just write

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  [}\DataTypeTok{Field}\NormalTok{ a]}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     [}\DataTypeTok{Choice}\NormalTok{ a]}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L34{-}L40}

\KeywordTok{data} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Field}

\KeywordTok{data} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Choice}
\end{Highlighting}
\end{Shaded}

But there's a problem here: \texttt{RecordType} is a combination of
\texttt{Field}s, but\ldots each \texttt{Field} is of a different type! For
example, in our \texttt{Customer} example, the \texttt{Person} branch has two
fields: \texttt{Name} and \texttt{Age}. Our name schema would look like
\texttt{nameField\ ::\ Field\ String}, and our age schema would look like
\texttt{ageField\ ::\ Field\ Int}\ldots and so you can't really put that into a
list like \texttt{{[}Field\ a{]}} since they each have different types. And
further more, we want a final \texttt{Customer} (in our
\texttt{Schema\ Customer}), a type which is different from both \texttt{String}
and \texttt{Int}.

What we need is a way to express heterogeneous collection/sequence of
\texttt{Field\ a}, coupled with a way of ``combining'' all of them to create an
aggregate value of a final type. A type that says ``use a bunch of
\texttt{Field} of \texttt{x}s of different types to generate a final
\texttt{a}''.

There are a couple of ways to arrive at this mystery type. One way is to
recognize ``combine a bunch of \texttt{f\ x}s of different types to create an
\texttt{f\ b}'' is essentially the MO of the \emph{Applicative} abstraction, and
so essentially we want to give \texttt{Field} some sort of \texttt{Applicative}
structure. And so we can reach for ``the type that gives something an
\texttt{Applicative} structure'', the
\href{https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html}{free
applicative}.

Another way is to think about it as an enhancement along a functor combinator
described in the
\href{https://blog.jle.im/entry/functor-combinatorpedia.html}{functor
combinatorpedia}. Here we know we want to enhance \texttt{Field} in a specific
way, so we can scan the list of functor combinators until there is one that we
need. And scrolling down, we see:

\begin{quote}
\href{https://blog.jle.im/entry/functor-combinatorpedia.html\#ap-ap1}{\textbf{Ap
/ Ap1 }}

\textbf{Origin}:
\emph{\href{https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html}{Control.Applicative.Free}}
/
\emph{\href{https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html}{Data.Functor.Apply.Free}}

\textbf{Enhancement}: The ability to provide multiple \texttt{f}s that the
interpreter \emph{must} consume \emph{all} of. (\ldots)

While \texttt{ListF} may be considered ``multiple options \emph{offered}'',
\texttt{Ap} can be considered ``multiple actions all \emph{required}''. The
interpreter must consume/interpret \emph{all} of the multiple \texttt{f}s in
order to interpret an \texttt{Ap}.

Note that ordering is not enforced: while the consumer must handle each
\texttt{f} eventually, they are free to handle it in whatever order they desire.
In fact, they could even all be handled in parallel. See \texttt{Free} for a
version where ordering is enforced.

\ldots{}

Because this has an \texttt{Applicative} instance, you can use
\texttt{(\textless{}*\textgreater{})\ ::\ Ap\ f\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ Ap\ f\ a\ -\textgreater{}\ Ap\ f\ b}
to sequence multiple \texttt{Ap\ f}s together, and
\texttt{pure\ ::\ a\ -\textgreater{}\ Ap\ f\ a} to produce a ``no-op''
\texttt{Ap} without any \texttt{f}s.
\end{quote}

That sounds like it matches to me! In order to parse a \texttt{RecordType}, we
need to parse \emph{every} \texttt{Field}. It doesn't make any sense to skip one
field or the other: they all need to be processed and parsed. This sounds like
just the thing we need.

The description here also gives a clue for what we might want to use for
\texttt{SumType} (\texttt{ListF} sounds like a good companion for the behavior
we want sum type parsers to have)

Another way to come to this conclusion is to think about it in terms of
tensoring functors: ``how do we want to tensor together \emph{two}
\texttt{Field}s''?

Well, earlier we said that we want to combine fields of different types, while
also providing a way of combining the two types together to create a final
aggregate type. We can express this in Haskell with something like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{TwoFields} \OtherTok{=} \KeywordTok{forall}\NormalTok{ x y}\OperatorTok{.} \DataTypeTok{TwoFields}\NormalTok{ (}\DataTypeTok{Field}\NormalTok{ x) (}\DataTypeTok{Field}\NormalTok{ y) (x }\OtherTok{{-}>}\NormalTok{ y }\OtherTok{{-}>}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

In existential syntax, this says that \texttt{TwoFields\ a} consists of
\texttt{Field\ x} and \texttt{Field\ y} of a ``hidden'' \texttt{x} and
\texttt{y}, as well as a function to combine the \texttt{x} and \texttt{y} to
make an \texttt{a}.

We can look up what type of tensor this is in the functor combinatorpedia.
Scrolling down, we see:

\begin{quote}
\href{https://blog.jle.im/entry/functor-combinatorpedia.html\#day}{\textbf{Day}}

\textbf{Origin}:
\emph{\href{https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Day.html}{Data.Functor.Day}}

\textbf{Mixing Strategy}: ``Both, together forever'': provide values from
\emph{both} functors, and the user \emph{must} also \emph{use} both.

\ldots{}

Unlike for \texttt{:*:}, you always have to interpret \emph{both} functor values
in order to interpret a \texttt{Day}. It's a ``full mixing''.

The mechanism for this is interesting in and of itself. Looking at the
definition of the data type:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Day}\NormalTok{ f g a }\OtherTok{=} \KeywordTok{forall}\NormalTok{ x y}\OperatorTok{.} \DataTypeTok{Day}\NormalTok{ (f x) (g y) (x }\OtherTok{{-}>}\NormalTok{ y }\OtherTok{{-}>}\NormalTok{ a)}
\end{Highlighting}
\end{Shaded}

We see that because \texttt{x} and \texttt{y} are ``hidden'' from the external
world, we can't directly use them without applying the ``joining'' function
\texttt{x\ -\textgreater{}\ y\ -\textgreater{}\ a}. Due to how existential types
work, we can't get anything out of it that ``contains'' \texttt{x} or
\texttt{y}. Because of this, \emph{using} the joining function requires
\emph{both} \texttt{f\ x} and \texttt{g\ y}. If we only use \texttt{f\ x}, we
can only get, at best,\texttt{f\ (y\ -\textgreater{}\ a)}; if we only use
\texttt{g\ y}, we can only get, at best, \texttt{g\ (x\ -\textgreater{}\ a)}. In
order to fully eliminate \emph{both} existential variables, we need to get the
\texttt{x} and \texttt{y} from \emph{both} \texttt{f\ x} and \texttt{g\ y}, as
if the two values held separate halves of the key.
\end{quote}

It seems as if our \texttt{TwoFields} is exactly \texttt{Day\ Field\ Field}, so
we're on the right track.

Reading further on in the \texttt{Day} section, we see:

\begin{quote}
\textbf{List type}

\ldots{} \texttt{Ap\ f\ a} is a bunch of \texttt{f\ x}s \texttt{Day}d with each
other.
\end{quote}

All three different ways you might have arrived at the conclusion of using
\texttt{Ap}!

\hypertarget{building-ap}{%
\subsection{Building Ap}\label{building-ap}}

With this, we can write our final \texttt{Schema} type.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L28{-}L50}

\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  (}\DataTypeTok{Ap} \DataTypeTok{Field}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     (}\DataTypeTok{ListF} \DataTypeTok{Choice}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}
  \KeywordTok{deriving} \DataTypeTok{Functor}

\KeywordTok{data} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Field}
\NormalTok{    \{}\OtherTok{ fieldName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ fieldValue ::} \DataTypeTok{Schema}\NormalTok{ a}
\NormalTok{    \}}
  \KeywordTok{deriving} \DataTypeTok{Functor}

\KeywordTok{data} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Choice}
\NormalTok{    \{}\OtherTok{ choiceName  ::} \DataTypeTok{String}
\NormalTok{    ,}\OtherTok{ choiceValue ::} \DataTypeTok{Schema}\NormalTok{ a}
\NormalTok{    \}}
  \KeywordTok{deriving} \DataTypeTok{Functor}

\KeywordTok{data} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{PString}\NormalTok{ (}\DataTypeTok{String} \OtherTok{{-}>} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PNumber}\NormalTok{ (}\DataTypeTok{Scientific} \OtherTok{{-}>} \DataTypeTok{Maybe}\NormalTok{ a)}
    \OperatorTok{|} \DataTypeTok{PBool}\NormalTok{   (}\DataTypeTok{Bool} \OtherTok{{-}>} \DataTypeTok{Maybe}\NormalTok{ a)}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\end{Highlighting}
\end{Shaded}

Note that I switched from \texttt{{[}Choice\ a{]}} to \texttt{ListF\ Choice\ a}
--- the two are the same, but the latter has the Functor instance we want
(\texttt{fmap\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ ListF\ Choice\ a\ -\textgreater{}\ ListF\ Choice\ b}),
and is an instance of useful functor combinator typeclasses. Furthermore, it
illustrates the symmetry between sum types, since \texttt{Ap} and \texttt{ListF}
are contrasting types: \texttt{Ap} represents a product between many required
fields, and \texttt{ListF} represents a sum between many possible choices. It's
more clear how product types and list types are ``opposites'' in a nice clean
way.

We can now make our \texttt{Customer} schema:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L66{-}L80}

\OtherTok{customerSchema ::} \DataTypeTok{Schema} \DataTypeTok{Customer}
\NormalTok{customerSchema }\OtherTok{=} \DataTypeTok{SumType} \OperatorTok{$}
\NormalTok{      inject }\DataTypeTok{Choice}
\NormalTok{        \{ choiceName  }\OtherTok{=} \StringTok{"Person"}
\NormalTok{        , choiceValue }\OtherTok{=} \DataTypeTok{RecordType} \OperatorTok{$}
            \DataTypeTok{CPerson}
              \OperatorTok{<$>}\NormalTok{ inject }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Name"}\NormalTok{, fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pString \}}
              \OperatorTok{<*>}\NormalTok{ inject }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Age"}\NormalTok{ , fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pInt    \}}
\NormalTok{        \}}
  \OperatorTok{<!>}\NormalTok{ inject }\DataTypeTok{Choice}
\NormalTok{        \{ choiceName  }\OtherTok{=} \StringTok{"Business"}
\NormalTok{        , choiceValue }\OtherTok{=} \DataTypeTok{RecordType} \OperatorTok{$}
            \DataTypeTok{CBusiness}
              \OperatorTok{<$>}\NormalTok{ inject }\DataTypeTok{Field}\NormalTok{ \{ fieldName }\OtherTok{=} \StringTok{"Employees"}\NormalTok{, fieldValue }\OtherTok{=} \DataTypeTok{SchemaLeaf}\NormalTok{ pInt \}}
\NormalTok{        \}}
\end{Highlighting}
\end{Shaded}

The main new thing is using
\texttt{inject\ ::\ Choice\ a\ -\textgreater{}\ ListF\ Choice\ a} and
\texttt{inject\ ::\ Field\ a\ -\textgreater{}\ Ap\ Field\ a} to lift our base
types into their appropriate combinators. Then after that, we just use
\texttt{Ap}'s \texttt{Applicative} instance and \texttt{ListF}'s \texttt{Plus}
instance to combine them together. Overall it should look very similar to the
schema we wrote for the documentation section.

\hypertarget{interpreting-ap}{%
\subsection{Interpreting Ap}\label{interpreting-ap}}

Now, the typical way to ``run'' an applied functor combinator is with
interpreting functions, like:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{interpret ::} \DataTypeTok{Applicative}\NormalTok{ g }\OtherTok{=>}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}>}\NormalTok{ g x) }\OtherTok{=>} \DataTypeTok{Ap}\NormalTok{ f a    }\OtherTok{{-}>}\NormalTok{ g a}
\OtherTok{interpret ::} \DataTypeTok{Plus}\NormalTok{ g        }\OtherTok{=>}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}>}\NormalTok{ g x) }\OtherTok{=>} \DataTypeTok{ListF}\NormalTok{ f a }\OtherTok{{-}>}\NormalTok{ g a}
\end{Highlighting}
\end{Shaded}

You can interpret an \texttt{Ap\ f\ a} into any \texttt{Applicative\ g}, and you
can interpret a \texttt{ListF\ f\ a} into any \texttt{Plus\ g} (\texttt{Plus} is
basically \texttt{Alternative} without an \texttt{Applicative} requirement).
Basically, you write a function to interpret any \texttt{f} you find, and
\texttt{interpret} will accumulate them all together for you.

In our case, if we decided to use \texttt{interpret}, we could write:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{interpret ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.} \DataTypeTok{Field}\NormalTok{  x }\OtherTok{{-}>} \DataTypeTok{Parse} \DataTypeTok{ErrType}\NormalTok{ x) }\OtherTok{{-}>} \DataTypeTok{Ap}    \DataTypeTok{Field}\NormalTok{  a }\OtherTok{{-}>} \DataTypeTok{Parse} \DataTypeTok{ErrType}\NormalTok{ x}
\OtherTok{interpret ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.} \DataTypeTok{Choice}\NormalTok{ x }\OtherTok{{-}>} \DataTypeTok{Parse} \DataTypeTok{ErrType}\NormalTok{ x) }\OtherTok{{-}>} \DataTypeTok{ListF} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{Parse} \DataTypeTok{ErrType}\NormalTok{ x}
\end{Highlighting}
\end{Shaded}

Basically, if we have a way to parse each \texttt{Field}, then we have a way to
parse an \texttt{Ap\ Field\ a}. If we have a way to parse each \texttt{Choice},
then we have a way to parse a \texttt{ListF\ Choice\ a}.

Let's write those individual parsers for each smaller type:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L124{-}L125}

\OtherTok{fieldParser ::} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{fieldParser }\DataTypeTok{Field}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ A.key (T.pack fieldName) (schemaParser fieldValue)}
\end{Highlighting}
\end{Shaded}

Here we use \emph{aeson-better-errors}'s
\texttt{key\ ::\ Text\ -\textgreater{}\ Parser\ a\ -\textgreater{}\ Parser\ a},
which takes a key and a parser, and runs that parser on whatever is under that
key. For \texttt{fieldParser}, we run the schema parser for our sub-schema under
that key.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L127{-}L132}

\OtherTok{choiceParser ::} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{choiceParser }\DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=} \KeywordTok{do}
\NormalTok{  tag }\OtherTok{<{-}}\NormalTok{ A.key }\StringTok{"tag"}\NormalTok{ A.asString}
\NormalTok{  unless (tag }\OperatorTok{==}\NormalTok{ choiceName) }\OperatorTok{$}
\NormalTok{    A.throwCustomError }\StringTok{"Tag does not match"}
\NormalTok{  A.key }\StringTok{"contents"} \OperatorTok{$}\NormalTok{ schemaParser choiceValue}
\end{Highlighting}
\end{Shaded}

Our sum type encoding is a bit more involved, because json doesn't have any
native sum type construct. So we're going to parse whatever is in the key
\texttt{"tag"}, and if that tag matches our current choice's constructor, we
parse the schema parser for our sub-schema under that key. Otherwise, this
choice isn't what is currently in our json value.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L134{-}L141}

\OtherTok{primParser ::} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{A.Parse} \DataTypeTok{String}\NormalTok{ a}
\NormalTok{primParser }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
  \DataTypeTok{PString}\NormalTok{ f }\OtherTok{{-}>}\NormalTok{ A.withString }\OperatorTok{$}
    \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating string"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
  \DataTypeTok{PNumber}\NormalTok{ f }\OtherTok{{-}>}\NormalTok{ A.withScientific }\OperatorTok{$}
    \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating number"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
  \DataTypeTok{PBool}\NormalTok{ f }\OtherTok{{-}>}\NormalTok{ A.withBool }\OperatorTok{$}
    \FunctionTok{maybe}\NormalTok{ (}\DataTypeTok{Left} \StringTok{"error validating bool"}\NormalTok{) }\DataTypeTok{Right} \OperatorTok{.}\NormalTok{ f}
\end{Highlighting}
\end{Shaded}

Our primitive parser is just going to use \emph{aeson-better-error}'s primitive
value parsers with the function in them --- nothing too fancy, just some
plumbing.

Finally, to wrap bring it all together, we use the \texttt{interpret} functions
we talked about:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L118{-}L122}

\OtherTok{schemaParser ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{A.Parse} \DataTypeTok{ErrType}\NormalTok{ a}
\NormalTok{schemaParser }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}>}\NormalTok{ interpret fieldParser fs}
    \DataTypeTok{SumType}\NormalTok{    cs }\OtherTok{{-}>}\NormalTok{ interpret choiceParser cs}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}>}\NormalTok{ primParser p}
\end{Highlighting}
\end{Shaded}

And that's it!

Ah well, not exactly so fast. Even though they could support it,
\emph{aeson-better-errors} doesn't provide \texttt{Plus} a for \texttt{Parse}.
We can write them as orphans here just because this is a fun learning experience
(but we usually do like to avoid defining instances for types or typeclasses
that aren't ours).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L111{-}L114}

\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=>} \DataTypeTok{Alt}\NormalTok{ (}\DataTypeTok{A.ParseT}\NormalTok{ e f) }\KeywordTok{where}
\NormalTok{    (}\OperatorTok{<!>}\NormalTok{) }\OtherTok{=}\NormalTok{ (}\OperatorTok{A.<|>}\NormalTok{)}
\KeywordTok{instance} \DataTypeTok{Monad}\NormalTok{ f }\OtherTok{=>} \DataTypeTok{Plus}\NormalTok{ (}\DataTypeTok{A.ParseT} \DataTypeTok{String}\NormalTok{ f) }\KeywordTok{where}
\NormalTok{    zero  }\OtherTok{=}\NormalTok{ A.throwCustomError }\StringTok{"No options were validated"}
\end{Highlighting}
\end{Shaded}

And\ldots that should work!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{>} \OperatorTok{:}\NormalTok{set }\OperatorTok{{-}}\DataTypeTok{XOverloadedStrings}
\NormalTok{ghci}\OperatorTok{>}\NormalTok{ parseSchema customerSchema  }\StringTok{"\{ \textbackslash{}"tag\textbackslash{}": \textbackslash{}"Person\textbackslash{}", \textbackslash{}"contents\textbackslash{}": \{ \textbackslash{}"Name\textbackslash{}": \textbackslash{}"Same\textbackslash{}", \textbackslash{}"Age\textbackslash{}": 40 \} \}"}
\DataTypeTok{Right}\NormalTok{ (}\DataTypeTok{CPerson}\NormalTok{ \{cpName }\OtherTok{=} \StringTok{"Same"}\NormalTok{, cpAge }\OtherTok{=} \DecValTok{30}\NormalTok{\})}
\NormalTok{ghci}\OperatorTok{>}\NormalTok{ parseSchema customerSchema  }\StringTok{"\{ \textbackslash{}"tag\textbackslash{}": \textbackslash{}"Business\textbackslash{}", \textbackslash{}"contents\textbackslash{}": \{ \textbackslash{}"Employees\textbackslash{}": 3 \} \}"}
\DataTypeTok{Right}\NormalTok{ (}\DataTypeTok{CBusiness}\NormalTok{ \{cbEmployees }\OtherTok{=} \DecValTok{3}\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

We were able to generate a fully functional parser from our schema, by only
providing parsers for the smaller, more specific types we had (\texttt{Field}
and \texttt{Choice}), and having them all fit together in a way directed by
their \texttt{Apply} and \texttt{Alt} typeclass instances.

\hypertarget{direct-structural-inspection}{%
\subsection{Direct Structural Inspection}\label{direct-structural-inspection}}

However, sometimes the typeclass instances aren't really the best way to handle
things. It gives us a nice principled shortcut --- for example, to interpret out
of an \texttt{Ap}, GHC needs a way to know ``how to sequence \texttt{Parse}s'',
and so \texttt{interpret} uses the \texttt{Applicative} instance for that. But
we know there are usually different ways to sequence or combine actions ---
famously in IO, we have the option to sequence IO actions in series or in
parallel. So, offloading our logic to a typeclass can be a convenient route, but
it's not necessarily the most pragmatic way.

In our case, the \texttt{Plus} instance actually combines failed fallback
behavior in an undesirable way: our errors become not too useful, because
\texttt{\textless{}!\textgreater{}} always picks the right side's errors, and we
eventually run into \texttt{A.throwCustomError\ "No\ options\ were\ validated"}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ghci}\OperatorTok{>}\NormalTok{ parseSchema customerSchema  }\StringTok{"\{ \textbackslash{}"tag\textbackslash{}": \textbackslash{}"Business\textbackslash{}", \textbackslash{}"contents\textbackslash{}": \{ \textbackslash{}"Employees\textbackslash{}": \textbackslash{}"Mustard\textbackslash{}" \} \}"}
\DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{BadSchema}\NormalTok{ [] (}\DataTypeTok{CustomError} \StringTok{"No options were validated"}\NormalTok{))}
\NormalTok{ghci}\OperatorTok{>}\NormalTok{ parseSchema customerSchema  }\StringTok{"\{ \textbackslash{}"tag\textbackslash{}": \textbackslash{}"Grape\textbackslash{}", \textbackslash{}"contents\textbackslash{}": \{ \textbackslash{}"Color\textbackslash{}": \textbackslash{}"purple\textbackslash{}" \} \}"}
\DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{BadSchema}\NormalTok{ [] (}\DataTypeTok{CustomError} \StringTok{"No options were validated"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Since \texttt{Plus}'s \texttt{zero} definition always falls back to the same
error, this is not very useful!

So \texttt{interpret} for \texttt{ListF}, while convenient, isn't necessarily
the best way to tear down a \texttt{ListF}. Luckily, most functor combinators
are just ADTs that we can pattern match and break down and access the structures
manually. In the case of \texttt{ListF}, the structure is pretty simple:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{ListF}\NormalTok{ f a }\OtherTok{=} \DataTypeTok{ListF}\NormalTok{ \{}\OtherTok{ runListF ::}\NormalTok{ [f a] \}}
\end{Highlighting}
\end{Shaded}

Our \texttt{ListF\ Choice\ a} is just \texttt{{[}Choice\ a{]}}. This is
something we can work with! Let's write a better \texttt{ListF\ Choice\ a}
processor by working with the list itself.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L143{-}L155}

\OtherTok{schemaParser2 ::} \KeywordTok{forall}\NormalTok{ a}\OperatorTok{.} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{A.Parse} \DataTypeTok{ErrType}\NormalTok{ a}
\NormalTok{schemaParser2 }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}>}\NormalTok{ interpret fieldParser fs}
    \DataTypeTok{SumType}\NormalTok{    cs }\OtherTok{{-}>} \KeywordTok{do}
      \KeywordTok{let}\OtherTok{ schemaMap ::} \DataTypeTok{M.Map} \DataTypeTok{String}\NormalTok{ (}\DataTypeTok{Schema}\NormalTok{ a)}
\NormalTok{          schemaMap }\OtherTok{=}\NormalTok{ M.fromList [ (choiceName, choiceValue) }\OperatorTok{|} \DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{<{-}}\NormalTok{ runListF cs ]}
\NormalTok{      tag }\OtherTok{<{-}}\NormalTok{ A.key }\StringTok{"tag"}\NormalTok{ A.asString}
      \KeywordTok{case}\NormalTok{ M.lookup tag schemaMap }\KeywordTok{of}
        \DataTypeTok{Nothing} \OtherTok{{-}>}\NormalTok{ A.throwCustomError }\OperatorTok{$}
                \StringTok{"tag "} \OperatorTok{<>}\NormalTok{ tag }\OperatorTok{<>} \StringTok{" not recognized: Expected one of "}
             \OperatorTok{<>}\NormalTok{ intercalate }\StringTok{", "}\NormalTok{ (M.keys schemaMap)}
        \DataTypeTok{Just}\NormalTok{ sc }\OtherTok{{-}>}\NormalTok{ A.key }\StringTok{"contents"}\NormalTok{ (schemaParser2 sc)}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}>}\NormalTok{ primParser p}
\end{Highlighting}
\end{Shaded}

We can use the structure of \texttt{ListF} to generate a \texttt{Map}
associating any tags with the schemas they are meant to encode. We then parse
the tag, look up what schema it represents (if any) and then use that schema
under the contents key.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{λ}\OperatorTok{:}\NormalTok{ parseSchema2 customerSchema  }\StringTok{"\{ \textbackslash{}"tag\textbackslash{}": \textbackslash{}"Business\textbackslash{}", \textbackslash{}"contents\textbackslash{}": \{ \textbackslash{}"Employees\textbackslash{}": \textbackslash{}"Mustard\textbackslash{}" \} \}"}
\DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{BadSchema}\NormalTok{ [}\DataTypeTok{ObjectKey} \StringTok{"contents"}\NormalTok{,}\DataTypeTok{ObjectKey} \StringTok{"Employees"}\NormalTok{] (}\DataTypeTok{WrongType} \DataTypeTok{TyNumber}\NormalTok{ (}\DataTypeTok{String} \StringTok{"Mustard"}\NormalTok{)))}
\NormalTok{λ}\OperatorTok{:}\NormalTok{ parseSchema2 customerSchema  }\StringTok{"\{ \textbackslash{}"tag\textbackslash{}": \textbackslash{}"Grape\textbackslash{}", \textbackslash{}"contents\textbackslash{}": \{ \textbackslash{}"Color\textbackslash{}": \textbackslash{}"purple\textbackslash{}" \} \}"}
\DataTypeTok{Left}\NormalTok{ (}\DataTypeTok{BadSchema}\NormalTok{ [] (}\DataTypeTok{CustomError} \StringTok{"tag Grape not recognized: Expected one of Business, Person"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Much better messages!

\hypertarget{backporting-documentation}{%
\subsection{Backporting documentation}\label{backporting-documentation}}

Remember that the whole point of this exercise was to \emph{add} functionality
to our schema. That means we also have to upgrade our documentation function as
well.

Hopefully it is clear from the structure of our data type that we haven't
\emph{lost} any information. Updating our documentation generator should be just
a matter of changing how to we get the items from our \texttt{ListF} and
\texttt{Ap}.

Yes, we could manually pattern match and take advantage of the structure, or use
an interpretation function directly, etc., but if we just want to get a list of
monomorphic items from a functor combinator, there's a convenient function in
\emph{functor-combinators} called \texttt{icollect}:\footnote{\texttt{icollect}
  function is nothing magical --- it's essentially \texttt{interpret} wrapped
  with \texttt{Const}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} essentially}
\NormalTok{icollect f }\OtherTok{=}\NormalTok{ getConst }\OperatorTok{.}\NormalTok{ interpret (\textbackslash{}x }\OtherTok{{-}>} \DataTypeTok{Const}\NormalTok{ [f x])}
\end{Highlighting}
\end{Shaded}
}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{icollect ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}>}\NormalTok{ b) }\OtherTok{{-}>} \DataTypeTok{ListF}\NormalTok{ f a }\OtherTok{{-}>}\NormalTok{ [b]}
\OtherTok{icollect ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.}\NormalTok{ f x }\OtherTok{{-}>}\NormalTok{ b) }\OtherTok{{-}>} \DataTypeTok{Ap}\NormalTok{    f a }\OtherTok{{-}>}\NormalTok{ [b]}
\end{Highlighting}
\end{Shaded}

Give it a function to ``get'' a \texttt{b} out of every \texttt{f}, it collects
the \texttt{b} from every \texttt{f} inside the structure and puts it in a list
for us. Note that this type is very similar to the \texttt{map} we used earlier:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} what we used before}
\FunctionTok{map}\OtherTok{      ::}\NormalTok{ (          }\DataTypeTok{Field}   \OtherTok{{-}>}\NormalTok{ b) }\OtherTok{{-}>}\NormalTok{ [}\DataTypeTok{Field}\NormalTok{]    }\OtherTok{{-}>}\NormalTok{ [b]}
\CommentTok{{-}{-} what we can use now}
\OtherTok{icollect ::}\NormalTok{ (}\KeywordTok{forall}\NormalTok{ x}\OperatorTok{.} \DataTypeTok{Field}\NormalTok{ x }\OtherTok{{-}>}\NormalTok{ b) }\OtherTok{{-}>} \DataTypeTok{Ap} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{{-}>}\NormalTok{ [b]}
\end{Highlighting}
\end{Shaded}

So it looks like \texttt{icollect} should work as a drop-in replacement for
\texttt{map} \ldots{}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/parse.hs\#L82{-}L109}

\NormalTok{schemaDoc}
\OtherTok{    ::} \DataTypeTok{String}       \CommentTok{{-}{-} \^{} name}
    \OtherTok{{-}>} \DataTypeTok{Schema}\NormalTok{ x     }\CommentTok{{-}{-} \^{} schema}
    \OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{schemaDoc title }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
    \DataTypeTok{RecordType}\NormalTok{ fs }\OtherTok{{-}>}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"\{"} \OperatorTok{<>}\NormalTok{ title }\OperatorTok{<>} \StringTok{"\}"}\NormalTok{)}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
\NormalTok{          icollect (\textbackslash{}fld }\OtherTok{{-}>} \StringTok{"*"} \OperatorTok{PP.<+>}\NormalTok{ PP.indent }\DecValTok{2}\NormalTok{ (fieldDoc fld)) fs}
\NormalTok{      ]}
    \DataTypeTok{SumType}\NormalTok{ cs    }\OtherTok{{-}>}\NormalTok{ PP.vsep [}
\NormalTok{        PP.pretty (}\StringTok{"("} \OperatorTok{<>}\NormalTok{ title }\OperatorTok{<>} \StringTok{")"}\NormalTok{)}
\NormalTok{      , }\StringTok{"Choice of:"}
\NormalTok{      , PP.indent }\DecValTok{2} \OperatorTok{.}\NormalTok{ PP.vsep }\OperatorTok{$}
\NormalTok{          icollect choiceDoc cs}
\NormalTok{      ]}
    \DataTypeTok{SchemaLeaf}\NormalTok{ p  }\OtherTok{{-}>}\NormalTok{ PP.pretty (title }\OperatorTok{<>} \StringTok{":"}\NormalTok{)}
              \OperatorTok{PP.<+>}\NormalTok{ primDoc p}
  \KeywordTok{where}
\OtherTok{    fieldDoc ::} \DataTypeTok{Field}\NormalTok{ x }\OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    fieldDoc }\DataTypeTok{Field}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ schemaDoc fieldName fieldValue}
\OtherTok{    choiceDoc ::} \DataTypeTok{Choice}\NormalTok{ x }\OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    choiceDoc }\DataTypeTok{Choice}\NormalTok{\{}\OperatorTok{..}\NormalTok{\} }\OtherTok{=}\NormalTok{ schemaDoc choiceName choiceValue}
\OtherTok{    primDoc ::} \DataTypeTok{Primitive}\NormalTok{ x }\OtherTok{{-}>} \DataTypeTok{PP.Doc}\NormalTok{ a}
\NormalTok{    primDoc }\OtherTok{=}\NormalTok{ \textbackslash{}}\KeywordTok{case}
      \DataTypeTok{PString}\NormalTok{ \_ }\OtherTok{{-}>} \StringTok{"string"}
      \DataTypeTok{PNumber}\NormalTok{ \_ }\OtherTok{{-}>} \StringTok{"number"}
      \DataTypeTok{PBool}\NormalTok{   \_ }\OtherTok{{-}>} \StringTok{"bool"}
\end{Highlighting}
\end{Shaded}

Neat, we just had to replace
\texttt{map\ (\textbackslash{}fld\ -\textgreater{}\ ..)\ fs} with
\texttt{icollect\ (\textbackslash{}fld\ -\textgreater{}\ ...)\ fs}, and
\texttt{map\ choiceDoc\ cs} with \texttt{icollect\ choiceDoc\ cs}. We were able
to re-use the exact same logic --- we lose no power and upgrading was a
straightforward mechanical transformation.

\hypertarget{contravariant-consumption}{%
\section{Contravariant Consumption}\label{contravariant-consumption}}

Now, let's consider instead the situation where we would want to
\emph{serialize} an \texttt{a} with a schema. We'll make a type
\texttt{Schema\ a} that represents something that can encode an \texttt{a} as a
json value; we'll write a function:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{schemaToValue ::} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{{-}>}\NormalTok{ a }\OtherTok{{-}>} \DataTypeTok{Aeson.Value}
\end{Highlighting}
\end{Shaded}

To keep things simple, let's forget all the parsing stuff for now; we'll add it
back in later. Let's just create a type that can \emph{only} serialize by
enhancing our documentation schema.

Again, for the same reasons as before, we can get away with the only fundamental
change being at the leaves/primitives. Our structure is very limited, and our
schema type only expresses only variations within that limit, and the only
variations (aside from sum/record structure) are how each leaf can be
serialized.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/serialize.hs\#L51{-}L54}

\KeywordTok{data} \DataTypeTok{Primitive}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{PString}\NormalTok{ (a }\OtherTok{{-}>} \DataTypeTok{String}\NormalTok{)}
    \OperatorTok{|} \DataTypeTok{PNumber}\NormalTok{ (a }\OtherTok{{-}>} \DataTypeTok{Scientific}\NormalTok{)}
    \OperatorTok{|} \DataTypeTok{PBool}\NormalTok{   (a }\OtherTok{{-}>} \DataTypeTok{Bool}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A \texttt{Primitive\ a} will be a way to \emph{serialize} a json primitive ---
it can be \texttt{PString}, \texttt{PNumber}, or \texttt{PBool}. To create a
``String Serializer'', you need to use \texttt{PString} with a function on ``how
to turn it into a \texttt{String}''. To create a ``Bool parser'', you need
\texttt{PBool} with a function on what how to turn the value into a
\texttt{String}.

Again, it can be useful to add some helper primitives:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/serialize.hs\#L73{-}L80}

\OtherTok{pString ::} \DataTypeTok{Primitive} \DataTypeTok{String}
\NormalTok{pString }\OtherTok{=} \DataTypeTok{PString} \FunctionTok{id}

\OtherTok{pInt ::} \DataTypeTok{Primitive} \DataTypeTok{Int}
\NormalTok{pInt }\OtherTok{=} \DataTypeTok{PNumber} \FunctionTok{fromIntegral}

\OtherTok{pBool ::} \DataTypeTok{Primitive} \DataTypeTok{Bool}
\NormalTok{pBool }\OtherTok{=} \DataTypeTok{PBool} \FunctionTok{id}
\end{Highlighting}
\end{Shaded}

\texttt{pString\ ::\ Primitive\ String} is the most basic way to serialize a
primitive json string: just return the \texttt{String} itself. \texttt{pInt}
needs to serialize the \texttt{Int} into a \texttt{Scientific} (the numeric type
of the aeson library).

\hypertarget{covariance-vs-contravariance}{%
\subsection{Covariance vs Contravariance}\label{covariance-vs-contravariance}}

Before we go further, let's take a moment to pause and discuss the difference
between covariant and contravariant functors, and the usefulness of those
concepts. ``Covariant'' functors (or capital-F \texttt{Functor}s in Haskell) are
functors \texttt{f} where you can consider \texttt{f\ a} as a ``producer'' of
\texttt{a} --- for example, \texttt{Schema\ a} from our parsing section is a
thing you can use to parse/produce an \texttt{a} out of a bytestring. These are
things where it makes sense to
\texttt{fmap\ ::\ (a\ -\textgreater{}\ b)\ -\textgreater{}\ f\ a\ -\textgreater{}\ f\ b}:
if you have a producer of \texttt{a}s, you can always ``post-filter'' the result
with an \texttt{a\ -\textgreater{}\ b} to get a producer of \texttt{b}s.

``Contravariant'' functors (\texttt{Contravariant} in Haskell) are functors
\texttt{f} where you can consider \texttt{f\ a} as a ``consumer'' of \texttt{a}.
For example, \texttt{Primtive\ a} (and the \texttt{Schema\ a} we want to make)
from our serializing section is something that consums \texttt{a}s and produces
json values. These are things where it makes sense to \texttt{contramap}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{class} \DataTypeTok{Contravariant}\NormalTok{ f }\KeywordTok{where}
\OtherTok{    contramap ::}\NormalTok{ (a }\OtherTok{{-}>}\NormalTok{ b) }\OtherTok{{-}>}\NormalTok{ f b }\OtherTok{{-}>}\NormalTok{ f a}
\end{Highlighting}
\end{Shaded}

which says: if you have a consumer of \texttt{b}s, you can always ``pre-filter''
the input with an \texttt{a\ -\textgreater{}\ b} to get a consumer of
\texttt{a}s.

\hypertarget{finding-div}{%
\subsection{Finding Div}\label{finding-div}}

Now, back on to building our \texttt{Schema} type. Again, we might want to write
something like

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data} \DataTypeTok{Schema}\NormalTok{ a }\OtherTok{=}
      \DataTypeTok{RecordType}\NormalTok{  [}\DataTypeTok{Field}\NormalTok{ a]}
    \OperatorTok{|} \DataTypeTok{SumType}\NormalTok{     [}\DataTypeTok{Choice}\NormalTok{ a]}
    \OperatorTok{|} \DataTypeTok{SchemaLeaf}\NormalTok{  (}\DataTypeTok{Primitive}\NormalTok{ a)}
  \KeywordTok{deriving} \DataTypeTok{Functor}
\CommentTok{{-}{-} source: https://github.com/mstksg/inCode/tree/master/code{-}samples/functor{-}structures/serialize.hs\#L39{-}L45}

\KeywordTok{data} \DataTypeTok{Field}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Field}

\KeywordTok{data} \DataTypeTok{Choice}\NormalTok{ a }\OtherTok{=} \DataTypeTok{Choice}
\end{Highlighting}
\end{Shaded}

However, this has the same problems as before. \texttt{RecordType} is a
combination of \texttt{Field}s, and each \texttt{Field} is (again) a different
type! We also have a unique situation in this case where each \texttt{Choice}
has to consume a specific type (the sub-type of our \texttt{Sum}) if we want
each one to not be a partial consumer. For example, for the \texttt{CBusiness}
branch, we'd want it to have a \texttt{Choice\ Int} (the \texttt{cbEmployees}
field), not \texttt{Choice\ Customer} --- \texttt{Customer} is too general of a
type, since we want that specific branch to consume only \texttt{Int}s.

So again we have the challenge of ``mixing'' together the types of our
individual components somehow.

\begin{itemize}
\tightlist
\item
  For \texttt{RecordType}, we need something that can combine multiple
  \texttt{Field\ x}s into a \texttt{Schema\ a} by distributing the \texttt{a}
  input and sharing it across all the \texttt{Field\ x}s.
\item
  For \texttt{SumType}, we need something that can combine multiple
  \texttt{Choice\ x}s into a \texttt{Schema\ a} by \emph{redirecting} the
  \texttt{a} input into the appropriate \texttt{Choice} that is meant to handle
  it.
\end{itemize}

These ones are a little trickier because contravariant abstractions like these
are a little less commonly used than the covariant ones we talked about earlier.

\hypertarget{signoff}{%
\section{Signoff}\label{signoff}}

Hi, thanks for reading! You can reach me via email at
\href{mailto:justin@jle.im}{\nolinkurl{justin@jle.im}}, or at twitter at
\href{https://twitter.com/mstk}{@mstk}! This post and all others are published
under the \href{https://creativecommons.org/licenses/by-nc-nd/3.0/}{CC-BY-NC-ND
3.0} license. Corrections and edits via pull request are welcome and encouraged
at \href{https://github.com/mstksg/inCode}{the source repository}.

If you feel inclined, or this post was particularly helpful for you, why not
consider \href{https://www.patreon.com/justinle/overview}{supporting me on
Patreon}, or a \href{bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU}{BTC donation}?
:)

\end{document}
