<!DOCTYPE HTML>
<html><head><title>Hamiltonian Dynamics in Haskell · in Code</title><meta name="description" content="Weblog of Justin Le, covering his various adventures in programming and explorations in the vast worlds of computation physics, and knowledge."><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><meta name="flattr:id" content="3p9jqr"><meta property="og:site_name" content="in Code"><meta property="og:description" content="As promised in my hamilton introduction post (published almost exactly one year ago!), I’m going to go over implementing of the hamilton library using  * DataKinds (with TypeLits) to enforce sizes of vectors and matrices and help guide us write our code * Statically-sized linear algebra with hmatrix * Automatic differentiation with ad * Statically-sized vectors with vector-sized This post will be a bit heavy in some mathematics and Haskell concepts. The expected audience is intermediate Haskell programmers. Note that this is not a post on dependent types, because dependent types (types that depend on runtime values) are not explicitly used. The mathematics and physics are “extra” flavor text and could potentially be skipped, but you’ll get the most out of this article if you have basic familiarity with:  * Basic concepts of multivariable calculus (like partial and total derivatives). * Concepts of linear algebra (like dot products, matrix multiplication, and matrix inverses) No physics knowledge is assumed, but knowing a little bit of first semester physics would help you gain a bit more of an appreciation for the end result!"><meta property="og:type" content="article"><meta property="og:title" content="Hamiltonian Dynamics in Haskell"><meta property="og:image" content="https://blog.jle.im/img/site_logo.jpg"><meta property="og:locale" content="en_US"><meta property="og:url" content="https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.html"><meta name="twitter:card" content="summary"><meta name="twitter:creator:id" content="mstk"><link rel="author" href="https://plus.google.com/107705320197444500140"><link rel="alternate" type="application/rss+xml" title="in Code (RSS Feed)" href="http://feeds.feedburner.com/incodeblog"><link rel="canonical" href="https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.html"><link href="https://blog.jle.im/favicon.ico" rel="shortcut icon"><link href="https://blog.jle.im/css/toast.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/font.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/main.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/page/entry.css" rel="stylesheet" type="text/css"><link href="https://blog.jle.im/css/pygments.css" rel="stylesheet" type="text/css"><script type="text/javascript">var page_data = {};
var disqus_shortname='incode';
</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-443711-8', 'jle.im');
ga('send', 'pageview');
</script><script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5234d67a6b68dcd4"></script><script type="text/javascript" src="https://blog.jle.im/js/page/entry_toc.js"></script><script type="text/javascript" src="https://blog.jle.im/js/disqus_count.js"></script><script type="text/javascript" src="https://blog.jle.im/js/social.js"></script><script type="text/javascript" src="https://blog.jle.im/js/jquery/jquery.toc.js"></script><script type="text/javascript" src="https://blog.jle.im/purescript/entry.js"></script></head><body><div id="fb-root"><script>(function(d, s, id) {
 var js, fjs = d.getElementsByTagName(s)[0];
 if (d.getElementById(id)) return;
 js = d.createElement(s); js.id = id;
 js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=641852699171929";
 fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));
</script></div><div id="header-container"><div id="navbar-container" class="tile"><nav id="navbar-content"><div class="nav-info"><h1 class="site-title"><a href="https://blog.jle.im/" class="nav-title">in Code</a></h1><span class="nav-author">Justin Le</span></div><ul class="nav-links"><li><a href="https://blog.jle.im/">home</a></li><li><a href="https://blog.jle.im/entries.html">archives</a></li><div class="clear"></div></ul></nav></div><div id="header-content"></div></div><div id="body-container" class="container"><div id="main-container" class="grid"><div class="entry-section unit span-grid" role="main"><article class="tile article"><header><h1 id="title">Hamiltonian Dynamics in Haskell</h1><p class="entry-info">by <a class="author" href="https://blog.jle.im/">Justin Le</a><span class="info-separator"> &diams; </span><time datetime="2017-11-27T11:46:18Z" pubdate="" class="pubdate">Monday November 27, 2017</time></p><p><span class="source-info"><a class="source-link" href="https://github.com/mstksg/inCode/tree/master/copy/entries/hamilton-1.md">Source</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://github.com/mstksg/inCode/tree/gh-pages/entry/hamiltonian-dynamics-in-haskell.md">Markdown</a><span class="info-separator"> &diams; </span><a class="source-link" href="https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.tex">LaTeX</a><span class="info-separator"> &diams; </span></span>Posted in <a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category" title="Functional, pure, non-strict, statically and strongly typed, natively
compiled...really just the king of great languages.">Haskell</a><span class="info-separator"> &diams; </span><a class="comment-link" href="#disqus_thread">Comments</a></p></header><hr><aside class="contents-container"><h5 id="contents-header">Contents</h5><div id="toc"></div></aside><div class="main-content copy-content"><p>As promised in my <a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html"><em>hamilton</em> introduction post</a> (published almost exactly one year ago!), I’m going to go over implementing of the <em><a href="http://hackage.haskell.org/package/hamilton">hamilton</a></em> library using</p>
<ol type="1">
<li><em>DataKinds</em> (with <em>TypeLits</em>) to enforce sizes of vectors and matrices and help guide us write our code</li>
<li>Statically-sized linear algebra with <em><a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a></em></li>
<li>Automatic differentiation with <em><a href="http://hackage.haskell.org/package/ad">ad</a></em></li>
<li>Statically-sized vectors with <em><a href="http://hackage.haskell.org/package/vector-sized">vector-sized</a></em></li>
</ol>
<p>This post will be a bit heavy in some mathematics and Haskell concepts. The expected audience is intermediate Haskell programmers. Note that this is <em>not</em> a post on dependent types, because dependent types (types that depend on runtime values) are not explicitly used.</p>
<p>The mathematics and physics are “extra” flavor text and could potentially be skipped, but you’ll get the most out of this article if you have basic familiarity with:</p>
<ol type="1">
<li>Basic concepts of multivariable calculus (like partial and total derivatives).</li>
<li>Concepts of linear algebra (like dot products, matrix multiplication, and matrix inverses)</li>
</ol>
<p>No physics knowledge is assumed, but knowing a little bit of first semester physics would help you gain a bit more of an appreciation for the end result!</p>
<p>The <a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">hamilton library introduction</a> should be considered a “soft prerequisite” for this post, as it presents motivations, visual demonstrations, and general overviews of the methods presented here!</p>
<h2 id="the-goal">The Goal</h2>
<p>At the end of this, we should be able to have Haskell <em>automatically generate</em> <strong>equations of motions</strong> for any arbitrary system described in arbitrary coordinate systems, and simulate that system.</p>
<p>Normally, we’d describe a system using particles’ x and y coordinates, but our goal is to be able to describe our particles’ positions using any coordinate system we want (polar, distance-along-a-curved-rail, pendulum-angles, etc.) and have Haskell automatically generate equations of motions and time progressions of those coordinates.</p>
<p>Read <a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">my hamilton library introduction</a> for more information and examples!</p>
<h2 id="hamiltonian-mechanics">Hamiltonian Mechanics</h2>
<p>As mentioned in the previous post, Hamiltonian mechanics is a re-imagining of dynamics and mechanics (think “the world post-<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?F%20%3D%20m%20a" alt="F = m a" title="F = m a" />”) that not only opened up new doors to solving problems in classical, but also ended up being the right angle of viewing the world to unlock statistical mechanics and thermodynamics, and later even quantum mechanics.</p>
<p>Hamiltonian mechanics lets you parameterize your system’s “position” in arbitrary ways (like the angle of rotation, for pendulum problems) and then posits that the full state of the system exists in something called <em>phase space</em>, and that the system’s dynamics is its motion through phase space that is dictated by the geometry of the <em>Hamiltonian</em> of that phase space.</p>
<p>The system’s <em>Hamiltonian</em> is a <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B2n%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D" alt="\mathbb{R}^{2n} \rightarrow \mathbb{R}" title="\mathbb{R}^{2n} \rightarrow \mathbb{R}" /> function from a point in <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B2n%7D" alt="\mathbb{R}^{2n}" title="\mathbb{R}^{2n}" /> phase space (where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> is the number of coordinates parameterizing your system) to a scalar in <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D" alt="\mathbb{R}" title="\mathbb{R}" />. For a time-independent system, the picture of the dynamics is pretty simple: the system moves along the <em>contour lines</em> of the <em>Hamiltonian</em> – the lines of equal “height”.</p>
<figure>
<img src="/img/entries/hamilton/contour-lines.jpg" title="Contour lines" alt="Example of contour lines of a \mathbb{R}^2 \rightarrow \mathbb{R} function – the elevation of land, from the Ordinace Survey website." /><figcaption>Example of contour lines of a <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E2%20%5Crightarrow%20%5Cmathbb%7BR%7D" alt="\mathbb{R}^2 \rightarrow \mathbb{R}" title="\mathbb{R}^2 \rightarrow \mathbb{R}" /> function – the elevation of land, from the <a href="https://www.ordnancesurvey.co.uk/blog/2015/11/map-reading-skills-making-sense-of-contour-lines/">Ordinace Survey</a> website.</figcaption>
</figure>
<p>In the example above, if we imagine that phase space is the 2D location, then the <em>Hamiltonian</em> is the mountain. And for a system dropped anywhere on the mountain, its motion would be along the contour lines. For example, if a system started somewhere along the 10 contour line, it would begin to oscillate the entire phase space along the 10 contour line.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<p><em>Every</em> <a href="https://www.youtube.com/watch?v=izGwDsrQ1eQ">smooth</a> <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5E%7B2n%7D%20%5Crightarrow%20%5Cmathbb%7BR%7D" alt="\mathbb{R}^{2n} \rightarrow \mathbb{R}" title="\mathbb{R}^{2n} \rightarrow \mathbb{R}" /> function on phase space can be used as a Hamiltonian to describe the physics of some system. So, given any “mountain range” on phase space, any “elevation map” or real-valued function on phase space, you can treat it as a description of the dynamics of some physical system.</p>
<p>The <em>trick</em>, then, to using Hamiltonian dynamics to model your system, is:</p>
<ol type="1">
<li><p>Finding the phase space to describe your system. This can be done based on any continuous parameterization of your system (“generalized coordinates”), like angles of pendulums and so on.</p></li>
<li><p>Finding the Hamiltonian on that phase space to describe your system.</p></li>
</ol>
<p>And then Hamilton’s dynamics will give you the rest! All you do is “follow the contour lines” on that Hamiltonian!</p>
<h3 id="phase-space">Phase Space</h3>
<p>Hamiltonian dynamics are about systems moving around in phase space. It seems that phase space is the “room where it happens”, so to speak, so let’s dig deeper into what it is. <em>Phase space</em> is a <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?2n" alt="2n" title="2n" />-dimensional space parameterized by:</p>
<ol type="1">
<li>All of the current values of the <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> parameters (“generalized coordinates”)</li>
<li>All of the current “generalized momenta” of those <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> parameters</li>
</ol>
<p>So if you were parameterizing your pendulum system by, say, the angle of the pendulum, then a point in phase space would be the current angle of the pendulum along with the current “generalized momentum” associated with the angle of the pendulum. What exactly <em>is</em> generalized momentum? We’ll go over calculating it eventually, but what does it represent…<em>physically</em>?</p>
<p>The deeper answer involves the underlying Lie algebra of the Lie group associated with the generalized coordinates, but going into that would make this a completely different post. What I <em>can</em> say is that the generalized momenta associated with (“conjugate to”) certain sets of familiar coordinates yield things that we typically call “momenta”:</p>
<ol type="1">
<li><p>The momentum conjugate to normal Cartesian coordinates is just our normal run-of-the-mill <em>linear momentum</em> (in the <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D%20%3D%20m%20%5Cmathbf%7Bv%7D" alt="\mathbf{p} = m \mathbf{v}" title="\mathbf{p} = m \mathbf{v}" />) from first semester physics.</p></li>
<li><p>The momentum conjugate to the angle <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta" alt="\theta" title="\theta" /> in polar coordinates is <em>angular momentum</em> (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?L%20%3D%20m%20r%5E2%20%5Cdot%7B%5Ctheta%7D" alt="L = m r^2 \dot{\theta}" title="L = m r^2 \dot{\theta}" />) from first semester physics.</p></li>
<li><p>The momentum conjugate to the radial coordinate <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?r" alt="r" title="r" /> in polar coordinates is also just boring old linear momentum <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?p_r%20%3D%20m%20%5Cdot%7Br%7D" alt="p_r = m \dot{r}" title="p_r = m \dot{r}" />, which makes sense because purely radial motion is just linear motion.</p></li>
</ol>
<p>So, it’s our normal momentum (for linear and polar coordinates) <em>generalized</em> to arbitrary coordinates.</p>
<h3 id="hamiltonian-dynamics">Hamiltonian Dynamics</h3>
<p>I’ve explained Hamiltonian dynamics for time-independent Hamiltonians as “follow the contour lines”. If you remember your basic multi-variable calculus course, you’ll know that the line of “steepest ascent” is the gradient. If we call the Hamiltonian <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29" alt="\mathcal{H}(\mathbf{q},\mathbf{p})" title="\mathcal{H}(\mathbf{q},\mathbf{p})" /> (where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> is the vector of positions and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" /> is the vector of momenta), then the direction of steepest ascent is</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cleft%20%5Clangle%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7Bq%7D%7D%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%2C%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cmathbf%7Bp%7D%7D%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%5Cright%20%5Crangle%0A" alt="
\left \langle \frac{\partial}{\partial \mathbf{q}}
\mathcal{H}(\mathbf{q},\mathbf{p}), \frac{\partial}{\partial \mathbf{p}}
\mathcal{H}(\mathbf{q},\mathbf{p}) \right \rangle
" title="
\left \langle \frac{\partial}{\partial \mathbf{q}}
\mathcal{H}(\mathbf{q},\mathbf{p}), \frac{\partial}{\partial \mathbf{p}}
\mathcal{H}(\mathbf{q},\mathbf{p}) \right \rangle
" /><br /></p>
<p>But we want to move along the <em>contour lines</em>…and these are the lines <em>perpendicular</em> to the direction of steepest descent. The vector perpendicular to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Clangle%20x%2C%20y%20%5Crangle" alt="\langle x, y \rangle" title="\langle x, y \rangle" /> is <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Clangle%20y%2C%20-x%20%5Crangle" alt="\langle y, -x \rangle" title="\langle y, -x \rangle" />,<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> so we just derived the actual Hamiltonian equations of motion: just move in the direction perpendicular to the steepest ascent! That is, to have things move on contour lines, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bq%7D" alt="\dot{q}" title="\dot{q}" /> and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bp%7D_q" alt="\dot{p}_q" title="\dot{p}_q" /> <em>should</em> be:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cdot%7Bq%7D%20%26%20%3D%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20p_q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%5C%5C%0A%5Cdot%7Bp%7D_q%20%26%20%3D%20-%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%0A%5Cend%7Baligned%7D%0A" alt="
\begin{aligned}
\dot{q} &amp; = \frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p}) \\
\dot{p}_q &amp; = - \frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})
\end{aligned}
" title="
\begin{aligned}
\dot{q} &amp; = \frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p}) \\
\dot{p}_q &amp; = - \frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})
\end{aligned}
" /><br /></p>
<p>This is a conclusion with one generalized coordinate <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q" alt="q" title="q" />, but we can generalize this to systems with multiple coordinates as well, as long as this holds for <em>every</em> <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q" alt="q" title="q" /> and the momentum conjugate to it (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?p_q" alt="p_q" title="p_q" />). (For the rest of this post, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> refers to the vector of coordinates, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q" alt="q" title="q" /> refers to a single specific coordinate, and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?p_q" alt="p_q" title="p_q" /> refers to the momentum conjugate to that coordinate).</p>
<p>Essentially, these give you “updating functions” for <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q" alt="q" title="q" /> and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?p_q" alt="p_q" title="p_q" /> – given <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29" alt="\mathcal{H}(\mathbf{q},\mathbf{p})" title="\mathcal{H}(\mathbf{q},\mathbf{p})" />, you have a way to “update” the particle’s position in phase space. Just take the partial derivatives of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D" alt="\mathcal{H}" title="\mathcal{H}" /> at every step in time! To update <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q" alt="q" title="q" />, nudge it by <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20p_q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29" alt="\frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p})" title="\frac{\partial}{\partial p_q} \mathcal{H}(\mathbf{q},\mathbf{p})" />. To update <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?p_q" alt="p_q" title="p_q" />, nudge it by <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?-%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29" alt="-\frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})" title="-\frac{\partial}{\partial q} \mathcal{H}(\mathbf{q},\mathbf{p})" />!</p>
<p>This picture is appealing to me in a visceral way because it sort of seems like the system is “surfing” along the Hamiltonian’s contour lines. It’s being “pushed” <em>faster</em> when the Hamiltonian is steeper, and slower when it’s more shallow. I can apply all my intuition as a surfer<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> to Hamiltonian mechanics!</p>
<h2 id="hamiltonian-dynamics-and-physical-systems">Hamiltonian Dynamics and Physical Systems</h2>
<p>Earlier I mentioned that the two steps for applying Hamiltonian mechanics to your system was figuring out your system’s conjugate momenta and the appropriate Hamiltonian. To explain this, I’m going to make a couple of simplifying assumptions that make the job easier for the purposes of this article:</p>
<ol type="1">
<li>Your coordinates and potential energy are time-independent.</li>
<li>Your potential energy function only depends on <em>positions</em>, and not <em>velocities</em>. (So nothing like friction or wind resistance or magnetic field vector potentials)</li>
</ol>
<p>With these assumptions, I’m going to skip over discussing the <a href="https://en.wikipedia.org/wiki/Lagrangian_mechanics">Lagrangian</a> of the system, which is the traditional way to do this. You can think of this section as me presenting derived conclusions and skipping the derivations.</p>
<h3 id="conjugate-momenta">Conjugate Momenta</h3>
<p>For systems with velocity-independent potential energies, it can be shown that the momentum conjugate to coordinate <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q" alt="q" title="q" /> is</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0Ap_q%20%3D%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cdot%7Bq%7D%7D%20KE%28%5Cmathbf%7Bq%7D%2C%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29%0A" alt="
p_q = \frac{\partial}{\partial \dot{q}} KE(\mathbf{q}, \dot{\mathbf{q}})
" title="
p_q = \frac{\partial}{\partial \dot{q}} KE(\mathbf{q}, \dot{\mathbf{q}})
" /><br /></p>
<p>Where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?KE%28%5Cmathbf%7Bq%7D%2C%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29" alt="KE(\mathbf{q},\dot{\mathbf{q}})" title="KE(\mathbf{q},\dot{\mathbf{q}})" /> is the kinetic energy of the system, which is a function on the coordinates <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> and their rates of change, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D" alt="\dot{\mathbf{q}}" title="\dot{\mathbf{q}}" />. For example, for normal Cartesian coordinates in one dimension, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?KE%28x%2C%20%5Cdot%7Bx%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20m%20%5Cdot%7Bx%7D%5E2" alt="KE(x, \dot{x}) = \frac{1}{2} m \dot{x}^2" title="KE(x, \dot{x}) = \frac{1}{2} m \dot{x}^2" />. So the momentum conjugate to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /> is:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0Ap_x%20%3D%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20%5Cdot%7Bx%7D%7D%20%5Cleft%5B%20%5Cfrac%7B1%7D%7B2%7D%20m%20%5Cdot%7Bx%7D%5E2%20%5Cright%5D%20%3D%20m%20%5Cdot%7Bx%7D%0A" alt="
p_x = \frac{\partial}{\partial \dot{x}} \left[ \frac{1}{2} m \dot{x}^2 \right] = m \dot{x}
" title="
p_x = \frac{\partial}{\partial \dot{x}} \left[ \frac{1}{2} m \dot{x}^2 \right] = m \dot{x}
" /><br /></p>
<p>Just linear momentum, like I claimed before.</p>
<p>Let’s generalize this to arbitrary coordinates. In general, for <em>Cartesian</em> coordinates, the kinetic energy will always be</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0AKE%28%5Cmathbf%7Bx%7D%2C%20%5Cdot%7B%5Cmathbf%7Bx%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cleft%5B%20m_1%20%5Cdot%7Bx%7D_1%5E2%20%2B%20m_2%20%5Cdot%7Bx%7D_2%5E2%20%2B%20m_3%20%5Cdot%7Bx%7D_3%5E2%20%2B%20%5Cdots%20%5Cright%5D%0A" alt="
KE(\mathbf{x}, \dot{\mathbf{x}}) = \frac{1}{2} \left[ m_1 \dot{x}_1^2 + m_2 \dot{x}_2^2 + m_3 \dot{x}_3^2 + \dots \right]
" title="
KE(\mathbf{x}, \dot{\mathbf{x}}) = \frac{1}{2} \left[ m_1 \dot{x}_1^2 + m_2 \dot{x}_2^2 + m_3 \dot{x}_3^2 + \dots \right]
" /><br /></p>
<p>Where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m" alt="m" title="m" /> is the inertia associated with each coordinate…for example, if <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Clangle%20x_1%2C%20x_2%20%5Crangle" alt="\langle x_1, x_2 \rangle" title="\langle x_1, x_2 \rangle" /> describes the location of an object of mass <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m" alt="m" title="m" />, then <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m_1%20%3D%20m_2%20%3D%20m" alt="m_1 = m_2 = m" title="m_1 = m_2 = m" />.</p>
<p>To give us nice notation and make things more convenient, we’ll write this as a quadratic form over an inertia matrix:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0AKE%28%5Cdot%7B%5Cmathbf%7Bx%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bx%7D%7D%5ET%20%5Chat%7BM%7D%20%5Cdot%7B%5Cmathbf%7Bx%7D%7D%0A" alt="
KE(\dot{\mathbf{x}}) = \frac{1}{2} \dot{\mathbf{x}}^T \hat{M} \dot{\mathbf{x}}
" title="
KE(\dot{\mathbf{x}}) = \frac{1}{2} \dot{\mathbf{x}}^T \hat{M} \dot{\mathbf{x}}
" /><br /></p>
<p>Where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BM%7D" alt="\hat{M}" title="\hat{M}" /> is the <a href="https://en.wikipedia.org/wiki/Diagonal_matrix">diagonal matrix</a> whose entries are the masses of each coordinate, and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bx%7D%7D" alt="\dot{\mathbf{x}}" title="\dot{\mathbf{x}}" /> is the column vector of all of the (Cartesian) coordinates, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cleft%5B%20%5Cdot%7Bx%7D_1%5C%2C%20%5Cdot%7Bx%7D_2%5C%2C%20%5Cdot%7Bx%7D_3%5C%2C%20%5Cdots%20%5Cright%5D%5ET" alt="\left[ \dot{x}_1\, \dot{x}_2\, \dot{x}_3\, \dots \right]^T" title="\left[ \dot{x}_1\, \dot{x}_2\, \dot{x}_3\, \dots \right]^T" />.</p>
<p>Now! How to generalize this to arbitrary coordinates? Well, if we have <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> generalized coordinates <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> mapping to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m" alt="m" title="m" />-dimensional Cartesian coordinates, we can specify them as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D%20%3D%20f%28%5Cmathbf%7Bq%7D%29" alt="\mathbf{x} = f(\mathbf{q})" title="\mathbf{x} = f(\mathbf{q})" />, where <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em" alt="f : \mathbb{R}^n \rightarrow \mathbb{R}^m" title="f : \mathbb{R}^n \rightarrow \mathbb{R}^m" />, taking the vector of generalized coordinates and returning a vector for the position in Cartesian space. For example, for polar coordinates, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f%28r%2C%20%5Ctheta%29%20%3D%20%5Cleft%20%5Clangle%20r%20%5Ccos%28%5Ctheta%29%2C%20r%20%5Csin%28%5Ctheta%29%20%5Cright%20%5Crangle" alt="f(r, \theta) = \left \langle r \cos(\theta), r \sin(\theta) \right \rangle" title="f(r, \theta) = \left \langle r \cos(\theta), r \sin(\theta) \right \rangle" />, because, for polar coordinates, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?x%20%3D%20r%20%5Ccos%28%5Ctheta%29" alt="x = r \cos(\theta)" title="x = r \cos(\theta)" /> and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?y%20%3D%20r%20%5Csin%28%5Ctheta%29" alt="y = r \sin(\theta)" title="y = r \sin(\theta)" />.</p>
<p>So we can get <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bx%7D" alt="\mathbf{x}" title="\mathbf{x}" /> from <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> with <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" />, but how can we get <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bx%7D%7D" alt="\dot{\mathbf{x}}" title="\dot{\mathbf{x}}" />, the vector of rate of changes? Well, if <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?x_1%20%3D%20f_1%28q_1%2C%20q_2%2C%20q_3%20%5Cdots%29" alt="x_1 = f_1(q_1, q_2, q_3 \dots)" title="x_1 = f_1(q_1, q_2, q_3 \dots)" />, then the <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D_1" alt="\dot{x}_1" title="\dot{x}_1" /> is the <a href="https://en.wikipedia.org/wiki/Total_derivative">total derivative</a> of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?x_1" alt="x_1" title="x_1" /> with respect to time:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cdot%7Bx%7D_1%20%3D%20%5Cfrac%7B%5Cpartial%20f_1%7D%7B%5Cpartial%20q_1%7D%20%5Cdot%7Bq%7D_1%20%2B%0A%20%20%20%20%5Cfrac%7B%5Cpartial%20f_1%7D%7B%5Cpartial%20q_2%7D%20%5Cdot%7Bq%7D_2%20%2B%0A%20%20%20%20%5Cfrac%7B%5Cpartial%20f_1%7D%7B%5Cpartial%20q_3%7D%20%5Cdot%7Bq%7D_3%20%2B%20%5Cdots%0A" alt="
\dot{x}_1 = \frac{\partial f_1}{\partial q_1} \dot{q}_1 +
    \frac{\partial f_1}{\partial q_2} \dot{q}_2 +
    \frac{\partial f_1}{\partial q_3} \dot{q}_3 + \dots
" title="
\dot{x}_1 = \frac{\partial f_1}{\partial q_1} \dot{q}_1 +
    \frac{\partial f_1}{\partial q_2} \dot{q}_2 +
    \frac{\partial f_1}{\partial q_3} \dot{q}_3 + \dots
" /><br /></p>
<p>Or, in short:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cdot%7Bx%7D_i%20%3D%20%5Csum_%7Bj%20%3D%201%7D%5En%20%5Cfrac%7B%5Cpartial%20f_i%7D%7B%5Cpartial%20q_j%7D%20%5Cdot%7Bq%7D_j%0A" alt="
\dot{x}_i = \sum_{j = 1}^n \frac{\partial f_i}{\partial q_j} \dot{q}_j
" title="
\dot{x}_i = \sum_{j = 1}^n \frac{\partial f_i}{\partial q_j} \dot{q}_j
" /><br /></p>
<p>But, hey, this looks a lot like a matrix-vector multiplication! If we make <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f" alt="\hat{J}_f" title="\hat{J}_f" />, an <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n" alt="m \times n" title="m \times n" /> matrix of partial derivatives of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" /> (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_%7Bfij%7D%20%3D%20%5Cfrac%7B%5Cpartial%20f_i%7D%7B%5Cpartial%20q_j%7D" alt="\hat{J}_{fij} = \frac{\partial f_i}{\partial q_j}" title="\hat{J}_{fij} = \frac{\partial f_i}{\partial q_j}" />) at a given point (typically called the <a href="https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant">Jacobian matrix of f</a>, then we have a nice expression for <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bx%7D%7D" alt="\dot{\mathbf{x}}" title="\dot{\mathbf{x}}" />:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cdot%7B%5Cmathbf%7Bx%7D%7D%20%3D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A" alt="
\dot{\mathbf{x}} = \hat{J}_f \dot{\mathbf{q}}
" title="
\dot{\mathbf{x}} = \hat{J}_f \dot{\mathbf{q}}
" /><br /></p>
<p>And we can plug it in (remembering that <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%28A%20B%29%5ET%20%3D%20B%5ET%20A%5ET" alt="(A B)^T = B^T A^T" title="(A B)^T = B^T A^T" />) to our kinetic energy equation to get:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0AKE%28%5Cmathbf%7Bq%7D%2C%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BJ%7D_f%5ET%0A%20%20%20%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A" alt="
KE(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T
    \hat{M} \hat{J}_f \dot{\mathbf{q}}
" title="
KE(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T
    \hat{M} \hat{J}_f \dot{\mathbf{q}}
" /><br /></p>
<p>And for the final step, we differentiate with respect to the <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bq%7D" alt="\dot{q}" title="\dot{q}" />s (which is just the gradient <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cnabla_%7B%5Cdot%7B%5Cmathbf%7Bq%7D%7D%7D" alt="\nabla_{\dot{\mathbf{q}}}" title="\nabla_{\dot{\mathbf{q}}}" />) to get <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" />, the vector of conjugate momenta:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7Bp%7D%20%3D%20%5Cnabla_%7B%5Cdot%7B%5Cmathbf%7Bq%7D%7D%7D%20%5Cleft%5B%0A%20%20%20%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A%20%20%5Cright%5D%0A%20%20%3D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A" alt="
\mathbf{p} = \nabla_{\dot{\mathbf{q}}} \left[
    \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
  \right]
  = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
" title="
\mathbf{p} = \nabla_{\dot{\mathbf{q}}} \left[
    \frac{1}{2} \dot{\mathbf{q}}^T \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
  \right]
  = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
" /><br /></p>
<p>Now, we’re going to be using <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f" alt="\hat{J}_f^T \hat{M} \hat{J}_f" title="\hat{J}_f^T \hat{M} \hat{J}_f" /> a lot, so let’s give it a name, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D" alt="\hat{K}" title="\hat{K}" />. <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D" alt="\hat{K}" title="\hat{K}" /> represents some sort of coordinate-aware inertia term for our system. If the masses are all positive and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f" alt="\hat{J}_f" title="\hat{J}_f" /> is full-rank<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>, then <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D" alt="\hat{K}" title="\hat{K}" /> is a symmetric, positive-definite, invertible matrix (by construction). It’s important to also remember that it’s an explicit function of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" />, because <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f" alt="\hat{J}_f" title="\hat{J}_f" /> is a matrix of partial derivatives at a given <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" />. We now have a simple expression for the vector of conjugate momenta (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D%20%3D%20%5Chat%7BK%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D" alt="\mathbf{p} = \hat{K} \dot{\mathbf{q}}" title="\mathbf{p} = \hat{K} \dot{\mathbf{q}}" />), and also for kinetic energy (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?KE%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BK%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D" alt="KE = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}}" title="KE = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}}" />).</p>
<p>It’s going to be important for us to also be able to go backwards (to get <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D" alt="\dot{\mathbf{q}}" title="\dot{\mathbf{q}}" /> from <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" />). Luckily, because we wrote the whole thing as a matrix operation, going backwards is easy – just take the matrix inverse, which we know exists!</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A" alt="
\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}
" title="
\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}
" /><br /></p>
<p>The power of linear algebra!</p>
<h3 id="hamiltonians-of-physical-systems">Hamiltonians of Physical Systems</h3>
<p>Ok, that’s step one. How about step two – finding the Hamiltonian for your system?</p>
<p>The <em>real</em> Hamiltonian is actually the <a href="https://en.wikipedia.org/wiki/Poisson_bracket">Poisson bracket</a> of the system’s <a href="https://en.wikipedia.org/wiki/Lagrangian_mechanics">Lagrangian</a>, but I did some of the work for you for the case of time-independent coordinates where the potential energy depends <em>only</em> on positions (so, no friction, wind resistance, time, etc.). In such a case, the Hamiltonian of a system is precisely the system’s total <a href="https://en.wikipedia.org/wiki/Mechanical_energy">mechanical energy</a>, or its kinetic energy plus the potential energy:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%20KE%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%2B%20PE%28%5Cmathbf%7Bq%7D%29%0A" alt="
\mathcal{H}(\mathbf{q},\mathbf{p}) = KE(\mathbf{q},\mathbf{p}) + PE(\mathbf{q})
" title="
\mathcal{H}(\mathbf{q},\mathbf{p}) = KE(\mathbf{q},\mathbf{p}) + PE(\mathbf{q})
" /><br /></p>
<p>Which makes a lot of intuitive sense, because you might recall that total mechanical energy is always conserved for certain types of systems. Incidentally, Hamiltonian dynamics makes sure that the value of the system’s Hamiltonian stays the same (because it moves along contour lines). So, the system’s Hamiltonian always stays the same, and so its total mechanical energy stays the same, as well! Energy is conserved because the Hamiltonian stays the same!</p>
<p>Anyway, we want to build our system’s Hamiltonian from properties of the coordinate system, so plugging in our expression for <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?KE" alt="KE" title="KE" />, we get <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cdot%7B%5Cmathbf%7Bq%7D%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%5ET%20%5Chat%7BK%7D%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%2B%20PE%28%5Cmathbf%7Bq%7D%29" alt="\mathcal{H}(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}} + PE(\mathbf{q})" title="\mathcal{H}(\mathbf{q},\dot{\mathbf{q}}) = \frac{1}{2} \dot{\mathbf{q}}^T \hat{K} \dot{\mathbf{q}} + PE(\mathbf{q})" />.</p>
<p>Oh, but oops, the Hamiltonian has to be a function of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" />, not of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D" alt="\dot{\mathbf{q}}" title="\dot{\mathbf{q}}" />. Let’s remember that <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D" alt="\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}" title="\dot{\mathbf{q}} = \hat{K}^{-1} \mathbf{p}" /> and find the final form of our Hamiltonian (after a bit of simplification, remembering that the inverse of a symmetric matrix is also symmetric):</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%20%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%20%2B%20PE%28%5Cmathbf%7Bq%7D%29%0A" alt="
\mathcal{H}(\mathbf{q},\mathbf{p}) = \frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p} + PE(\mathbf{q})
" title="
\mathcal{H}(\mathbf{q},\mathbf{p}) = \frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p} + PE(\mathbf{q})
" /><br /></p>
<h3 id="hamiltonian-equations">Hamiltonian Equations</h3>
<p>We got our Hamiltonian! Now just to find our updating functions (the partial derivatives of the Hamiltonian), and we’re done with the math.</p>
<p>Because we are assuming the case (with loss of generality) <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?PE" alt="PE" title="PE" /> doesn’t depend on <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" />, the partial derivatives of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D" alt="\mathcal{H}" title="\mathcal{H}" /> with respect to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" /> is:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cnabla_%7B%5Cmathbf%7Bp%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A" alt="
\nabla_{\mathbf{p}} \mathcal{H}(\mathbf{q},\mathbf{p}) = \hat{K}^{-1} \mathbf{p}
" title="
\nabla_{\mathbf{p}} \mathcal{H}(\mathbf{q},\mathbf{p}) = \hat{K}^{-1} \mathbf{p}
" /><br /></p>
<p>We already can calculate <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D%5E%7B-1%7D" alt="\hat{K}^{-1}" title="\hat{K}^{-1}" />, so this wound up being easy peasy. But finding the partial derivatives with respect to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> is a little trickier. The gradient is a linear operator, so we can break that down to just finding the gradient of the <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?KE" alt="KE" title="KE" /> term <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%7D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D" alt="\frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p}" title="\frac{1}{2} \mathbf{p}^T \hat{K}^{-1} \mathbf{p}" />. Because <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp%7D" alt="\mathbf{p}" title="\mathbf{p}" /> is an independent input to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BH%7D" alt="\mathcal{H}" title="\mathcal{H}" />, we can just look at the gradient of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D%5E%7B-1%7D" alt="\hat{K}^{-1}" title="\hat{K}^{-1}" />. We can simplify that even more by realizing that for any invertible matrix <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?A" alt="A" title="A" />, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20A%5E%7B-1%7D%20%3D%20-%20A%5E%7B-1%7D%20%5Cleft%5B%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q%7D%20A%20%5Cright%5D%20A%5E%7B-1%7D" alt="\frac{\partial}{\partial q} A^{-1} = - A^{-1} \left[ \frac{\partial}{\partial q} A \right] A^{-1}" title="\frac{\partial}{\partial q} A^{-1} = - A^{-1} \left[ \frac{\partial}{\partial q} A \right] A^{-1}" />, so now we just need to find the partial derivatives of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D" alt="\hat{K}" title="\hat{K}" />, or <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%7D" alt="\hat{J}_f^T \hat{M} \hat{J}_f}" title="\hat{J}_f^T \hat{M} \hat{J}_f}" />. <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BM%7D" alt="\hat{M}" title="\hat{M}" /> is a constant term, so, using the good ol’ product rule over <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f%5ET" alt="\hat{J}_f^T" title="\hat{J}_f^T" /> and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f" alt="\hat{J}_f" title="\hat{J}_f" />, we see that, after some simplification:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Cleft%5B%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%3D%0A%20%20%20%202%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Cleft%5B%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%0A" alt="
\frac{\partial}{\partial q_i} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right]
" title="
\frac{\partial}{\partial q_i} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right]
" /><br /></p>
<p><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f" alt="\frac{\partial}{\partial q_i} \hat{J}_f" title="\frac{\partial}{\partial q_i} \hat{J}_f" /> (an <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n" alt="m \times n" title="m \times n" /> matrix, like <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ%7D_f" alt="\hat{J}_f" title="\hat{J}_f" />) represents the <em>second derivatives</em> of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" /> – the derivative (with respect to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?q_i" alt="q_i" title="q_i" />) of the derivatives.</p>
<p>The collection of “second-order derivatives of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" />” is known as the <a href="https://en.wikipedia.org/wiki/Hessian_matrix#Vector-valued_functions">Hessian Tensor</a> (a vector-valued generalization of the Hessian matrix), which we will denote as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BH%7D_f" alt="\hat{H}_f" title="\hat{H}_f" />.<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> We can write this in a nicer way by abusing matrix multiplication notation to get</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cleft%5B%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%3D%0A%20%20%20%202%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BH%7D_f%0A" alt="
\nabla_{\mathbf{q}} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \hat{H}_f
" title="
\nabla_{\mathbf{q}} \left[ \hat{J}_f^T \hat{M} \hat{J}_f \right] =
    2 \hat{J}_f^T \hat{M} \hat{H}_f
" /><br /></p>
<p>if we use <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BH%7D_f" alt="\hat{H}_f" title="\hat{H}_f" /> as an <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n%20%5Ctimes%20m%20%5Ctimes%20n" alt="n \times m \times n" title="n \times m \times n" /> tensor, whose <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?n" alt="n" title="n" /> components are the each the <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n" alt="m \times n" title="m \times n" /> matrices corresponding to <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f" alt="\frac{\partial}{\partial q_i} \hat{J}_f" title="\frac{\partial}{\partial q_i} \hat{J}_f" /></p>
<p>And with that, we have our final expression for <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29" alt="\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})" title="\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})" />:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%0A%20%20%20%20-%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Cleft%5B%20%5Cfrac%7B%5Cpartial%7D%7B%5Cpartial%20q_i%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20%2B%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A" alt="
\frac{\partial}{\partial q_i} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
" title="
\frac{\partial}{\partial q_i} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \frac{\partial}{\partial q_i} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
" /><br /></p>
<p>Or, to use our abuse of notation:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%20%3D%0A%20%20%20%20-%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Chat%7BH%7D_f%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20%2B%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A" alt="
\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
" title="
\nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p}) =
    - \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    + \nabla_{\mathbf{q}} PE(\mathbf{q})
" /><br /></p>
<p>And, finally, we have everything we need – we can now construct our equations of motion! To progress through phase space (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Clangle%20%5Cmathbf%7Bq%7D%2C%20%5Cmathbf%7Bp%7D%5Crangle" alt="\langle \mathbf{q}, \mathbf{p}\rangle" title="\langle \mathbf{q}, \mathbf{p}\rangle" />):</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%26%20%3D%20%5Cnabla_%7B%5Cmathbf%7Bp_q%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%0A%20%20%26%26%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%20%5C%5C%0A%5Cdot%7B%5Cmathbf%7Bp%7D%7D%20%26%20%3D%20-%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Cmathcal%7BH%7D%28%5Cmathbf%7Bq%7D%2C%5Cmathbf%7Bp%7D%29%0A%20%20%26%26%20%3D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Chat%7BH%7D_f%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20-%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A%5Cend%7Baligned%7D%0A" alt="
\begin{aligned}
\dot{\mathbf{q}} &amp; = \nabla_{\mathbf{p_q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;&amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp; = - \nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;&amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
" title="
\begin{aligned}
\dot{\mathbf{q}} &amp; = \nabla_{\mathbf{p_q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;&amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp; = - \nabla_{\mathbf{q}} \mathcal{H}(\mathbf{q},\mathbf{p})
  &amp;&amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \hat{H}_f \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
" /><br /></p>
<p>That’s it. We’re done. Have a nice day, thanks for reading!</p>
<h2 id="the-haskell">The Haskell</h2>
<p>Just kidding, now it’s time for the fun stuff :)</p>
<p>Our final goal is to be able to simulate a <em>system of discrete particles</em> through <em>arbitrary generalized coordinates</em>.</p>
<p>To simplify the math, we always assume that, whatever generalized coordinates you are using (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5En" alt="\mathbb{R}^n" title="\mathbb{R}^n" />), your system “actually” exists in some real flat Cartesian coordinate system (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5Em" alt="\mathbb{R}^m" title="\mathbb{R}^m" />). This allows us to take advantage of all of that math we derived in the previous section.</p>
<p>So, in order to fully describe the system, we need:</p>
<ol type="1">
<li>Each of their masses (or inertias) in their underlying <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m" alt="m" title="m" /> Cartesian coordinates, which we’ll call <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bm%7D" alt="\mathbf{m}" title="\mathbf{m}" />.</li>
<li>A function <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em" alt="f : \mathbb{R}^n \rightarrow \mathbb{R}^m" title="f : \mathbb{R}^n \rightarrow \mathbb{R}^m" /> to convert the generalized coordinates (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%5En%7D" alt="\mathbb{R^n}" title="\mathbb{R^n}" />) to Cartesian coordinates (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5Em" alt="\mathbb{R}^m" title="\mathbb{R}^m" />)</li>
<li>The potential energy function <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?U%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D" alt="U : \mathbb{R}^n \rightarrow \mathbb{R}" title="U : \mathbb{R}^n \rightarrow \mathbb{R}" /> in the generalized coordinates (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%5En%7D" alt="\mathbb{R^n}" title="\mathbb{R^n}" />)</li>
</ol>
<p>From these alone, we can derive the equations of motion for the particles in phase space as a system of first-order ODEs using the process described above. Then, given an initial phase space position, we can do numeric integration to simulate our system’s motion through phase space. To “surf the Hamiltonian waves in phase space”, so to speak.</p>
<p>But, to be explicit, we also are going to need some derivatives for these functions/vectors, too. If you’ve been following along, the full enumeration of functions and vectors we need is:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cmathbf%7Bm%7D%20%26%20%3A%20%5Cmathbb%7BR%7D%5Em%20%5C%5C%0Af%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5Em%20%5C%5C%0A%5Chat%7BJ%7D_f%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7Bm%20%5Ctimes%20n%7D%20%5C%5C%0A%5Chat%7BH%7D_f%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5E%7Bn%20%5Ctimes%20m%20%5Ctimes%20n%7D%20%5C%5C%0AU%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%20%5C%5C%0A%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20U%20%26%20%3A%20%5Cmathbb%7BR%7D%5En%20%5Crightarrow%20%5Cmathbb%7BR%7D%5En%0A%5Cend%7Baligned%7D%0A" alt="
\begin{aligned}
\mathbf{m} &amp; : \mathbb{R}^m \\
f &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^m \\
\hat{J}_f &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{m \times n} \\
\hat{H}_f &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{n \times m \times n} \\
U &amp; : \mathbb{R}^n \rightarrow \mathbb{R} \\
\nabla_{\mathbf{q}} U &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^n
\end{aligned}
" title="
\begin{aligned}
\mathbf{m} &amp; : \mathbb{R}^m \\
f &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^m \\
\hat{J}_f &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{m \times n} \\
\hat{H}_f &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^{n \times m \times n} \\
U &amp; : \mathbb{R}^n \rightarrow \mathbb{R} \\
\nabla_{\mathbf{q}} U &amp; : \mathbb{R}^n \rightarrow \mathbb{R}^n
\end{aligned}
" /><br /></p>
<p>But, as we’ll see, with libraries like <em><a href="http://hackage.haskell.org/package/ad">ad</a></em> in Haskell, we can really just ask the user for <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bm%7D" alt="\mathbf{m}" title="\mathbf{m}" />, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?f" alt="f" title="f" />, and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?U" alt="U" title="U" /> – all of the derivatives can be computed automatically.</p>
<h3 id="our-data-structures">Our Data Structures</h3>
<p>We can couple together all of these functions in a data type that fully describes the physics of our systems (the “shape” of the Hamiltonian):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L26-L33</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">System</span> m n <span class="fu">=</span> <span class="dt">System</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    {<span class="ot"> sysInertia       ::</span> <span class="dt">R</span> m                         <span class="co">-- ^ &#39;m&#39; vector</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    ,<span class="ot"> sysCoords        ::</span> <span class="dt">R</span> n <span class="ot">-&gt;</span> <span class="dt">R</span> m                  <span class="co">-- ^ f</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    ,<span class="ot"> sysJacobian      ::</span> <span class="dt">R</span> n <span class="ot">-&gt;</span> <span class="dt">L</span> m n                <span class="co">-- ^ J_f</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    ,<span class="ot"> sysHessian       ::</span> <span class="dt">R</span> n <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> n (<span class="dt">L</span> m n)   <span class="co">-- ^ H_f</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    ,<span class="ot"> sysPotential     ::</span> <span class="dt">R</span> n <span class="ot">-&gt;</span> <span class="dt">Double</span>               <span class="co">-- ^ U</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    ,<span class="ot"> sysPotentialGrad ::</span> <span class="dt">R</span> n <span class="ot">-&gt;</span> <span class="dt">R</span> n                  <span class="co">-- ^ grad U</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    }</a></code></pre></div>
<p><code>R n</code> and <code>L m n</code> are from the <em><a href="http://hackage.haskell.org/package/hmatrix">hmatrix</a></em> library; an <code>R n</code> represents an n-vector (For example, an <code>R 4</code> is a 4-vector), and an <code>L m n</code> represents an <code>m x n</code> matrix (For example, an <code>L 5 3</code> is a 5x3 matrix).</p>
<p>A <code>System m n</code> will describe a system parameterized by <code>n</code> generalized coordinates, taking place in an underlying <code>m</code>-dimensional Cartesian space.</p>
<p>It’ll also be convenient to have a data type to describe the state of our system in terms of its generalized positions (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" />) and generalized velocities (the rates of changes of these positions, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7B%5Cmathbf%7Bq%7D%7D" alt="\dot{\mathbf{q}}" title="\dot{\mathbf{q}}" />), which is sometimes called “configuration space”:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L36-L40</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Config</span> n <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">    {<span class="ot"> confPositions  ::</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    ,<span class="ot"> confVelocities ::</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>And, more importantly, remember that Hamiltonian dynamics is all about surfing around on that phase space (generalized positions <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D" alt="\mathbf{q}" title="\mathbf{q}" /> and their conjugate momenta, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bp_q%7D" alt="\mathbf{p_q}" title="\mathbf{p_q}" />). So let’s make a type to describe the state of our system in phase space:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L43-L47</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Phase</span> n <span class="fu">=</span> <span class="dt">Phase</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    {<span class="ot"> phasePositions ::</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    ,<span class="ot"> phaseMomenta   ::</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    }</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<h3 id="getting-comfortable-with-our-data-types">Getting comfortable with our data types</h3>
<p>First of all, assuming we can construct a <code>System</code> in a sound way, let’s imagine some useful functions.</p>
<p>We can write a function <code>underlyingPosition</code>, which allows you to give a position in generalized coordinates, and returns the position in the “underlying coordinate system”:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L52-L56</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">underlyingPosition</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">System</span> m n</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">R</span> m</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">underlyingPosition <span class="fu">=</span> sysCoords</a></code></pre></div>
<p>Note that the types in our function helps us know exactly what the function is doing — and also helps us implement it correctly. If we have a <code>System</code> in <code>n</code> dimensions, over an underlying <code>m</code>-dimensional Cartesian space, then we would need to convert an <code>R n</code> (an n-dimensional vector of all of the positions) into an <code>R m</code> (a vector in the underlying Cartesian space).</p>
<p>Simple enough, but let’s maybe try to calculate something more complicated: the <em>momenta</em> of a system, given its positions and velocities (configuration).</p>
<p>We remember that we have a nice formula for that, up above:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cmathbf%7Bp%7D%20%3D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f%20%5Cdot%7B%5Cmathbf%7Bq%7D%7D%0A" alt="
\mathbf{p} = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
" title="
\mathbf{p} = \hat{J}_f^T \hat{M} \hat{J}_f \dot{\mathbf{q}}
" /><br /></p>
<p>We can translate that directly into Haskell code:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L60-L68</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">momenta</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">System</span> m n</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Config</span> n</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">momenta s (<span class="dt">Config</span> q v) <span class="fu">=</span> tr j <span class="fu">#&gt;</span> mHat <span class="fu">#&gt;</span> j <span class="fu">#&gt;</span> v</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    j    <span class="fu">=</span> sysJacobian s q</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    mHat <span class="fu">=</span> diag (sysInertia s)</a></code></pre></div>
<p>Note that, because our vectors have their size indexed in their type, this is pretty simple to write and ensure that the shapes “line up”. In fact, GHC can even help you write this function by telling you what values can go in what locations. Being able to get rid of a large class of bugs and clean up your implementation space is nice, too!</p>
<p>(Note that <em>hmatrix</em> requires a <code>KnownNat</code> constraint on the size parameters of our vectors for some functions, so we add this as a constraint on our end.)</p>
<p>With this, we can write a function to convert any state in configuration space to its coordinates in phase space:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L71-L76</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">toPhase</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">System</span> m n</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Config</span> n</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Phase</span> n</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">toPhase s c <span class="fu">=</span> <span class="dt">Phase</span> (confPositions c) (momenta s c)</a></code></pre></div>
<p>This function is important, because “configuration space” is how we actually directly observe our system – in terms of positions and velocities, and not in terms of positions and momenta (and sometimes conjugate momenta might not even have meaningful physical interpretations). So, having <code>toPhase</code> lets us “initialize” our system in terms of direct observables, and then convert it to its phase space representation, which is something that Hamiltonian mechanics can work with.</p>
<h3 id="automatic-differentiation">Automatic Differentiation</h3>
<p>Now, creating a <code>System</code> “from scratch” is not much fun, because you would have to manually differentiate your coordinate systems and potentials to generate your Jacobians and gradients.</p>
<p>Here’s where the magic comes in – we can have Haskell generate our Jacobians and gradients <em>automatically</em>, using the amazing <a href="http://hackage.haskell.org/package/ad">ad</a> library! We can just use the appropriately named <code>grad</code>, <code>jacobian</code>, and <code>hessianF</code> functions.</p>
<h4 id="quick-intro-to-ad">Quick Intro to AD</h4>
<p>At the simplest level, if we have a function from some number to some other number, we can use <code>diff</code> to get its derivative:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">myFunc      ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">diff<span class="ot"> myFunc ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>If we have a function a function from a sized vector to a scalar, we can use <code>grad</code> to get its gradient:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- import qualified Data.Vector.Sized as V</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">myFunc      ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">grad<span class="ot"> myFunc ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> n a</a></code></pre></div>
<p>Where each of the components in the resulting vector corresponds to the rate of change of the output according to variations in that component.</p>
<p>We’re using <strong>statically sized vector</strong> type from the <a href="http://hackage.haskell.org/package/vector-sized">vector-sized</a> package (in the <a href="http://hackage.haskell.org/package/vector-sized/docs/Data-Vector-Sized.html">Data.Vector.Sized</a> module), where <code>V.Vector n a</code> is a <code>n</code>-vector of <code>a</code>s – for example, a <code>V.Vector 3 Double</code> is a vector of 3 <code>Double</code>s.</p>
<p>We have to use <code>Vector</code> (instead of <code>R</code>, from <em>hmatrix</em>) because automatic differentiation for gradients requires <em>some Functor</em> to work. An <code>R 5</code> is essentially a <code>V.Vector 5 Double</code>, except the latter can contain other, non-Double things – and therefore can be used by <em>ad</em> to do its magic.</p>
<p>If we have a function from a sized vector to a (differently) sized vector, we can use the <code>jacobian</code> function to get its jacobian!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">myFunc          ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> m a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">jacobian<span class="ot"> myFunc ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> m (<span class="dt">V.Vector</span> n a)</a></code></pre></div>
<p>Again note the usage of sized vector types, and the fact that our <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n" alt="m \times n" title="m \times n" /> matrix is represented by a <code>m</code>-vector of <code>n</code>-vectors.</p>
<p>Finally, we can get our Hessian Tensor by using <code>hessianF</code>:<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">myFunc</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">    ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> m a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">hessianF myFunc</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> m (<span class="dt">V.Vector</span> n (<span class="dt">V.Vector</span> n a))</a></code></pre></div>
<h4 id="conversion-between-vector-sized-and-hmatrix">Conversion between vector-sized and hmatrix</h4>
<p>Just a small hiccup — the <em>ad</em> libraries requires our vectors to be <em>Functors</em>, but <code>R</code> and <code>L</code> from <em>hmatrix</em> are not your typical capital-F <code>Functor</code> instances in Haskell. We just need to do some manual conversion using the <em><a href="http://hackage.haskell.org/package/hmatrix-vector-sized">hmatrix-vector-sized</a></em> library.</p>
<p>This gives functions like:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">-- import qualified Data.Vector.Sorable.Sized as VS</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">vecR  ::</span> <span class="dt">VS.Vector</span> n <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">R</span> n</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">rVec  ::</span> <span class="dt">R</span> n                <span class="ot">-&gt;</span> <span class="dt">VS.Vector</span> n <span class="dt">Double</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">rowsL ::</span> <span class="dt">V.Vector</span> m (<span class="dt">R</span> n)   <span class="ot">-&gt;</span> <span class="dt">L</span> m n</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="ot">lRows ::</span> <span class="dt">L</span> m n              <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> m (<span class="dt">R</span> n)</a></code></pre></div>
<p>to allow us to convert back and forth.</p>
<p>Also, even though <em>ad</em> gives our Hessian as an <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n%20%5Ctimes%20n" alt="m \times n \times n" title="m \times n \times n" /> tensor, we really want it as a n-vector of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?m%20%5Ctimes%20n" alt="m \times n" title="m \times n" /> matrices – that’s how we interpreted it in our original math. So we just need to write an function to convert what <em>ad</em> gives us to the form we expect. Just a minor reshuffling:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L79-L83</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">tr2 ::</span> (<span class="dt">KnownNat</span> m, <span class="dt">KnownNat</span> n)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> m (<span class="dt">L</span> n n)</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> n (<span class="dt">L</span> m n)</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">tr2 <span class="fu">=</span> fmap rowsL <span class="fu">.</span> traverse lRows</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="ot">{-# INLINE tr2 #-}</span></a></code></pre></div>
<p>We also would need to have a function converting a vector of vectors into a matrix:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L86-L90</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">vec2l</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="ot">    ::</span> <span class="dt">V.Vector</span> m (<span class="dt">V.Vector</span> n <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">L</span> m n</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">vec2l <span class="fu">=</span> rowsL <span class="fu">.</span> fmap (vecR <span class="fu">.</span> VG.convert)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="ot">{-# INLINE vec2l #-}</span></a></code></pre></div>
<h4 id="using-ad-to-auto-derive-systems">Using AD to Auto-Derive Systems</h4>
<p>Now to make a <code>System</code> using just the mass vector, the coordinate conversion function, and the potential energy function:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L94-L111</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">mkSystem</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">KnownNat</span> m, <span class="dt">KnownNat</span> n)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">R</span> m</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="ot">-&gt;</span> (forall a<span class="fu">.</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> m a)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="ot">-&gt;</span> (forall a<span class="fu">.</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> n a <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    <span class="ot">-&gt;</span> <span class="dt">System</span> m n</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">mkSystem m f u <span class="fu">=</span> <span class="dt">System</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">                    <span class="co">-- &lt; convert from      | actual thing | convert to &gt;</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    { sysInertia       <span class="fu">=</span>                     m</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    , sysCoords        <span class="fu">=</span> vecR <span class="fu">.</span> cFrom      <span class="fu">.</span> f            <span class="fu">.</span> cTo <span class="fu">.</span> rVec</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">    , sysJacobian      <span class="fu">=</span> tr   <span class="fu">.</span> vec2l      <span class="fu">.</span> jacobianT f  <span class="fu">.</span> cTo <span class="fu">.</span> rVec</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">    , sysHessian       <span class="fu">=</span> tr2  <span class="fu">.</span> fmap vec2l <span class="fu">.</span> hessianF f   <span class="fu">.</span> cTo <span class="fu">.</span> rVec</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">    , sysPotential     <span class="fu">=</span>                     u            <span class="fu">.</span> cTo <span class="fu">.</span> rVec</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">    , sysPotentialGrad <span class="fu">=</span> vecR <span class="fu">.</span> cFrom      <span class="fu">.</span> grad u       <span class="fu">.</span> cTo <span class="fu">.</span> rVec</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">    }</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19">    cTo   <span class="fu">=</span> VG.convert</a>
<a class="sourceLine" id="cb14-20" data-line-number="20">    cFrom <span class="fu">=</span> VG.convert</a></code></pre></div>
<p>Now, I hesitate to call this “trivial”…but, I think it really is a straightforward direct translation of the definitions, minus some boilerplate conversions back and forth between vector using <code>VG.convert</code>, <code>vecR</code>, etc.!</p>
<ol type="1">
<li>The vector of masses is just <code>m</code></li>
<li>The coordinate function is just <code>f</code></li>
<li>The Jacobian of the coordinate function is just <code>jacobian f</code></li>
<li>The Hessian Tensor of the coordinate function is just <code>hessianF f</code></li>
<li>The potential energy function is just <code>u</code></li>
<li>The gradient of the potential energy function is just <code>grad u</code></li>
</ol>
<p>The <em>ad</em> library automatically generated all of these for us and created a perfectly well-formed <code>System</code> with all of its gradients and Jacobians and Hessians by giving only the coordinate function and the potential energy function, and in such a clean and concise way!</p>
<h3 id="equations-of-motion">Equations of Motion</h3>
<p>At this point, we’re ready to write our final equations of motion, which we found to be given by:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cdot%7B%5Cmathbf%7Bq%7D%7D%20%26%20%3D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%20%5C%5C%0A%5Cdot%7B%5Cmathbf%7Bp%7D%7D%20%26%20%3D%20%5Cmathbf%7Bp%7D%5ET%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%0A%20%20%20%20%20%20%20%20%5Cleft%5B%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20%5Chat%7BJ%7D_f%20%5Cright%5D%20%5Chat%7BK%7D%5E%7B-1%7D%20%5Cmathbf%7Bp%7D%0A%20%20%20%20-%20%5Cnabla_%7B%5Cmathbf%7Bq%7D%7D%20PE%28%5Cmathbf%7Bq%7D%29%0A%5Cend%7Baligned%7D%0A" alt="
\begin{aligned}
\dot{\mathbf{q}} &amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \nabla_{\mathbf{q}} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
" title="
\begin{aligned}
\dot{\mathbf{q}} &amp; = \hat{K}^{-1} \mathbf{p} \\
\dot{\mathbf{p}} &amp; = \mathbf{p}^T \hat{K}^{-1} \hat{J}_f^T \hat{M}
        \left[ \nabla_{\mathbf{q}} \hat{J}_f \right] \hat{K}^{-1} \mathbf{p}
    - \nabla_{\mathbf{q}} PE(\mathbf{q})
\end{aligned}
" /><br /></p>
<p>These equations aren’t particularly beautiful, but it’s straightforward to translate them into Haskell (using <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D%20%3D%20%5Chat%7BJ%7D_f%5ET%20%5Chat%7BM%7D%20%5Chat%7BJ%7D_f" alt="\hat{K} = \hat{J}_f^T \hat{M} \hat{J}_f" title="\hat{K} = \hat{J}_f^T \hat{M} \hat{J}_f" />):</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L115-L132</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">hamilEqns</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">System</span> m n</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Phase</span> n</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    <span class="ot">-&gt;</span> (<span class="dt">R</span> n, <span class="dt">R</span> n)       <span class="co">-- dq/dt and dp/dt</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">hamilEqns s (<span class="dt">Phase</span> q p) <span class="fu">=</span> (dqdt, dpdt)</a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    j       <span class="fu">=</span> sysJacobian s q</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    trj     <span class="fu">=</span> tr j</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    mHat    <span class="fu">=</span> diag (sysInertia s)</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    kHat    <span class="fu">=</span> trj <span class="ot">`mul`</span> mHat <span class="ot">`mul`</span> j</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    kHatInv <span class="fu">=</span> inv kHat</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">    dqdt    <span class="fu">=</span> kHatInv <span class="fu">#&gt;</span> p</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">    dpdt    <span class="fu">=</span> vecR (VG.convert bigUglyThing) <span class="fu">-</span> sysPotentialGrad s q</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-18" data-line-number="18">        bigUglyThing <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19">          fmap (\j2 <span class="ot">-&gt;</span> <span class="fu">-</span>p <span class="fu">&lt;.&gt;</span> kHatInv <span class="fu">#&gt;</span> trj <span class="fu">#&gt;</span> mHat <span class="fu">#&gt;</span> j2 <span class="fu">#&gt;</span> kHatInv <span class="fu">#&gt;</span> p)</a>
<a class="sourceLine" id="cb15-20" data-line-number="20">               (sysHessian s q)</a></code></pre></div>
<p>Of course, there is no way to get around the big ugly math term in <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bp%7D_q" alt="\dot{p}_q" title="\dot{p}_q" />, but at least it is a direct reading of the math!</p>
<p><em>But!!</em> I’d much rather write this scary Haskell than that scary math, because <em>ghc typechecks our math</em>! When writing out those equations, we really had no idea if we were writing it correctly, and if the matrix and vector and tensor dimensions line up. If it even <em>made sense</em> to multiply and transpose the quantities we had.</p>
<p>However, when writing <code>hamilEqns</code>, we let GHC <em>hold our hand for us</em>. If any of our math is wrong, GHC will verify it for us! If any dimensions don’t match up, or any transpositions don’t make sense, we’ll know immediately. And if we’re ever lost, we can leave a <em><a href="https://wiki.haskell.org/GHC/Typed_holes">typed hole</a></em> – then GHC will tell you all of the values in scope that can <em>fit</em> in that hole! Even if you don’t completely understand the math, this helps you implement it in a somewhat confident way.</p>
<p>It’s admittedly difficult to convey how helpful these sized vector types are without working through trying to implement them yourself, so feel free to give it a try when you get the chance! :D</p>
<h3 id="numerical-integration">Numerical Integration</h3>
<p>The result of <code>hamilEqns</code> gives the rate of change of the components of our <code>Phase n</code>. The rest of the processes then is just to “step” <code>Phase n</code>. Gradually update it, following these rate of changes!</p>
<p>This process is known as <a href="https://en.wikipedia.org/wiki/Numerical_integration">numerical integration</a>. The “best” way to do it is quite a big field, so for this article we’re going to be using the extremely extremely simple <a href="https://en.wikipedia.org/wiki/Euler_method">Euler method</a> to progress our system through time.</p>
<p>Disclaimer – The Euler method is typically a <strong>very very bad</strong> choice for numerical integration (even though, as popularized in the movie <em>Hidden Figures</em>, it was good enough to <a href="http://www.latimes.com/science/sciencenow/la-sci-sn-hidden-figures-katherine-johnson-20170109-story.html">send humans to space?</a>). We are just choosing it for this article because it’s very simple, conceptually!</p>
<p>The basic idea is that you pick a time-step, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5CDelta%20t" alt="\Delta t" title="\Delta t" />, and update each coordinate as:</p>
<p><br /><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%0Ax%28t%20%2B%20%5CDelta%20t%29%20%3D%20x%28t%29%20%2B%20%5Cdot%7Bx%7D%28t%29%20%5CDelta%20t%0A" alt="
x(t + \Delta t) = x(t) + \dot{x}(t) \Delta t
" title="
x(t + \Delta t) = x(t) + \dot{x}(t) \Delta t
" /><br /></p>
<p>Which makes sense visually if we imagine <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D" alt="\dot{x}" title="\dot{x}" /> as the “slope” of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?x" alt="x" title="x" /> – it just means to follow the slope another <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5CDelta%20t" alt="\Delta t" title="\Delta t" /> steps. If the slope stays constant, this method is perfectly accurate. The inaccuracy, of course, happens when the slope changes drastically within that <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5CDelta%20t" alt="\Delta t" title="\Delta t" /> (and also from the fact that small errors cause errors in the new calculations of <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D" alt="\dot{x}" title="\dot{x}" />, and so compound over time)</p>
<p>You can understand this symbolically, as well, by remembering that the derivative can be approximated by <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cdot%7Bx%7D%28t%29%20%5Capprox%20%5Cfrac%7Bx%28t%20%2B%20%5CDelta%20t%29%20-%20x%28t%29%7D%7B%5CDelta%20t%7D" alt="\dot{x}(t) \approx \frac{x(t + \Delta t) - x(t)}{\Delta t}" title="\dot{x}(t) \approx \frac{x(t + \Delta t) - x(t)}{\Delta t}" /> for small <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5CDelta%20t" alt="\Delta t" title="\Delta t" />, and so we can do a little bit of symbolic manipulation to get <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?x%28t%20%2B%20%5CDelta%20t%29%20%5Capprox%20%5Cdot%7Bx%7D%28t%29%20%5CDelta%20t%20%2B%20x%28t%29" alt="x(t + \Delta t) \approx \dot{x}(t) \Delta t + x(t)" title="x(t + \Delta t) \approx \dot{x}(t) \Delta t + x(t)" />.</p>
<p>We can directly translate this into Haskell: (using <code>konst :: KnownNat n =&gt; Double -&gt; R n</code>, making a constant vector, and <code>*</code>, the component-wise product of two vectors)</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L135-L143</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">stepEuler</a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m)</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">System</span> m n       <span class="co">-- ^ the system</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Double</span>           <span class="co">-- ^ dt</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Phase</span> n          <span class="co">-- ^ q(t) and p(t)</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">    <span class="ot">-&gt;</span> <span class="dt">Phase</span> n          <span class="co">-- ^ q(t + dt) and p(t + dt)</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">stepEuler s dt ph<span class="fu">@</span>(<span class="dt">Phase</span> q p) <span class="fu">=</span> <span class="dt">Phase</span> (q <span class="fu">+</span> konst dt <span class="fu">*</span> dq) (p <span class="fu">+</span> konst dt <span class="fu">*</span> dp)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">    (dq, dp) <span class="fu">=</span> hamilEqns s ph</a></code></pre></div>
<p>And repeatedly evolve this system as a lazy list:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L146-L154</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">runSystem</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="ot">    ::</span> (<span class="dt">KnownNat</span> n, <span class="dt">KnownNat</span> m)</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    <span class="ot">=&gt;</span> <span class="dt">System</span> m n       <span class="co">-- ^ the system</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    <span class="ot">-&gt;</span> <span class="dt">Double</span>           <span class="co">-- ^ dt</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    <span class="ot">-&gt;</span> <span class="dt">Phase</span> n          <span class="co">-- ^ initial phase</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">    <span class="ot">-&gt;</span> [<span class="dt">Phase</span> n]        <span class="co">-- ^ progression of the system using Euler integration</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">runSystem s dt <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb17-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    go p0 <span class="fu">=</span> p0 <span class="fu">:</span> go (stepEuler s dt p0)</a></code></pre></div>
<h2 id="running-with-it">Running with it</h2>
<p>And…that’s it! Granted, in real life, we would be using a less naive integration method, but this is essentially the entire process!</p>
<p>Let’s generate the boring system, a 5kg particle in 2D Cartesian Coordinates under gravity –</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L157-L163</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="ot">simpleSystem ::</span> <span class="dt">System</span> <span class="dv">2</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">simpleSystem <span class="fu">=</span> mkSystem (vec2 <span class="dv">5</span> <span class="dv">5</span>) id pot</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    <span class="co">-- potential energy of a gravity field</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    <span class="co">-- U(x,y) = 9.8 * y</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">    pot ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> <span class="dv">2</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    pot xy <span class="fu">=</span> <span class="fl">9.8</span> <span class="fu">*</span> (xy <span class="ot">`V.index`</span> <span class="dv">1</span>)</a></code></pre></div>
<p>If we initialize the particle at position <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bq%7D_0%20%3D%20%5Clangle%200%2C%200%20%5Crangle" alt="\mathbf{q}_0 = \langle 0, 0 \rangle" title="\mathbf{q}_0 = \langle 0, 0 \rangle" /> and velocity <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Cmathbf%7Bv%7D_0%20%3D%20%5Clangle%201%2C%203%20%5Crangle" alt="\mathbf{v}_0 = \langle 1, 3 \rangle" title="\mathbf{v}_0 = \langle 1, 3 \rangle" /> (that is, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?v_x%20%3D%201" alt="v_x = 1" title="v_x = 1" /> and <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?v_y%20%3D%203" alt="v_y = 3" title="v_y = 3" />), we should see something that travels at a constant velocity in x and something that starts moving “upwards” (in positive y) and eventually reaches a peak and moves downwards.</p>
<p>We can make our initial configuration:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L167-L171</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="ot">simpleConfig0 ::</span> <span class="dt">Config</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">simpleConfig0 <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    { confPositions  <span class="fu">=</span> vec2 <span class="dv">0</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">    , confVelocities <span class="fu">=</span> vec2 <span class="dv">1</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">    }</a></code></pre></div>
<p>And then…let it run!</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L173-L177</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">simpleMain ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">simpleMain <span class="fu">=</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    mapM_ (disp <span class="dv">2</span> <span class="fu">.</span> phasePositions)  <span class="co">-- position with 2 digits of precision</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">  <span class="fu">.</span> take <span class="dv">25</span>                          <span class="co">-- 25 steps</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">  <span class="fu">$</span> runSystem simpleSystem <span class="fl">0.1</span> (toPhase simpleSystem simpleConfig0)</a></code></pre></div>
<p>We get:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>l Hamilton.hs</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">ghci<span class="fu">&gt;</span> simpleMain</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="dv">0</span>     <span class="dv">0</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="fl">0.10</span>  <span class="fl">0.30</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5"><span class="fl">0.20</span>  <span class="fl">0.58</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="fl">0.30</span>  <span class="fl">0.84</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7"><span class="fl">0.40</span>  <span class="fl">1.08</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="fl">0.50</span>  <span class="fl">1.30</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="fl">0.60</span>  <span class="fl">1.51</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="fl">0.70</span>  <span class="fl">1.69</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11"><span class="fl">0.80</span>  <span class="fl">1.85</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12"><span class="fl">0.90</span>  <span class="fl">1.99</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13"><span class="fl">1.00</span>  <span class="fl">2.12</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14"><span class="fl">1.10</span>  <span class="fl">2.22</span></a>
<a class="sourceLine" id="cb21-15" data-line-number="15"><span class="fl">1.20</span>  <span class="fl">2.31</span></a>
<a class="sourceLine" id="cb21-16" data-line-number="16"><span class="fl">1.30</span>  <span class="fl">2.37</span></a>
<a class="sourceLine" id="cb21-17" data-line-number="17"><span class="fl">1.40</span>  <span class="fl">2.42</span></a>
<a class="sourceLine" id="cb21-18" data-line-number="18"><span class="fl">1.50</span>  <span class="fl">2.44</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19"><span class="fl">1.60</span>  <span class="fl">2.45</span></a>
<a class="sourceLine" id="cb21-20" data-line-number="20"><span class="fl">1.70</span>  <span class="fl">2.43</span></a>
<a class="sourceLine" id="cb21-21" data-line-number="21"><span class="fl">1.80</span>  <span class="fl">2.40</span></a>
<a class="sourceLine" id="cb21-22" data-line-number="22"><span class="fl">1.90</span>  <span class="fl">2.35</span></a>
<a class="sourceLine" id="cb21-23" data-line-number="23"><span class="fl">2.00</span>  <span class="fl">2.28</span></a>
<a class="sourceLine" id="cb21-24" data-line-number="24"><span class="fl">2.10</span>  <span class="fl">2.18</span></a>
<a class="sourceLine" id="cb21-25" data-line-number="25"><span class="fl">2.20</span>  <span class="fl">2.07</span></a>
<a class="sourceLine" id="cb21-26" data-line-number="26"><span class="fl">2.30</span>  <span class="fl">1.94</span></a>
<a class="sourceLine" id="cb21-27" data-line-number="27"><span class="fl">2.40</span>  <span class="fl">1.79</span></a></code></pre></div>
<p>Exactly what we’d expect! The <code>x</code> positions increase steadily, and the <code>y</code> positions increase, slow down, and start decreasing.</p>
<p>We can try a slightly more complicated example that validates (and justifies) all of the work we’ve done – let’s simulate a simple pendulum. The state of a pendulum is characterized by one coordinate <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta" alt="\theta" title="\theta" />, which refers to the angular (clockwise) from the equilibrium “hanging straight down” position. <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta%20%3D%200" alt="\theta = 0" title="\theta = 0" /> corresponds to 6 o’ clock, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta%20%3D%20%5Cpi%2F2" alt="\theta = \pi/2" title="\theta = \pi/2" /> corresponds to 9 o’ clock, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta%20%3D%20-%20%5Cpi%20%2F%202" alt="\theta = - \pi / 2" title="\theta = - \pi / 2" /> corresponds to 3 o’ clock, etc. For a pendulum of length <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?l" alt="l" title="l" />, we can translate that as <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Clangle%20x%2C%20y%20%5Crangle%20%3D%20%5Clangle%20-%20l%20sin%28%5Ctheta%29%2C%20-%20l%20cos%28%5Ctheta%29%20%5Crangle" alt="\langle x, y \rangle = \langle - l sin(\theta), - l cos(\theta) \rangle" title="\langle x, y \rangle = \langle - l sin(\theta), - l cos(\theta) \rangle" />.</p>
<p>Let’s set up that system! We’ll put it under normal gravity potential, again (<img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?U%28x%2Cy%29%20%3D%209.8%20y" alt="U(x,y) = 9.8 y" title="U(x,y) = 9.8 y" />). Our initial position <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta_0" alt="\theta_0" title="\theta_0" /> will be at equilibrium, and our initial angular velocity <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?v_%7B%5Ctheta%200%7D" alt="v_{\theta 0}" title="v_{\theta 0}" /> will be 0.1 radians/sec (clockwise), as we try to induce harmonic motion:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">-- source: https://github.com/mstksg/inCode/tree/master/code-samples/hamilton1/Hamilton.hs#L180-L207</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="co">-- | A pendulum system, parameterized by its angle clockwise from</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="co">-- equilibrium</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">pendulum ::</span> <span class="dt">System</span> <span class="dv">2</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">pendulum <span class="fu">=</span> mkSystem (vec2 <span class="dv">5</span> <span class="dv">5</span>) coords pot      <span class="co">-- 5kg particle</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">    <span class="co">-- &lt;x,y&gt; = &lt;-0.5 sin(theta), -0.5 cos(theta)&gt;</span></a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    <span class="co">-- pendulum of length 0.25</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10"><span class="ot">    coords ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> <span class="dv">1</span> a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dv">2</span> a</a>
<a class="sourceLine" id="cb22-11" data-line-number="11">    coords (V.head<span class="ot">-&gt;</span>theta) <span class="fu">=</span> V.fromTuple (<span class="fu">-</span> <span class="fl">0.25</span> <span class="fu">*</span> sin theta, <span class="fu">-</span> <span class="fl">0.25</span> <span class="fu">*</span> cos theta)</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">    <span class="co">-- potential energy of gravity field</span></a>
<a class="sourceLine" id="cb22-13" data-line-number="13">    <span class="co">-- U(x,y) = 9.8 * y</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14"><span class="ot">    pot ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> <span class="dv">1</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">    pot q <span class="fu">=</span> <span class="fl">9.8</span> <span class="fu">*</span> (coords q <span class="ot">`V.index`</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb22-16" data-line-number="16"></a>
<a class="sourceLine" id="cb22-17" data-line-number="17"><span class="ot">pendulumConfig0 ::</span> <span class="dt">Config</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">pendulumConfig0 <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">    { confPositions  <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb22-20" data-line-number="20">    , confVelocities <span class="fu">=</span> <span class="fl">0.1</span></a>
<a class="sourceLine" id="cb22-21" data-line-number="21">    }</a>
<a class="sourceLine" id="cb22-22" data-line-number="22"></a>
<a class="sourceLine" id="cb22-23" data-line-number="23"><span class="ot">pendulumMain ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb22-24" data-line-number="24">pendulumMain <span class="fu">=</span></a>
<a class="sourceLine" id="cb22-25" data-line-number="25">    mapM_ (disp <span class="dv">3</span> <span class="fu">.</span> phasePositions)  <span class="co">-- position with 2 digits of precision</span></a>
<a class="sourceLine" id="cb22-26" data-line-number="26">  <span class="fu">.</span> take <span class="dv">25</span>                          <span class="co">-- 25 steps</span></a>
<a class="sourceLine" id="cb22-27" data-line-number="27">  <span class="fu">$</span> runSystem pendulum <span class="fl">0.1</span> (toPhase pendulum pendulumConfig0)</a></code></pre></div>
<p>This pendulum should wobble back and forth, ever so slightly, around equilibrium.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">ghci<span class="fu">&gt;</span> <span class="fu">:</span>l Hamilton.hs</a>
<a class="sourceLine" id="cb23-2" data-line-number="2">ghci<span class="fu">&gt;</span> pendulumMain</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="dv">0</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="fl">0.010</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="fl">0.020</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="fl">0.029</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="fl">0.037</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="fl">0.042</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="fl">0.045</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10"><span class="fl">0.044</span></a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="fl">0.040</span></a>
<a class="sourceLine" id="cb23-12" data-line-number="12"><span class="fl">0.032</span></a>
<a class="sourceLine" id="cb23-13" data-line-number="13"><span class="fl">0.021</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14"><span class="fl">0.007</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15"><span class="fu">-</span><span class="fl">0.008</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16"><span class="fu">-</span><span class="fl">0.023</span></a>
<a class="sourceLine" id="cb23-17" data-line-number="17"><span class="fu">-</span><span class="fl">0.038</span></a>
<a class="sourceLine" id="cb23-18" data-line-number="18"><span class="fu">-</span><span class="fl">0.051</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19"><span class="fu">-</span><span class="fl">0.061</span></a>
<a class="sourceLine" id="cb23-20" data-line-number="20"><span class="fu">-</span><span class="fl">0.068</span></a>
<a class="sourceLine" id="cb23-21" data-line-number="21"><span class="fu">-</span><span class="fl">0.069</span></a>
<a class="sourceLine" id="cb23-22" data-line-number="22"><span class="fu">-</span><span class="fl">0.065</span></a>
<a class="sourceLine" id="cb23-23" data-line-number="23"><span class="fu">-</span><span class="fl">0.056</span></a>
<a class="sourceLine" id="cb23-24" data-line-number="24"><span class="fu">-</span><span class="fl">0.041</span></a>
<a class="sourceLine" id="cb23-25" data-line-number="25"><span class="fu">-</span><span class="fl">0.022</span></a>
<a class="sourceLine" id="cb23-26" data-line-number="26"><span class="fu">-</span><span class="fl">0.000</span></a>
<a class="sourceLine" id="cb23-27" data-line-number="27"><span class="fl">0.023</span></a></code></pre></div>
<p>We see our <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Ctheta" alt="\theta" title="\theta" /> coordinate increasing, then turning around and decreasing, swinging the other way past equilibrium, and then turning around and heading back!<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a></p>
<p>We <em>automatically generated equations of motion for a pendulum</em>. Sweet!</p>
<h2 id="wrap-up">Wrap-Up</h2>
<p>We traveled through the world of physics, math, Haskell, and back again to achieve something that would have initially seemed like a crazy thought experiment. But, utilizing Hamiltonian mechanics, we have a system that can automatically generate equations of motion given your coordinate system and a potential energy function. We also learned how to leverage typed vectors for more correct code and a smoother development process.</p>
<p>See my <a href="https://blog.jle.im/entry/introducing-the-hamilton-library.html">previous post</a> for even crazier examples – involving multiple objects, double pendulums, and more. And check out my <a href="http://hackage.haskell.org/package/hamilton">hamilton</a> library on hackage, which includes demos for exotic interesting systems, rendered graphically on your terminal.</p>
<p>I realize that this was a lot, so if you have any questions or suggestions for clarifications, feel free to leave a comment, drop me a <a href="https://twitter.com/mstk" title="Twitter">tweet</a>, or find me on the freenode <em>#haskell</em> channel (where I usually idle as <em>jle`</em>!)</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The picture with a time-dependent Hamiltonian is different, but only slightly. In the time-dependent case, the system still <em>tries</em> to move along contour lines at every point in time, but the mountain is constantly changing underneath it and the contour lines keep on shifting underneath it. Sounds like life!<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>There’s also another perpendicular vector, <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Clangle%20-y%2C%20x%20%5Crangle" alt="\langle -y, x \rangle" title="\langle -y, x \rangle" />, which actually gives motion <em>backwards</em> in time.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>Disclaimer: I am not a surfer.<a href="#fnref3" class="footnote-back">↩</a></p></li>
<li id="fn4"><p><img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BJ_f%7D" alt="\hat{J_f}" title="\hat{J_f}" /> is full-rank (meaning <img style="vertical-align:middle" src="https://latex.codecogs.com/png.latex?%5Chat%7BK%7D" alt="\hat{K}" title="\hat{K}" /> is invertible) if its rows are linearly independent. This should be the case as you don’t have any redundant or duplicate coordinates in your general coordinate system.<a href="#fnref4" class="footnote-back">↩</a></p></li>
<li id="fn5"><p>Thanks to Edward Kmett for <a href="http://disq.us/p/1o4oyqh">pointing this out</a>!<a href="#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p><code>hessian</code> computes the Hessian Matrix for scalar-valued function, but here, we have a vector-valued function, so we need <code>hessianF</code>, the Hessian <em>Tensor</em>.<a href="#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>Clearly our system is gaining some sort of phantom energy, since it rises up to 0.045 on the left, and then all the way up to -0.69 on the right. Rest assured that this is simply from the inaccuracies in Euler’s Method.<a href="#fnref7" class="footnote-back">↩</a></p></li>
</ol>
</section></div><footer><hr><div class="copy-content"><p>Hi, thanks for reading! You can reach me via email at <a href="mailto:justin@jle.im">justin@jle.im</a>, or at twitter at <a href="https://twitter.com/mstk">@mstk</a>! This post and all others are published under the <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/">CC-BY-NC-ND 3.0</a> license. Corrections and edits via pull request are welcome and encouraged at <a href="https://github.com/mstksg/inCode">the source repository</a>.</p>
<p>If you feel inclined, or this post was particularly helpful for you, why not consider <a href="https://www.patreon.com/justinle/overview">supporting me on Patreon</a>, or a <a href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">BTC donation</a>? :)</p></div><div class="clear"></div><ul class="entry-series"><li><div>This entry is a part of a series called <b>&quot;Hamilton&quot;</b>.  Find the rest of the entries in this series at its <a href="https://blog.jle.im/entries/series/+hamilton.html" class="tag-a-series" title="+Hamilton"> series history</a>.</div></li></ul><ul class="tag-list"><li><a href="https://blog.jle.im/entries/tagged/dependent-types.html" class="tag-a-tag">#dependent types</a></li><li><a href="https://blog.jle.im/entries/tagged/functional-programming.html" class="tag-a-tag">#functional programming</a></li><li><a href="https://blog.jle.im/entries/tagged/haskell.html" class="tag-a-tag">#haskell</a></li><li><a href="https://blog.jle.im/entries/tagged/numerical-methods.html" class="tag-a-tag">#numerical methods</a></li><li><a href="https://blog.jle.im/entries/tagged/physics.html" class="tag-a-tag">#physics</a></li><li><a href="https://blog.jle.im/entries/category/@haskell.html" class="tag-a-category">@HASKELL</a></li><li><a href="https://blog.jle.im/entries/series/+hamilton.html" class="tag-a-series">+Hamilton</a></li></ul><aside class="social-buttons"><div class="addthis_toolbox addthis_default_style addthis-buttons"><a class="addthis_button_facebook_like" fb:like:layout="button_count"></a><a class="addthis_button_tweet"></a><a class="addthis_button_google_plusone" g:plusone:size="medium"></a><a class="addthis_counter addthis_pill_style"></a></div><div class="custom-social-buttons"><div class="custom-social-button"><a href="https://www.reddit.com/submit" onclick="window.location = &#39;https://www.reddit.com/submit?url=&#39;+ encodeURIComponent(window.location); return false"><img src="https://www.reddit.com/static/spreddit7.gif" alt="submit to reddit"></a></div></div></aside><nav class="next-prev-links"><ul><li class="prev-entry-link">&larr; <a href="https://blog.jle.im/entry/fixed-length-vector-types-in-haskell.html">Fixed-Length Vector Types in Haskell (an Update for 2017)</a> (Previous)</li><li class="next-entry-link">(Next) <a href="https://blog.jle.im/entry/advent-of-code-2017.html">Advent of Code 2017! Ongoing solutions and explanations</a> &rarr;</li></ul></nav></footer></article><div class="post-entry"><div class="tile"><div id="disqus_thread"></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://blog.jle.im/entry/hamiltonian-dynamics-in-haskell.html';
    this.page.identifier = 'hamilton-1';
};
(function() {
    var d = document, s = d.createElement('script');
    s.src = '//incode.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a><br></noscript><a href="http://disqus.com" class="dsq-brlink">Comments powered by <span class="logo-disqus">Disqus</span></a></div></div></div></div></div><div id="footer-container"><div id="footer-content"><div class="tile"><div class="footer-copyright">&copy; 2018 Justin Le <span class="license-link">(<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/" class="license">CC-BY-NC-ND 3.0</a>)</span></div><div class="footer-follow social-follows"><ul class="social-follows-list"><li><ul class="social-follows-list-social"><li><a class="social-follow-twitter" title="Follow me on Twitter!" href="https://twitter.com/intent/user?user_id=mstk" onclick="window.open(
  &#39;http://twitter.com/intent/user?user_id=907281&#39;,
  &#39;facebook-share-dialog&#39;,
  &#39;width=550,height=520&#39;);
return false;
">Twitter</a></li><li><a class="social-follow-github" title="Fork me on Github!" href="https://github.com/mstksg">Github</a></li><li><a class="social-follow-twitch" title="Watch me on Twitch!" href="https://www.twitch.tv/mstksg">Twitch</a></li><li><a class="social-follow-patreon" title="Support me on Patreon!" href="https://www.patreon.com/justinle/overview">Patreon</a></li><li><a class="social-follow-gplus" title="Add me on Google+!" href="https://plus.google.com/+JustinLe">Google+</a></li><li><a class="social-follow-keybase" title="Track me on Keybase!" href="https://keybase.io/mstksg">Keybase</a></li><li><a class="social-follow-linkedin" title="Connect with me on LinkedIn!" href="https://linkedin.com/in/lejustin">LinkedIn</a></li><li><a class="social-follow-bitcoin" title="Donate via bitcoin!" href="bitcoin:3D7rmAYgbDnp4gp4rf22THsGt74fNucPDU">Bitcoin</a></li></ul></li><li><ul class="social-follows-list-site"><li><a class="social-follow-rss" title="Subscribe to my RSS Feed!" href="http://feeds.feedburner.com/incodeblog">RSS</a></li><li><a class="social-follow-email" title="Subscribe to the mailing list!" href="https://feedburner.google.com/fb/a/mailverify?loc=en_US&amp;uri=incodeblog">Mailing list</a></li></ul></li></ul></div></div></div></div></body></html>