<?xml version="1.0" encoding="UTF-8"?><rss dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>in Code — Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
</description><item><title>Shuffling things up: Applying Group Theory in Advent of Code</title><link>https://blog.jle.im/entry/shuffling-things-up.html</link><description>&lt;p&gt;So it’s November, and &lt;a href=&#34;https://adventofcode.com/&#34;&gt;Advent of Code&lt;/a&gt; season is in the air! It’s time for everyone’s favorite Santa-based light hearted learn-to-program-or-a-new-language holiday season programming challenge series. Every year a bunch of us gather around the fireplace, roast chestnuts, and brainstorm all of the interesting ways we can solve these cute themed puzzles every day. These puzzles are designed to accessible enough for most new programmers, but deep enough to provide entertainment for experienced ones. I’ve &lt;a href=&#34;https://blog.jle.im/entries/tagged/advent-of-code.html&#34;&gt;written many blog posts&lt;/a&gt; on some of the interesting insight some of the puzzles have yielded, and I also &lt;a href=&#34;https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md&#34;&gt;post my reflections on as many puzzles I can&lt;/a&gt; while solving them in Haskell. And if you’re solving things in Haskell, I also published an &lt;a href=&#34;https://hackage.haskell.org/package/advent-of-code-api&#34;&gt;open-sourced rate-limited API library&lt;/a&gt; so you can fetch and submit answers from the comfort of your command line.&lt;/p&gt;
&lt;p&gt;To kick off the season, I’ve decided to write about one of my favorite puzzles from Advent of Code 2019 – &lt;a href=&#34;https://adventofcode.com/2019/day/22&#34;&gt;Day 22: Slam Shuffle&lt;/a&gt;. To me, it stands out because it’s a perfect example of how Haskell’s approach to mathematical abstraction nudges you into the direction of an efficient solution — in a way that other languages would obscure or make less obvious.&lt;/p&gt;
&lt;p&gt;So, let’s dive in! In the end, hopefully this post can get you excited for this wonderful season, and maybe also shed some insight into what it means when we say that Haskell can help you leverage math to find good solutions to your real problems.&lt;/p&gt;
&lt;p&gt;Of course, this post has spoilers for Advent of Code 2019 Day 22, if you are planning on trying to figure it out from yourself. If you haven’t tried it, I recommend you give it a shot and come back after! :D&lt;/p&gt;
&lt;h2 id=&#34;slam-shuffle&#34;&gt;Slam Shuffle&lt;/h2&gt;
&lt;p&gt;If you haven’t already, take some time to &lt;a href=&#34;https://adventofcode.com/2019/day/22&#34;&gt;read through the problem statement&lt;/a&gt;. The basic idea is that we are given a series of operations to “shuffle” a deck of 10007 cards, such as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deal with increment 7
deal into new stack
deal into new stack
... etc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After performing all of the many operations, the question then asks about the card at a given position (the 2019th card in the deck).&lt;/p&gt;
&lt;p&gt;Part 2, which you might not be able to see if you haven’t submitted an answer yet for Part 1, involves the same process with a deck of 119315717514047 cards, and repeating the entire shuffling sequence 101741582076661 times. It then asks you to find the card that ends up at index 2020.&lt;/p&gt;
&lt;p&gt;In this problem, it seems we have a list of “shuffles” that we want to run on a deck of cards. However, let’s think about this in a more data-driven approach: instead of thinking about successive shufflings of cards, let’s imagine the specification of a “shuffle” itself as our main data, and how we can combine shuffle operations together into new shuffle operations.&lt;/p&gt;
&lt;p&gt;We are looking for “take shuffle A and shuffle B, and return a new shuffle that represents doing B, then A”. This is “shuffle composition”, or “permutation composition” (&lt;a href=&#34;https://en.wikipedia.org/wiki/Permutation&#34;&gt;permutation&lt;/a&gt; being the mathematical word for “shuffling” here, basically)&lt;/p&gt;
&lt;p&gt;Since we’ve identified that we want to begin implementing a way of composing/combining permutations together, we can do a bit of reading to learn that one of the most famous properties of permutation composition is that they form a “group”, which means they can be composed (associatively), have an identity, and can be inverted. This means that if you have two permutations, you can “squish” them to create a new permutation, and work with that &lt;em&gt;new&lt;/em&gt; permutation.&lt;/p&gt;
&lt;p&gt;I’ve talked about &lt;a href=&#34;https://blog.jle.im/entry/alchemical-groups.html&#34;&gt;using group theory&lt;/a&gt; principles before in this blog to help guide us towards solutions and optimizations — the main principle is that if we express our program in terms of group operations, then we can take advantage of the large body of knowledge built up over centuries to understand, analyze, and potentially optimize our program.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;first&lt;/em&gt; big advantage in this situation is that we can treat our transformations &lt;em&gt;as data&lt;/em&gt;, and not as functions. And that if we have two transformations, we can always create a new one (just a normal data type value) that represents the composition of the two original ones.&lt;/p&gt;
&lt;h2 id=&#34;now-youre-thinking-with-groups&#34;&gt;Now You’re Thinking With Groups&lt;/h2&gt;
&lt;p&gt;Knowing permutations are a group, it means that once we settle on our representation of them, &lt;code&gt;Perm&lt;/code&gt;, we can write an instance of &lt;code&gt;Perm&lt;/code&gt; for &lt;code&gt;Semigroup&lt;/code&gt;, &lt;code&gt;Monoid&lt;/code&gt;, and &lt;code&gt;Group&lt;/code&gt;, abstractions in Haskell that many types are already instances of. Abstractions like &lt;code&gt;Semigroup&lt;/code&gt; and &lt;code&gt;Monoid&lt;/code&gt; are pretty much an everyday thing in Haskell, so this fits in quite nicely. &lt;code&gt;Group&lt;/code&gt; comes from the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/groups&#34;&gt;groups&lt;/a&gt;&lt;/em&gt; package, which also provides some nice applications of group theory.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;co&#34;&gt;-- let&amp;#39;s figure out the implementation later, where n is the number of cards&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Haskell, we express things like “&lt;code&gt;Perm&lt;/code&gt; is a Semigroup/Monoid/Group” by saying that they are instances of &lt;em&gt;typeclasses&lt;/em&gt;, which (for this purpose) are like interfaces in languages like Java.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | An instance m can be &amp;quot;combined&amp;quot; using `x &amp;lt;&amp;gt; y`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; m &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    (&amp;lt;&amp;gt;) ::&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | There is always an identity element for &amp;lt;&amp;gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- x &amp;lt;&amp;gt; mempty == x&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- mempty &amp;lt;&amp;gt; x == x&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; m &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    mempty ::&lt;/span&gt; m&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Every m has an inverse:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-15&#34;&gt;&lt;a href=&#34;#cb3-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- x &amp;lt;&amp;gt; invert x == mempty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-16&#34;&gt;&lt;a href=&#34;#cb3-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- invert x &amp;lt;&amp;gt; x == mempty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-17&#34;&gt;&lt;a href=&#34;#cb3-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-18&#34;&gt;&lt;a href=&#34;#cb3-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; m &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-19&#34;&gt;&lt;a href=&#34;#cb3-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    invert ::&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that if &lt;code&gt;Perm&lt;/code&gt; is an instance of &lt;code&gt;Group&lt;/code&gt; (which has superclasses &lt;code&gt;Semigroup&lt;/code&gt; and &lt;code&gt;Monoid&lt;/code&gt;), we can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compose permutations using &lt;code&gt;x &amp;lt;&amp;gt; y&lt;/code&gt;, which means “shuffle with strategy &lt;code&gt;y&lt;/code&gt;, then with strategy &lt;code&gt;x&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;Summon an “identity permutation” where &lt;code&gt;x &amp;lt;&amp;gt; mempty == x&lt;/code&gt; (the identity permutation, which is “leave things alone”).&lt;/li&gt;
&lt;li&gt;Invert any shuffling (if we have &lt;code&gt;x&lt;/code&gt;, we can reverse its effect with &lt;code&gt;invert x&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, the standard libraries also give us a useful function &lt;code&gt;stimes&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;stimes ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which lets us compose &lt;code&gt;x&lt;/code&gt; with itself (&lt;code&gt;stimes 5 x == x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x&lt;/code&gt;), but can do it in &lt;em&gt;log(n)&lt;/em&gt; time using &lt;a href=&#34;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&#34;&gt;repeated squaring&lt;/a&gt;. It’s extremely efficient in a lot of circumstances (more on that later) — more so than the naive compose-it-n-times implementation. This will definitely become useful in part 2, where we have to do 101741582076661 compositions.&lt;/p&gt;
&lt;h2 id=&#34;our-gameplan&#34;&gt;Our Gameplan&lt;/h2&gt;
&lt;p&gt;Just &lt;em&gt;knowing&lt;/em&gt; that permutations form a group naturally guides us to these abstractions — we already know what &lt;em&gt;interface&lt;/em&gt; our type will have, even before we write any code. We know that no matter &lt;em&gt;what&lt;/em&gt; our implementation of permutation will be, we will have &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;stimes&lt;/code&gt;, &lt;code&gt;mempty&lt;/code&gt;, &lt;code&gt;invert&lt;/code&gt; available to us to use. So, let’s do just that! We’ll use a stub data type &lt;code&gt;Perm&lt;/code&gt; to represent our permutation and “pretend” we have that interface on it. We’ll write our functions first and then fill in the interface later!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Represents a permutation of n cards&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;....&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Given a permutation, find the place where a given index ends up.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runPerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-7&#34;&gt;&lt;a href=&#34;#cb5-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Parse a string line into the permutation it represents&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-8&#34;&gt;&lt;a href=&#34;#cb5-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parsePerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb5-9&#34;&gt;&lt;a href=&#34;#cb5-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-10&#34;&gt;&lt;a href=&#34;#cb5-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Given a permutation list, find the place where 2019 ends up&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-11&#34;&gt;&lt;a href=&#34;#cb5-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part1 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-12&#34;&gt;&lt;a href=&#34;#cb5-12&#34;&gt;&lt;/a&gt;part1 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm bigPerm &lt;span class=&#34;dv&#34;&gt;2019&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-13&#34;&gt;&lt;a href=&#34;#cb5-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-14&#34;&gt;&lt;a href=&#34;#cb5-14&#34;&gt;&lt;/a&gt;    bigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;mconcat perms&lt;/code&gt; composes all of the permutations one after another: &lt;code&gt;mconcat [x,y,z] = x &amp;lt;&amp;gt; y &amp;lt;&amp;gt; z&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;And…that’s it! For the actual “logic” of our part 1! All we need to do is implement &lt;code&gt;runPerm&lt;/code&gt; and &lt;code&gt;parsePerm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here, I’m using &lt;code&gt;Finite n&lt;/code&gt; from the great &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/finite-typelits&#34;&gt;finite-typelits&lt;/a&gt;&lt;/em&gt; library, where &lt;code&gt;Finite 100&lt;/code&gt; represents “an index between 0 and 99”, etc. It’s just exactly the right “shape” to represent the index of a deck of cards. &lt;em&gt;finite-typelits&lt;/em&gt; wasn’t designed with group theory in mind, but it’s still a great tool here — which is a testament to how flexible these abstractions can actually be :)&lt;/p&gt;
&lt;p&gt;For example, it means that for a &lt;code&gt;Perm 10007&lt;/code&gt; (a permutation of 10007 cards), the type of &lt;code&gt;runPerm&lt;/code&gt; is &lt;code&gt;Perm 10007 -&amp;gt; Finite 10007 -&amp;gt; Finite 10007&lt;/code&gt;, and the type of &lt;code&gt;parsePerm&lt;/code&gt; is &lt;code&gt;String -&amp;gt; Perm 10007&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can plan out our part 2 as well:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Given a permutation list, find the index that will end up at 2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part2 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;part2 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm (invert biiigPerm) &lt;span class=&#34;dv&#34;&gt;2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    bigPerm   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;    biiigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; stimes &lt;span class=&#34;dv&#34;&gt;101741582076661&lt;/span&gt; bigPerm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Part 2, I think, is where the group theory really shines.&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;We take advantage of &lt;code&gt;stimes&lt;/code&gt;, which uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&#34;&gt;repeated squaring&lt;/a&gt;. That means that to compute &lt;code&gt;stimes 8 x&lt;/code&gt;, instead of using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;it does&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let x2 = x &amp;lt;&amp;gt; x
    x4 = x2 &amp;lt;&amp;gt; x2
in  x4 &amp;lt;&amp;gt; x4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;essentially cutting down the number of multiplications exponentially. This means that to compute &lt;code&gt;stimes 101741582076661&lt;/code&gt;, we only need to do about 47 multiplications (log base 2), and not 101741582076661.&lt;/p&gt;
&lt;p&gt;This is only possible because we know that permutation composition is associative, so it doesn’t matter how we associate our parentheses. It is only “safe” to use repeated squaring if you &lt;em&gt;know&lt;/em&gt; that your operation is associative. Having a semigroup abstraction &lt;em&gt;in the first place&lt;/em&gt; guides us to this efficient solution — in a way that is pre-built just for us! This is made all the more powerful because &lt;em&gt;semigroup&lt;/em&gt; is a ubiquitous abstraction in Haskell, so we “think about” it all the time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remember how &lt;code&gt;runPerm p 2019&lt;/code&gt; gives us the index that &lt;code&gt;2019&lt;/code&gt; is sent to? Well, we want something else in this case. We basically want the index that &lt;em&gt;will be sent to&lt;/em&gt; &lt;code&gt;2020&lt;/code&gt;. So, we want to &lt;em&gt;reverse the function&lt;/em&gt;. Luckily, since our function is just a permutation, it is easy to reverse this: just &lt;code&gt;invert&lt;/code&gt; the permutation!&lt;/p&gt;
&lt;p&gt;The idea that we can simply invert a permutation instead of having to write a whole new permutation representation just to do “backwards indexing” is something that we are &lt;em&gt;guided to&lt;/em&gt;, just by recognizing that permutations form a group.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;a-first-guess-at-implementation&#34;&gt;A first guess at implementation&lt;/h2&gt;
&lt;p&gt;Now, time to do what we have been putting off and actually write our permutation representation – the definition of &lt;code&gt;Perm n&lt;/code&gt;. A good &lt;em&gt;first guess&lt;/em&gt; might be to write our permutation as an actual function — a function from index to index, &lt;code&gt;Finite n -&amp;gt; Finite n&lt;/code&gt;. Then, we can just use function composition as our permutation composition.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runPerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;runPerm (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; f) x  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; f x&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parsePerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb9-7&#34;&gt;&lt;a href=&#34;#cb9-7&#34;&gt;&lt;/a&gt;parsePerm str &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;words&lt;/span&gt; str &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-8&#34;&gt;&lt;a href=&#34;#cb9-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb9-9&#34;&gt;&lt;a href=&#34;#cb9-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; i&lt;/span&gt;
&lt;span id=&#34;cb9-10&#34;&gt;&lt;a href=&#34;#cb9-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb9-11&#34;&gt;&lt;a href=&#34;#cb9-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-12&#34;&gt;&lt;a href=&#34;#cb9-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-13&#34;&gt;&lt;a href=&#34;#cb9-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; g)     &lt;span class=&#34;co&#34;&gt;-- apply g, then apply x&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-14&#34;&gt;&lt;a href=&#34;#cb9-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-15&#34;&gt;&lt;a href=&#34;#cb9-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;mempty&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-16&#34;&gt;&lt;a href=&#34;#cb9-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-17&#34;&gt;&lt;a href=&#34;#cb9-17&#34;&gt;&lt;/a&gt;    invert (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; f) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;?????&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;Finite n&lt;/code&gt;’s &lt;code&gt;Num&lt;/code&gt; instance is modular arithmetic, so things like &lt;code&gt;negate&lt;/code&gt; and multiplication will “do the right thing”. We use &lt;code&gt;modulo&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;modulo ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which “reads” an &lt;code&gt;Integer&lt;/code&gt; into a &lt;code&gt;Finite n&lt;/code&gt;, making sure to wrap it in a cyclic way if it is negative or too high. &lt;code&gt;maxBound&lt;/code&gt; also gives us the highest index (the highest &lt;code&gt;Finite n&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; modulo &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;finite &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; modulo &lt;span class=&#34;dv&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;finite &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-5&#34;&gt;&lt;a href=&#34;#cb11-5&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; modulo (&lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-6&#34;&gt;&lt;a href=&#34;#cb11-6&#34;&gt;&lt;/a&gt;finite &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;KnownNat&lt;/code&gt; instance is a constraint that &lt;code&gt;modulo&lt;/code&gt; needs in order to know what quotient to modulo into.&lt;/p&gt;
&lt;p&gt;This implementation &lt;em&gt;seems&lt;/em&gt; to work, except for one apparent major problem: how do we write &lt;code&gt;invert&lt;/code&gt;? Also, &lt;code&gt;stimes&lt;/code&gt; doesn’t help us &lt;em&gt;too&lt;/em&gt; much here, because repeated squaring of function composition is…still a lot of function compositions in the end.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; So, while composition with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is cheap, application with &lt;code&gt;runPerm&lt;/code&gt; is expensive (and &lt;code&gt;stimes&lt;/code&gt; works best when composition is expensive and application is cheap). So, back to the drawing board.&lt;/p&gt;
&lt;h2 id=&#34;a-second-implementation-attempt-lookin-affine-today&#34;&gt;A Second Implementation Attempt: Lookin’ Affine Today&lt;/h2&gt;
&lt;p&gt;If we look carefully at &lt;code&gt;parsePerm&lt;/code&gt;, we might start to see a pattern in all of our permutations. In fact, they all seem to follow the same form:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They all seem to be some “scaling” and “adding” of &lt;code&gt;i&lt;/code&gt;. If we align things up, this becomes a little more clear:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;                &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;               &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;  modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n) &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; i&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of these seems to be some sort of scaling-and-adding of &lt;code&gt;i&lt;/code&gt;…also known as an &lt;a href=&#34;https://en.wikipedia.org/wiki/Affine_transformation&#34;&gt;Affine Transformation&lt;/a&gt;, but modulo some cyclic rotation.&lt;/p&gt;
&lt;p&gt;Well…affine transformations on cyclic indices are a subset of permutations in general. More importantly, we know (after some googling) that they are also &lt;em&gt;closed with respect to composition and inversion&lt;/em&gt; … which means that they are, themselves, a group! Maybe we can represent this as our permutation type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L16-L28&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; aScale ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-5&#34;&gt;&lt;a href=&#34;#cb14-5&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; aShift ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-6&#34;&gt;&lt;a href=&#34;#cb14-6&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb14-7&#34;&gt;&lt;a href=&#34;#cb14-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-8&#34;&gt;&lt;a href=&#34;#cb14-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runPerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-9&#34;&gt;&lt;a href=&#34;#cb14-9&#34;&gt;&lt;/a&gt;runPerm (&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b) x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; a &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; x &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb14-10&#34;&gt;&lt;a href=&#34;#cb14-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-11&#34;&gt;&lt;a href=&#34;#cb14-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parseAffine ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-12&#34;&gt;&lt;a href=&#34;#cb14-12&#34;&gt;&lt;/a&gt;parseAffine str &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;words&lt;/span&gt; str &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-13&#34;&gt;&lt;a href=&#34;#cb14-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt;                &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;  (&lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n))&lt;/span&gt;
&lt;span id=&#34;cb14-14&#34;&gt;&lt;a href=&#34;#cb14-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt;        (&lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)          &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-15&#34;&gt;&lt;a href=&#34;#cb14-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; (modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n))                 &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is “defunctionalization”: if we notice a pattern in our functions, we can instead abstract out the data that defines each instance of that pattern, and work with that data instead.&lt;/p&gt;
&lt;p&gt;So far so good! Now to think about how to define composition.&lt;/p&gt;
&lt;p&gt;If we want to do &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?f%28x%29%20%3D%20a%27%20x%20%2B%20b%27&#34; alt=&#34;f(x) = a&amp;#39; x + b&amp;#39;&#34; title=&#34;f(x) = a&amp;#39; x + b&amp;#39;&#34; /&gt; after &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?g%28x%29%20%3D%20a%20x%20%2B%20b&#34; alt=&#34;g(x) = a x + b&#34; title=&#34;g(x) = a x + b&#34; /&gt;, it’s:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%28f%20%5Ccirc%20g%29%28x%29%20%26%20%3D%20a%27%20%28a%20x%20%2B%20b%29%20%2B%20b%27%5C%5C%0A%20%20%28f%20%5Ccirc%20g%29%28x%29%20%26%20%3D%20a%27%20x%20%2B%20a%27%20b%20%2B%20b%27%0A%5Cend%7Baligned%7D%0A&#34; alt=&#34;
\begin{aligned}
(f \circ g)(x) &amp;amp; = a&amp;#39; (a x + b) + b&amp;#39;\\
  (f \circ g)(x) &amp;amp; = a&amp;#39; x + a&amp;#39; b + b&amp;#39;
\end{aligned}
&#34; title=&#34;
\begin{aligned}
(f \circ g)(x) &amp;amp; = a&amp;#39; (a x + b) + b&amp;#39;\\
  (f \circ g)(x) &amp;amp; = a&amp;#39; x + a&amp;#39; b + b&amp;#39;
\end{aligned}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;So composing &lt;code&gt;a&#39; x + b&#39;&lt;/code&gt; after &lt;code&gt;a x + b&lt;/code&gt; is is &lt;code&gt;a&#39; a x + a&#39; b + b&#39;&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L30-L31&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; a) (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; b &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; b&amp;#39;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! We can now compose &lt;em&gt;and&lt;/em&gt; run &lt;code&gt;Affine&lt;/code&gt;s efficiently, which makes &lt;code&gt;stimes&lt;/code&gt; useful! And the &lt;code&gt;Num&lt;/code&gt; instance (which requires &lt;code&gt;KnownNat n&lt;/code&gt;) for &lt;code&gt;Finite n&lt;/code&gt; takes care of automatically doing modular arithmetic for us.&lt;/p&gt;
&lt;p&gt;To define a &lt;code&gt;Monoid&lt;/code&gt; instance, we need an identity permutation. This would just leave x alone, so it makes sense that it’s &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?f%28x%29%20%3D%201%20x%20%2B%200&#34; alt=&#34;f(x) = 1 x + 0&#34; title=&#34;f(x) = 1 x + 0&#34; /&gt;, &lt;code&gt;1 x + 0&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L33-L34&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;mempty&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let’s define the inverse, which is a bit trickier.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;    invert (&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;        a&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;co&#34;&gt;-- ??&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;        b&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;co&#34;&gt;-- ??&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Inverting&lt;/em&gt; something means that we want &lt;code&gt;invert p &amp;lt;&amp;gt; p == mempty&lt;/code&gt;. That means we want to find &lt;code&gt;a&#39;&lt;/code&gt; and &lt;code&gt;b&#39;&lt;/code&gt; such that:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From our definition of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; earlier, that means we have to find &lt;code&gt;a&#39;&lt;/code&gt; and &lt;code&gt;b&#39;&lt;/code&gt; where:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; a) (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; b &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; b&amp;#39;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we need &lt;code&gt;a&#39; * a = 1&lt;/code&gt;, and &lt;code&gt;a&#39; * b + b&#39; = 0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To solve &lt;code&gt;a&#39; * a = 1&lt;/code&gt;, we can imagine that cycling &lt;code&gt;a&lt;/code&gt; through the whole deck gets you back to &lt;code&gt;a&lt;/code&gt;. (If &lt;code&gt;n&lt;/code&gt; is prime, then &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a*a&lt;/code&gt;, &lt;code&gt;a*a*a&lt;/code&gt;, etc. will all be unique…so you will keep on getting unique numbers until you exhaust the entire space at &lt;code&gt;a^size&lt;/code&gt; to arrive back at &lt;code&gt;a&lt;/code&gt;) So:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         a^n = a
=&amp;gt; a^(n-1)*a = a    -- definition of exponentiation
=&amp;gt; a^(n-1)   = 1    -- a^(n-1) leaves a unchanged, so it must be 1
=&amp;gt; a^(n-2)*a = 1    -- definition of exponentiation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see that if &lt;code&gt;a&#39; * a = 1&lt;/code&gt;, then &lt;code&gt;a&#39;&lt;/code&gt; must be &lt;code&gt;a^(n-2)&lt;/code&gt; for prime &lt;code&gt;n&lt;/code&gt;.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The second case is a little simpler: we can just shuffle around &lt;code&gt;a&#39; * b + b&#39; = 0&lt;/code&gt; to get &lt;code&gt;b&#39; = -(a&#39; * b)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This gives us everything we need to write &lt;code&gt;invert&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L36-L41&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Group instance only works if n is prime&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-5&#34;&gt;&lt;a href=&#34;#cb21-5&#34;&gt;&lt;/a&gt;    invert (&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39;&lt;/span&gt;
&lt;span id=&#34;cb21-6&#34;&gt;&lt;a href=&#34;#cb21-6&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-7&#34;&gt;&lt;a href=&#34;#cb21-7&#34;&gt;&lt;/a&gt;        a&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; a &lt;span class=&#34;op&#34;&gt;^&lt;/span&gt; (natVal (&lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;n) &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb21-8&#34;&gt;&lt;a href=&#34;#cb21-8&#34;&gt;&lt;/a&gt;        b&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…we’re done! This actually is pretty efficient with repeated squaring (which is how &lt;code&gt;^&lt;/code&gt; is implemented) because we are just squaring numbers. &lt;code&gt;natVal (Proxy @n)&lt;/code&gt; is how to get &lt;code&gt;n&lt;/code&gt; as an integer at the value level so we can use it as the exponent.&lt;/p&gt;
&lt;h2 id=&#34;the-full-implementation&#34;&gt;The Full Implementation&lt;/h2&gt;
&lt;p&gt;Just to close us out, I’ll re-paste the code we planned before, now with the context that we have implemented the appropriate permutation types. We get the &lt;code&gt;[Affine n]&lt;/code&gt;s by using &lt;code&gt;parseAffine&lt;/code&gt; on the &lt;code&gt;lines&lt;/code&gt; of our puzzle input and reversing that list.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L43-L54&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Part 1: Given a permutation list, find the place where 2019 ends up&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part1 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;part1 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm bigPerm &lt;span class=&#34;dv&#34;&gt;2019&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;    bigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-9&#34;&gt;&lt;a href=&#34;#cb22-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Part 2: Given a permutation list, find the index that will end up at 2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-10&#34;&gt;&lt;a href=&#34;#cb22-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part2 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-11&#34;&gt;&lt;a href=&#34;#cb22-11&#34;&gt;&lt;/a&gt;part2 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm (invert biiigPerm) &lt;span class=&#34;dv&#34;&gt;2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-12&#34;&gt;&lt;a href=&#34;#cb22-12&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-13&#34;&gt;&lt;a href=&#34;#cb22-13&#34;&gt;&lt;/a&gt;    bigPerm   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;
&lt;span id=&#34;cb22-14&#34;&gt;&lt;a href=&#34;#cb22-14&#34;&gt;&lt;/a&gt;    biiigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; stimes &lt;span class=&#34;dv&#34;&gt;101741582076661&lt;/span&gt; bigPerm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can load the finished code for this entire challenge &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs&#34;&gt;here&lt;/a&gt;. I’ve also included the sample input string for my advent of code account, and also parsed it conveniently into a list of properly ordered &lt;code&gt;Affine n&lt;/code&gt;s for you to test it yourself:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./advent-shuffle.hs
ghci&amp;gt; part1 myShuffles
finite 6978
ghci&amp;gt; part2 myShuffles
finite 24460989449140&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, Haskell performs these ~47 multiplication steps pretty quickly, and part 2 is only about 3 times slower than part 1 (~40μs vs. ~14μs on my machine).&lt;/p&gt;
&lt;h2 id=&#34;the-big-picture&#34;&gt;The Big Picture&lt;/h2&gt;
&lt;p&gt;Every time I make a post about how Haskell lets you “use” math, there’s a lot of room for confusion and misunderstanding. A common misconception is that you need to know math to use Haskell, or that writing a Haskell program is like solving a math equation.&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Instead, when we say we “use” math in Haskell, it means that Haskell naturally nudges us to phrase our problems in a way that can help illuminate connections to the groundwork that has already been laid for us through centuries of mathematical discoveries — and in many cases, allow us to translate those insights into making helpful improvements and optimizations in our actual code.&lt;/p&gt;
&lt;p&gt;Haskell is “functional programming”, but I think that betrays the major insight here: we got our main conceptual leap when we thought about shuffling not as “a function”, but rather &lt;em&gt;as data&lt;/em&gt;: our shuffle is itself &lt;em&gt;data&lt;/em&gt; (here, integers), and not an “algorithm”. Had we latched onto an algorithmic approach from the beginning, we might have gotten stuck in the mire of finding a way to “optimize an algorithm”. But because we initially started thinking about permutations and shuffles as &lt;em&gt;data structures&lt;/em&gt;, we actually end up thinking about how to most effectively manipulate the data structures themselves. Instead of manipulating the cards, we manipulate the shuffle! We combine and invert the &lt;em&gt;shuffles&lt;/em&gt;, not the cards. And math — especially abstract algebra — is all about different properties of how objects can combine and universal properties about certain operations.&lt;/p&gt;
&lt;p&gt;As we head into this wonderful season, stay safe and happy haskellings, everyone! :D&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;We only allocate a few function pointers (once for each &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, where &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/jwl93i/shuffling_things_up_solving_advent_of_code_with/gcudwg4?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3&#34;&gt;both sides themselves point to the same function pointer&lt;/a&gt;), so it’s very efficient in space as well, but to actually “run” that final function, we need to still traverse all of those nested pointers the full number of times.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;You can also use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm&#34;&gt;Extended Euclidean Algorithm&lt;/a&gt; to find the multiplicative inverse here as well if you are a (cool) nerd. But I wanted to show a way to do this without requiring knowledge of any ring theory.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;As &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/jwl93i/shuffling_things_up_solving_advent_of_code_with/gct4ihy/?context=3&#34;&gt;pointed out by rogercaptain on reddit&lt;/a&gt;, this also “works” in the case where &lt;code&gt;n&lt;/code&gt; is not prime too: only &lt;em&gt;some&lt;/em&gt; (and not all) &lt;code&gt;Affine n&lt;/code&gt;s represent permutations when &lt;code&gt;n&lt;/code&gt; is not prime, and for those specific &lt;code&gt;Affine n&lt;/code&gt;s (namely, where &lt;code&gt;a&lt;/code&gt; is coprime to &lt;code&gt;n&lt;/code&gt;), this technique does work.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Admittedly, we did do that a few times here. But that’s not &lt;em&gt;all&lt;/em&gt; we do :)&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Math</category><guid isPermaLink="true">https://blog.jle.im/entry/shuffling-things-up.html</guid><pubDate>Wed, 18 Nov 2020 18:17:52 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Math</subject><date>2020-11-18</date></item><item><title>Enhancing Functor Structures Step-By-Step (Part 2)</title><link>https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html</link><description>&lt;p&gt;Welcome to Part 2 of the &lt;a href=&#34;https://blog.jle.im/entries/series/+enhancing-functor-structures.html&#34;&gt;“Enhancing Functor Structures” series&lt;/a&gt;! Here we are taking a base structure describing a data type schema and enhancing it step-by-step with new functory capabilities: first, covariant capabilities (to generate parsers), then contravariant capabilities (to generate serializers)…who knows what might be in store next?&lt;/p&gt;
&lt;p&gt;Please do check out &lt;a href=&#34;https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html&#34;&gt;Part 1&lt;/a&gt; if you haven’t already, since this post pretty much jumps straight into things!&lt;/p&gt;
&lt;h2 id=&#34;parsing-and-serializing-invariantly&#34;&gt;Parsing and Serializing Invariantly&lt;/h2&gt;
&lt;p&gt;As we left off our project, we had done three things:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Started with a simple ADT representing the structure we want to be able to express&lt;/li&gt;
&lt;li&gt;Enhanced that simple ADT with Covariant Functor capabilities, in order to interpret it as a parser&lt;/li&gt;
&lt;li&gt;Enhanced that original simple ADT with Contravariant Functor, in order to interpret it as a serializer.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From this, it seems the next logical step would be to add &lt;em&gt;both&lt;/em&gt; enhancements to the same structure!&lt;/p&gt;
&lt;p&gt;There are some clear benefits to this — on the surface, it means we only have to write code once to get all three things (documentation, parsing, and serialization). Less code means less bugs!&lt;/p&gt;
&lt;p&gt;Even deeper, we can now ensure that our “serialization” and “parsing” functions are always “in sync”. If we defined a separate process/type for serializing and a separate process/type for parsing, then it’s possible we might accidentally make errors in keeping them in sync…one might use a different tag, or we might make changes to one but not the other during refactoring. There’s a good chance you have been bitten by situations where documentation becomes out of sync with actual code.&lt;/p&gt;
&lt;h3 id=&#34;adding-invariance&#34;&gt;Adding Invariance&lt;/h3&gt;
&lt;p&gt;Like before, the main thing we need to change at the fundamental level is &lt;code&gt;Primitive&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L39-L42&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)     (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;) (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)       (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re just basically combining the additions we made to enable parsing with the additions we made to enable serialization. Our new &lt;code&gt;Primitive&lt;/code&gt; type gives us the capability to do both!&lt;/p&gt;
&lt;p&gt;We can say this new &lt;code&gt;Primitive&lt;/code&gt; is an &lt;a href=&#34;https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html&#34;&gt;“Invariant” Functor&lt;/a&gt;: these are functors that give you “both” capabilities: interpreting covariantly &lt;em&gt;and&lt;/em&gt; contravariantly.&lt;/p&gt;
&lt;p&gt;Because we must be able to eventually &lt;em&gt;use&lt;/em&gt; either covariant or contravariant interpretation on an invariant functor, the corresponding mapping function takes functions in both ways in order to support both on consumption-time.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Invariant&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    invmap ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;divap-and-decalt&#34;&gt;DivAp and DecAlt&lt;/h3&gt;
&lt;p&gt;By now, we know the drill. We also need to change our &lt;code&gt;RecordType&lt;/code&gt; and &lt;code&gt;SumType&lt;/code&gt; constructors to get the right type of container.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- Covariant Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L25-L29&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- Contravariant Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L21-L24&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb4-6&#34;&gt;&lt;a href=&#34;#cb4-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb4-7&#34;&gt;&lt;a href=&#34;#cb4-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the covariant &lt;code&gt;RecordType&lt;/code&gt;, we used &lt;code&gt;Ap Field a&lt;/code&gt;. For the contravariant &lt;code&gt;RecordType&lt;/code&gt;, we used &lt;code&gt;Div Field a&lt;/code&gt;. Is there a type that combines &lt;em&gt;both&lt;/em&gt; &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;Div&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If we browse around, we see that we have &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DivAp.html&#34;&gt;DivAp&lt;/a&gt;&lt;/em&gt; from the &lt;em&gt;functor-combinatotrs&lt;/em&gt; library…which appears to be named to in a way to invoke the idea of having both &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;Div&lt;/code&gt; capabilities, combined together.&lt;/p&gt;
&lt;p&gt;For the covariant &lt;code&gt;SumType&lt;/code&gt;, we used &lt;code&gt;ListF Choice a&lt;/code&gt;. For the contravariant &lt;code&gt;SumType&lt;/code&gt;, we used &lt;code&gt;Dec Choice a&lt;/code&gt;. Is there a type that combines &lt;em&gt;both&lt;/em&gt; &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If we look nearby &lt;code&gt;DivAp&lt;/code&gt;, we see the answer: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DecAlt.html&#34;&gt;DecAlt&lt;/a&gt;&lt;/em&gt;! It combines both &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;building-an-invariant-schema&#34;&gt;Building an Invariant Schema&lt;/h3&gt;
&lt;p&gt;Let’s wire it up:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L24-L42&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-7&#34;&gt;&lt;a href=&#34;#cb5-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-8&#34;&gt;&lt;a href=&#34;#cb5-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-9&#34;&gt;&lt;a href=&#34;#cb5-9&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-10&#34;&gt;&lt;a href=&#34;#cb5-10&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb5-11&#34;&gt;&lt;a href=&#34;#cb5-11&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb5-12&#34;&gt;&lt;a href=&#34;#cb5-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-13&#34;&gt;&lt;a href=&#34;#cb5-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-14&#34;&gt;&lt;a href=&#34;#cb5-14&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-15&#34;&gt;&lt;a href=&#34;#cb5-15&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb5-16&#34;&gt;&lt;a href=&#34;#cb5-16&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb5-17&#34;&gt;&lt;a href=&#34;#cb5-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-18&#34;&gt;&lt;a href=&#34;#cb5-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-19&#34;&gt;&lt;a href=&#34;#cb5-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)     (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-20&#34;&gt;&lt;a href=&#34;#cb5-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;) (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-21&#34;&gt;&lt;a href=&#34;#cb5-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)       (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Writing a schema using this type is going to be very similar to writing one for our other schema types:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L55-L72&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    swerve (\&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; x y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (x,y); &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;           (&lt;span class=&#34;fu&#34;&gt;uncurry&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb6-7&#34;&gt;&lt;a href=&#34;#cb6-7&#34;&gt;&lt;/a&gt;           &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-8&#34;&gt;&lt;a href=&#34;#cb6-8&#34;&gt;&lt;/a&gt;        (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-9&#34;&gt;&lt;a href=&#34;#cb6-9&#34;&gt;&lt;/a&gt;          { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-10&#34;&gt;&lt;a href=&#34;#cb6-10&#34;&gt;&lt;/a&gt;          , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; gathered&lt;/span&gt;
&lt;span id=&#34;cb6-11&#34;&gt;&lt;a href=&#34;#cb6-11&#34;&gt;&lt;/a&gt;              (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString })&lt;/span&gt;
&lt;span id=&#34;cb6-12&#34;&gt;&lt;a href=&#34;#cb6-12&#34;&gt;&lt;/a&gt;              (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    })&lt;/span&gt;
&lt;span id=&#34;cb6-13&#34;&gt;&lt;a href=&#34;#cb6-13&#34;&gt;&lt;/a&gt;          }&lt;/span&gt;
&lt;span id=&#34;cb6-14&#34;&gt;&lt;a href=&#34;#cb6-14&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;
&lt;span id=&#34;cb6-15&#34;&gt;&lt;a href=&#34;#cb6-15&#34;&gt;&lt;/a&gt;        (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-16&#34;&gt;&lt;a href=&#34;#cb6-16&#34;&gt;&lt;/a&gt;          { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-17&#34;&gt;&lt;a href=&#34;#cb6-17&#34;&gt;&lt;/a&gt;          , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-18&#34;&gt;&lt;a href=&#34;#cb6-18&#34;&gt;&lt;/a&gt;              inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt }&lt;/span&gt;
&lt;span id=&#34;cb6-19&#34;&gt;&lt;a href=&#34;#cb6-19&#34;&gt;&lt;/a&gt;          }&lt;/span&gt;
&lt;span id=&#34;cb6-20&#34;&gt;&lt;a href=&#34;#cb6-20&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main difference is, while &lt;code&gt;decide&lt;/code&gt; expects the &lt;code&gt;a -&amp;gt; Either b c&lt;/code&gt; splitting function, &lt;code&gt;swerve&lt;/code&gt; (the invariant &lt;code&gt;DecAlt&lt;/code&gt; equivalent) expects also the functions to “recombine” the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; back to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;swerve&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c)    &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)             &lt;span class=&#34;co&#34;&gt;-- ^ put the branch back into the original input&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)             &lt;span class=&#34;co&#34;&gt;-- ^ put the branch back into the original input&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; f b           &lt;span class=&#34;co&#34;&gt;-- ^ handle first branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; f c           &lt;span class=&#34;co&#34;&gt;-- ^ handle second branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; f a           &lt;span class=&#34;co&#34;&gt;-- ^ overall handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-8&#34;&gt;&lt;a href=&#34;#cb7-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-9&#34;&gt;&lt;a href=&#34;#cb7-9&#34;&gt;&lt;/a&gt;swerve&lt;/span&gt;
&lt;span id=&#34;cb7-10&#34;&gt;&lt;a href=&#34;#cb7-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-11&#34;&gt;&lt;a href=&#34;#cb7-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ((&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;)              &lt;span class=&#34;co&#34;&gt;-- ^ put the CPerson branch back into a Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-12&#34;&gt;&lt;a href=&#34;#cb7-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;)                        &lt;span class=&#34;co&#34;&gt;-- ^ put the CBusiness branch back into a Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-13&#34;&gt;&lt;a href=&#34;#cb7-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)              &lt;span class=&#34;co&#34;&gt;-- ^ handle CPerson branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-14&#34;&gt;&lt;a href=&#34;#cb7-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;                        &lt;span class=&#34;co&#34;&gt;-- ^ handle CBusiness branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-15&#34;&gt;&lt;a href=&#34;#cb7-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-16&#34;&gt;&lt;a href=&#34;#cb7-16&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-17&#34;&gt;&lt;a href=&#34;#cb7-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- compare to what we used last time:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-18&#34;&gt;&lt;a href=&#34;#cb7-18&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb7-19&#34;&gt;&lt;a href=&#34;#cb7-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-20&#34;&gt;&lt;a href=&#34;#cb7-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)                 &lt;span class=&#34;co&#34;&gt;-- ^ handle CPerson branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-21&#34;&gt;&lt;a href=&#34;#cb7-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;                           &lt;span class=&#34;co&#34;&gt;-- ^ handle CBusiness branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-22&#34;&gt;&lt;a href=&#34;#cb7-22&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We also note that the invariant version of &lt;code&gt;divided&lt;/code&gt; is &lt;code&gt;gathered&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;gathered&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; f a          &lt;span class=&#34;co&#34;&gt;-- ^ first handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; f b          &lt;span class=&#34;co&#34;&gt;-- ^ second handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; f (a, b)     &lt;span class=&#34;co&#34;&gt;-- ^ merged handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;gathered&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpName field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;             &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpAge field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ handle both together&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- compare to what we used last time:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;divided&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpName field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;             &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpAge field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ handle both together&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;using-invariant-schema&#34;&gt;Using Invariant Schema&lt;/h3&gt;
&lt;p&gt;Let’s look into writing our interpreters. Luckily, we already did most of the work in the previous post. Writing &lt;code&gt;schemaDoc&lt;/code&gt;, &lt;code&gt;schemaParser&lt;/code&gt;, and &lt;code&gt;schemaToValue&lt;/code&gt;, we can re-use pretty much all of our code!&lt;/p&gt;
&lt;p&gt;The main (unfortunate) difference is that instead of using &lt;code&gt;interpret&lt;/code&gt; in every case, we must use &lt;code&gt;runCoDivAp&lt;/code&gt; to run our &lt;code&gt;DivAp&lt;/code&gt; in a covariant setting, and &lt;code&gt;runContraDivAp&lt;/code&gt; to run our &lt;code&gt;DivAp&lt;/code&gt; in a contravariant setting (similarly for &lt;code&gt;runCoDecAlt&lt;/code&gt; and &lt;code&gt;runContraDecAlt&lt;/code&gt;).&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L74-L150&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-7&#34;&gt;&lt;a href=&#34;#cb9-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-8&#34;&gt;&lt;a href=&#34;#cb9-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb9-9&#34;&gt;&lt;a href=&#34;#cb9-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-10&#34;&gt;&lt;a href=&#34;#cb9-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-11&#34;&gt;&lt;a href=&#34;#cb9-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb9-12&#34;&gt;&lt;a href=&#34;#cb9-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb9-13&#34;&gt;&lt;a href=&#34;#cb9-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb9-14&#34;&gt;&lt;a href=&#34;#cb9-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-15&#34;&gt;&lt;a href=&#34;#cb9-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-16&#34;&gt;&lt;a href=&#34;#cb9-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-17&#34;&gt;&lt;a href=&#34;#cb9-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb9-18&#34;&gt;&lt;a href=&#34;#cb9-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb9-19&#34;&gt;&lt;a href=&#34;#cb9-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-20&#34;&gt;&lt;a href=&#34;#cb9-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb9-21&#34;&gt;&lt;a href=&#34;#cb9-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-22&#34;&gt;&lt;a href=&#34;#cb9-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-23&#34;&gt;&lt;a href=&#34;#cb9-23&#34;&gt;&lt;/a&gt;    fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb9-24&#34;&gt;&lt;a href=&#34;#cb9-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-25&#34;&gt;&lt;a href=&#34;#cb9-25&#34;&gt;&lt;/a&gt;    choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb9-26&#34;&gt;&lt;a href=&#34;#cb9-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-27&#34;&gt;&lt;a href=&#34;#cb9-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-28&#34;&gt;&lt;a href=&#34;#cb9-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-29&#34;&gt;&lt;a href=&#34;#cb9-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-30&#34;&gt;&lt;a href=&#34;#cb9-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-31&#34;&gt;&lt;a href=&#34;#cb9-31&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-32&#34;&gt;&lt;a href=&#34;#cb9-32&#34;&gt;&lt;/a&gt;schemaParser&lt;/span&gt;
&lt;span id=&#34;cb9-33&#34;&gt;&lt;a href=&#34;#cb9-33&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-34&#34;&gt;&lt;a href=&#34;#cb9-34&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-35&#34;&gt;&lt;a href=&#34;#cb9-35&#34;&gt;&lt;/a&gt;schemaParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-36&#34;&gt;&lt;a href=&#34;#cb9-36&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; runCoDivAp  fieldParser  fs&lt;/span&gt;
&lt;span id=&#34;cb9-37&#34;&gt;&lt;a href=&#34;#cb9-37&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; runCoDecAlt choiceParser cs&lt;/span&gt;
&lt;span id=&#34;cb9-38&#34;&gt;&lt;a href=&#34;#cb9-38&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;
&lt;span id=&#34;cb9-39&#34;&gt;&lt;a href=&#34;#cb9-39&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-40&#34;&gt;&lt;a href=&#34;#cb9-40&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb9-41&#34;&gt;&lt;a href=&#34;#cb9-41&#34;&gt;&lt;/a&gt;    choiceParser (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-42&#34;&gt;&lt;a href=&#34;#cb9-42&#34;&gt;&lt;/a&gt;      tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb9-43&#34;&gt;&lt;a href=&#34;#cb9-43&#34;&gt;&lt;/a&gt;      unless (tag &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; name) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-44&#34;&gt;&lt;a href=&#34;#cb9-44&#34;&gt;&lt;/a&gt;        A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;Tag does not match&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-45&#34;&gt;&lt;a href=&#34;#cb9-45&#34;&gt;&lt;/a&gt;      A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; schemaParser val&lt;/span&gt;
&lt;span id=&#34;cb9-46&#34;&gt;&lt;a href=&#34;#cb9-46&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb9-47&#34;&gt;&lt;a href=&#34;#cb9-47&#34;&gt;&lt;/a&gt;    fieldParser (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.key (T.pack name) (schemaParser val)&lt;/span&gt;
&lt;span id=&#34;cb9-48&#34;&gt;&lt;a href=&#34;#cb9-48&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb9-49&#34;&gt;&lt;a href=&#34;#cb9-49&#34;&gt;&lt;/a&gt;    primParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-50&#34;&gt;&lt;a href=&#34;#cb9-50&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withString &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-51&#34;&gt;&lt;a href=&#34;#cb9-51&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating string&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-52&#34;&gt;&lt;a href=&#34;#cb9-52&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withScientific &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-53&#34;&gt;&lt;a href=&#34;#cb9-53&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating number&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-54&#34;&gt;&lt;a href=&#34;#cb9-54&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withBool &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-55&#34;&gt;&lt;a href=&#34;#cb9-55&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating bool&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-56&#34;&gt;&lt;a href=&#34;#cb9-56&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-57&#34;&gt;&lt;a href=&#34;#cb9-57&#34;&gt;&lt;/a&gt;schemaToValue&lt;/span&gt;
&lt;span id=&#34;cb9-58&#34;&gt;&lt;a href=&#34;#cb9-58&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-59&#34;&gt;&lt;a href=&#34;#cb9-59&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-60&#34;&gt;&lt;a href=&#34;#cb9-60&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-61&#34;&gt;&lt;a href=&#34;#cb9-61&#34;&gt;&lt;/a&gt;schemaToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-62&#34;&gt;&lt;a href=&#34;#cb9-62&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb9-63&#34;&gt;&lt;a href=&#34;#cb9-63&#34;&gt;&lt;/a&gt;                   &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; getOp (runContraDivAp  fieldToValue  fs)&lt;/span&gt;
&lt;span id=&#34;cb9-64&#34;&gt;&lt;a href=&#34;#cb9-64&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; getOp (runContraDecAlt choiceToValue cs)&lt;/span&gt;
&lt;span id=&#34;cb9-65&#34;&gt;&lt;a href=&#34;#cb9-65&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primToValue p&lt;/span&gt;
&lt;span id=&#34;cb9-66&#34;&gt;&lt;a href=&#34;#cb9-66&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-67&#34;&gt;&lt;a href=&#34;#cb9-67&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb9-68&#34;&gt;&lt;a href=&#34;#cb9-68&#34;&gt;&lt;/a&gt;    choiceToValue (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb9-69&#34;&gt;&lt;a href=&#34;#cb9-69&#34;&gt;&lt;/a&gt;      [ &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; T.pack name&lt;/span&gt;
&lt;span id=&#34;cb9-70&#34;&gt;&lt;a href=&#34;#cb9-70&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x&lt;/span&gt;
&lt;span id=&#34;cb9-71&#34;&gt;&lt;a href=&#34;#cb9-71&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb9-72&#34;&gt;&lt;a href=&#34;#cb9-72&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] x&lt;/span&gt;
&lt;span id=&#34;cb9-73&#34;&gt;&lt;a href=&#34;#cb9-73&#34;&gt;&lt;/a&gt;    fieldToValue (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-74&#34;&gt;&lt;a href=&#34;#cb9-74&#34;&gt;&lt;/a&gt;        [T.pack name &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x]&lt;/span&gt;
&lt;span id=&#34;cb9-75&#34;&gt;&lt;a href=&#34;#cb9-75&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-76&#34;&gt;&lt;a href=&#34;#cb9-76&#34;&gt;&lt;/a&gt;    primToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-77&#34;&gt;&lt;a href=&#34;#cb9-77&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.String&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; T.pack &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-78&#34;&gt;&lt;a href=&#34;#cb9-78&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Number&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-79&#34;&gt;&lt;a href=&#34;#cb9-79&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Bool&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And there we have it — a fully functional bidirectional parser schema type that we assembled step-by-step, adding each piece incrementally and exploring the space until we found something useful for us. We have a single schema that can represent documentation, parsing, and serialization in a way that they are all kept in sync, after writing things only once!&lt;/p&gt;
&lt;p&gt;A cute function we could write to tie things together would be one that does a round-trip, serializing and then parsing, to make sure things worked properly.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L152-L156&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;testRoundTrip&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb10-5&#34;&gt;&lt;a href=&#34;#cb10-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb10-6&#34;&gt;&lt;a href=&#34;#cb10-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseError&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb10-7&#34;&gt;&lt;a href=&#34;#cb10-7&#34;&gt;&lt;/a&gt;testRoundTrip sch &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.parseValue (schemaParser sch) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; schemaToValue sch&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; testRoundTrip customerSchema (&lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;40&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; {cpName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt;, cpAge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;40&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looks solid to me!&lt;/p&gt;
&lt;h2 id=&#34;an-alternative-invariant-strategy&#34;&gt;An Alternative Invariant Strategy&lt;/h2&gt;
&lt;p&gt;The thought process “I want to use both &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Ap&lt;/code&gt;, let’s just look for &lt;code&gt;DivAp&lt;/code&gt;” is kind of nice and straightforward. However, there’s a major downside in using &lt;code&gt;DivAp&lt;/code&gt; and &lt;code&gt;DecAlt&lt;/code&gt; that make their ergonomics not so great when building them up.&lt;/p&gt;
&lt;p&gt;A major part about what makes &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;ListF&lt;/code&gt; (and, to an extent, &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt;) so nice to use is that they are instances of popular Haskell typeclasses like &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Alternative&lt;/code&gt; (or &lt;code&gt;Plus&lt;/code&gt;) and using &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Alternative&lt;/code&gt; interfaces are pretty common in Haskell. Because of this, they are pretty comfortable for most Haskellers to use.&lt;/p&gt;
&lt;p&gt;However, &lt;code&gt;DivAp&lt;/code&gt; and &lt;code&gt;DecAlt&lt;/code&gt; aren’t really instances of any commonly used typeclass (aside from &lt;code&gt;Invariant&lt;/code&gt;).&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; So you really don’t have any nice interface for them other than just using functions specifically written for them, like &lt;code&gt;gather&lt;/code&gt; and &lt;code&gt;swerve&lt;/code&gt;, which may feel ad-hoc.&lt;/p&gt;
&lt;p&gt;Luckily, there’s another way to achieve the same goals and also be able to take advantage of our favorite familiar interfaces. We can “add Contravariance” directly into &lt;code&gt;Ap&lt;/code&gt; itself, using &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Route.html#t:Pre&#34;&gt;&lt;code&gt;Pre&lt;/code&gt;&lt;/a&gt;. This is a trick I first saw used in the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/unjson&#34;&gt;unjson&lt;/a&gt;&lt;/em&gt; library.&lt;/p&gt;
&lt;p&gt;Recall that &lt;code&gt;Ap Field a&lt;/code&gt; is a collection that contains a bunch of &lt;code&gt;Field x&lt;/code&gt;s of different &lt;code&gt;x&lt;/code&gt;s, and can be used to covariantly &lt;em&gt;produce&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; by combining all of the &lt;code&gt;x&lt;/code&gt;s back together.&lt;/p&gt;
&lt;p&gt;Now, a value of type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will “produce” &lt;code&gt;a&lt;/code&gt;s covariantly…but will “consume” &lt;code&gt;r&lt;/code&gt;s contravariantly. You can think of the &lt;code&gt;Pre r&lt;/code&gt; as adding an “tunnel” to guide the &lt;code&gt;r&lt;/code&gt; to each &lt;code&gt;Field&lt;/code&gt; in the &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;Ap&lt;/code&gt; is &lt;code&gt;Ap&lt;/code&gt; (famous for its &lt;code&gt;Applicative&lt;/code&gt; instance), we can use normal Applicative combinators to combine our fake invariant type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;(&lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb14-5&#34;&gt;&lt;a href=&#34;#cb14-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb14-6&#34;&gt;&lt;a href=&#34;#cb14-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) b&lt;/span&gt;
&lt;span id=&#34;cb14-7&#34;&gt;&lt;a href=&#34;#cb14-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-8&#34;&gt;&lt;a href=&#34;#cb14-8&#34;&gt;&lt;/a&gt;liftA2&lt;/span&gt;
&lt;span id=&#34;cb14-9&#34;&gt;&lt;a href=&#34;#cb14-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; c)&lt;/span&gt;
&lt;span id=&#34;cb14-10&#34;&gt;&lt;a href=&#34;#cb14-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb14-11&#34;&gt;&lt;a href=&#34;#cb14-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) b&lt;/span&gt;
&lt;span id=&#34;cb14-12&#34;&gt;&lt;a href=&#34;#cb14-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that the &lt;code&gt;Applicative&lt;/code&gt; combinators will recombine our “output” covariant types appropriately, but will keep the “input” contravariant type constant&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can construct a value of type &lt;code&gt;Ap (Pre r Field) a&lt;/code&gt; using &lt;code&gt;injectPre&lt;/code&gt;, which asks us to provide that “get an &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;r&lt;/code&gt;” function up-front:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;injectPre ::&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r f) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How do we interpret out of &lt;code&gt;Ap (Pre r f) a&lt;/code&gt;? Well, there’s a useful newtype wrapper over &lt;code&gt;Pre&lt;/code&gt; called &lt;code&gt;PreT&lt;/code&gt; that makes consuming and interpreting it very clean, by requiring the &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; to be the same:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; t f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; (t (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; a f) a)&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | `inject` works just like it did before with `Ap` and `Div`: put that `f`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- into a `PreT`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inject ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-7&#34;&gt;&lt;a href=&#34;#cb16-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | interpret for PreT treats `PreT Ap f a` as if it were just `Ap f a`, so we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-8&#34;&gt;&lt;a href=&#34;#cb16-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- interpret into an `Applicative` context, like we did with the parsers when&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-9&#34;&gt;&lt;a href=&#34;#cb16-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- we used `Ap f a`.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-10&#34;&gt;&lt;a href=&#34;#cb16-10&#34;&gt;&lt;/a&gt;interpret&lt;/span&gt;
&lt;span id=&#34;cb16-11&#34;&gt;&lt;a href=&#34;#cb16-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb16-12&#34;&gt;&lt;a href=&#34;#cb16-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb16-13&#34;&gt;&lt;a href=&#34;#cb16-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-14&#34;&gt;&lt;a href=&#34;#cb16-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb16-15&#34;&gt;&lt;a href=&#34;#cb16-15&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-16&#34;&gt;&lt;a href=&#34;#cb16-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | But we can also interpret into a `Divisible` context!  Just like when we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-17&#34;&gt;&lt;a href=&#34;#cb16-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- used `Div f a` to write our serializer!&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-18&#34;&gt;&lt;a href=&#34;#cb16-18&#34;&gt;&lt;/a&gt;preDivisibleT&lt;/span&gt;
&lt;span id=&#34;cb16-19&#34;&gt;&lt;a href=&#34;#cb16-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb16-20&#34;&gt;&lt;a href=&#34;#cb16-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb16-21&#34;&gt;&lt;a href=&#34;#cb16-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-22&#34;&gt;&lt;a href=&#34;#cb16-22&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb16-23&#34;&gt;&lt;a href=&#34;#cb16-23&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-24&#34;&gt;&lt;a href=&#34;#cb16-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | We can also use htoList like before&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-25&#34;&gt;&lt;a href=&#34;#cb16-25&#34;&gt;&lt;/a&gt;htoList&lt;/span&gt;
&lt;span id=&#34;cb16-26&#34;&gt;&lt;a href=&#34;#cb16-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb16-27&#34;&gt;&lt;a href=&#34;#cb16-27&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-28&#34;&gt;&lt;a href=&#34;#cb16-28&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that &lt;code&gt;interpret&lt;/code&gt; for &lt;code&gt;PreT Ap f a&lt;/code&gt; works just like &lt;code&gt;interpret&lt;/code&gt; for &lt;code&gt;Ap f a&lt;/code&gt;; we don’t lose any power, it’s the same as always if we wanted to just use &lt;code&gt;Ap f a&lt;/code&gt; covariantly to interpret into a parser. Exactly what we did when we wrote our parser generation.&lt;/p&gt;
&lt;p&gt;But, we also gain &lt;code&gt;preDivisibleT&lt;/code&gt;, which lets us &lt;code&gt;interpret&lt;/code&gt; into a contravariant &lt;code&gt;Divisible&lt;/code&gt; context! Just like as if we had &lt;code&gt;Div f a&lt;/code&gt;! This is exactly what we did when we wrote our serializers.&lt;/p&gt;
&lt;p&gt;So using &lt;code&gt;Pre&lt;/code&gt; and &lt;code&gt;PreT&lt;/code&gt;, we get to &lt;em&gt;assemble&lt;/em&gt; it using our favorite &lt;code&gt;Applicative&lt;/code&gt; combinators…then when we wrap it in &lt;code&gt;PreT&lt;/code&gt;, we get to &lt;em&gt;interpret&lt;/em&gt; it in whatever way we want by choosing different interpreters. It’s the best of both worlds!&lt;/p&gt;
&lt;p&gt;We can do the opposite thing with &lt;code&gt;Dec&lt;/code&gt; as well: we can use &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Route.html#t:Post&#34;&gt;&lt;code&gt;Post&lt;/code&gt;&lt;/a&gt; to embed covariant capabilities in &lt;code&gt;Dec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Recall that &lt;code&gt;Div Choice a&lt;/code&gt; is a collection that contains a bunch of &lt;code&gt;Choice x&lt;/code&gt;s of different &lt;code&gt;x&lt;/code&gt;s, and can be used to contravariantly &lt;em&gt;consume&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; (by sending the &lt;code&gt;a&lt;/code&gt; to one of the different &lt;code&gt;Choice x&lt;/code&gt;s).&lt;/p&gt;
&lt;p&gt;A value of type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will “consume” &lt;code&gt;a&lt;/code&gt;s contravariantly (like a normal &lt;code&gt;Dec&lt;/code&gt;), but will also produce &lt;code&gt;r&lt;/code&gt;s covariantly. You can think of the &lt;code&gt;Post r&lt;/code&gt; as adding an “tunnel” allowing the output of each &lt;code&gt;Choice&lt;/code&gt; to exit out of the &lt;code&gt;Dec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This means we can now use normal &lt;code&gt;Conclude&lt;/code&gt; contravariant typeclass-based combinators to combine our fake invariant type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c)        &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) b    &lt;span class=&#34;co&#34;&gt;-- ^ handle first branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) c    &lt;span class=&#34;co&#34;&gt;-- ^ handle second branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-5&#34;&gt;&lt;a href=&#34;#cb18-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) a    &lt;span class=&#34;co&#34;&gt;-- ^ overall handler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that &lt;code&gt;decide&lt;/code&gt; will recombine our “input” contravariant types appropriately, but will keep the “output” covariant type constant&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Again, we can construct a value of type &lt;code&gt;Dec (Post r Choice) a&lt;/code&gt; using &lt;code&gt;injectPost&lt;/code&gt;, which asks us to provide that “embed the &lt;code&gt;a&lt;/code&gt; in the &lt;code&gt;r&lt;/code&gt;” function up-front:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;injectPost ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r f) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And again, we have the newtype wrapper &lt;code&gt;PostT&lt;/code&gt; that gives us convenient interpreting functions:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; t f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; (t (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; a f) a)&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-3&#34;&gt;&lt;a href=&#34;#cb20-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | `inject` works just like it did before with `Dec` and `ListF`: put that `f`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-4&#34;&gt;&lt;a href=&#34;#cb20-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- into a `PostT`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-5&#34;&gt;&lt;a href=&#34;#cb20-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inject ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-6&#34;&gt;&lt;a href=&#34;#cb20-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-7&#34;&gt;&lt;a href=&#34;#cb20-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | interpret for PostT treats `PostT Dec f a` as if it were just `Dec f a`, so we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-8&#34;&gt;&lt;a href=&#34;#cb20-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- interpret into a `Conclude` context, like we did with the serializers when&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-9&#34;&gt;&lt;a href=&#34;#cb20-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- we used `Dec f a`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-10&#34;&gt;&lt;a href=&#34;#cb20-10&#34;&gt;&lt;/a&gt;interpret&lt;/span&gt;
&lt;span id=&#34;cb20-11&#34;&gt;&lt;a href=&#34;#cb20-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb20-12&#34;&gt;&lt;a href=&#34;#cb20-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb20-13&#34;&gt;&lt;a href=&#34;#cb20-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-14&#34;&gt;&lt;a href=&#34;#cb20-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb20-15&#34;&gt;&lt;a href=&#34;#cb20-15&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-16&#34;&gt;&lt;a href=&#34;#cb20-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | But we can also interpret into a `Plus` context!  Just like when we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-17&#34;&gt;&lt;a href=&#34;#cb20-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- used `ListF f a` to write our parser generation!&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-18&#34;&gt;&lt;a href=&#34;#cb20-18&#34;&gt;&lt;/a&gt;postPlusT&lt;/span&gt;
&lt;span id=&#34;cb20-19&#34;&gt;&lt;a href=&#34;#cb20-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb20-20&#34;&gt;&lt;a href=&#34;#cb20-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb20-21&#34;&gt;&lt;a href=&#34;#cb20-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-22&#34;&gt;&lt;a href=&#34;#cb20-22&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb20-23&#34;&gt;&lt;a href=&#34;#cb20-23&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-24&#34;&gt;&lt;a href=&#34;#cb20-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | We can also use htoList like before&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-25&#34;&gt;&lt;a href=&#34;#cb20-25&#34;&gt;&lt;/a&gt;htoList&lt;/span&gt;
&lt;span id=&#34;cb20-26&#34;&gt;&lt;a href=&#34;#cb20-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb20-27&#34;&gt;&lt;a href=&#34;#cb20-27&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-28&#34;&gt;&lt;a href=&#34;#cb20-28&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get the same benefits as for &lt;code&gt;PreT&lt;/code&gt;: if we want to interpret into a &lt;code&gt;Conclude&lt;/code&gt; (like we did for our serializers), we can use &lt;code&gt;interpret&lt;/code&gt;. If we want to interpret into a &lt;code&gt;Plus&lt;/code&gt; (like we did for our parser generation), we can use &lt;code&gt;postPlusT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With these new tools, we can imagine a different invariant &lt;code&gt;Schema&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/routing.hs#L36-L85&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb21-5&#34;&gt;&lt;a href=&#34;#cb21-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-6&#34;&gt;&lt;a href=&#34;#cb21-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-7&#34;&gt;&lt;a href=&#34;#cb21-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-8&#34;&gt;&lt;a href=&#34;#cb21-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-9&#34;&gt;&lt;a href=&#34;#cb21-9&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-10&#34;&gt;&lt;a href=&#34;#cb21-10&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb21-11&#34;&gt;&lt;a href=&#34;#cb21-11&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb21-12&#34;&gt;&lt;a href=&#34;#cb21-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-13&#34;&gt;&lt;a href=&#34;#cb21-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-14&#34;&gt;&lt;a href=&#34;#cb21-14&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-15&#34;&gt;&lt;a href=&#34;#cb21-15&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb21-16&#34;&gt;&lt;a href=&#34;#cb21-16&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb21-17&#34;&gt;&lt;a href=&#34;#cb21-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-18&#34;&gt;&lt;a href=&#34;#cb21-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-19&#34;&gt;&lt;a href=&#34;#cb21-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)     (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-20&#34;&gt;&lt;a href=&#34;#cb21-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;) (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-21&#34;&gt;&lt;a href=&#34;#cb21-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)       (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-22&#34;&gt;&lt;a href=&#34;#cb21-22&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-23&#34;&gt;&lt;a href=&#34;#cb21-23&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-24&#34;&gt;&lt;a href=&#34;#cb21-24&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-25&#34;&gt;&lt;a href=&#34;#cb21-25&#34;&gt;&lt;/a&gt;    decide (\&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; x y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (x, y); &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb21-26&#34;&gt;&lt;a href=&#34;#cb21-26&#34;&gt;&lt;/a&gt;      (injectPost (&lt;span class=&#34;fu&#34;&gt;uncurry&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-27&#34;&gt;&lt;a href=&#34;#cb21-27&#34;&gt;&lt;/a&gt;        { choiceName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-28&#34;&gt;&lt;a href=&#34;#cb21-28&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; (,)&lt;/span&gt;
&lt;span id=&#34;cb21-29&#34;&gt;&lt;a href=&#34;#cb21-29&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; injectPre &lt;span class=&#34;fu&#34;&gt;fst&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString }&lt;/span&gt;
&lt;span id=&#34;cb21-30&#34;&gt;&lt;a href=&#34;#cb21-30&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; injectPre &lt;span class=&#34;fu&#34;&gt;snd&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb21-31&#34;&gt;&lt;a href=&#34;#cb21-31&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb21-32&#34;&gt;&lt;a href=&#34;#cb21-32&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;
&lt;span id=&#34;cb21-33&#34;&gt;&lt;a href=&#34;#cb21-33&#34;&gt;&lt;/a&gt;      (injectPost &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt;         &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-34&#34;&gt;&lt;a href=&#34;#cb21-34&#34;&gt;&lt;/a&gt;        { choiceName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-35&#34;&gt;&lt;a href=&#34;#cb21-35&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; inject &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-36&#34;&gt;&lt;a href=&#34;#cb21-36&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb21-37&#34;&gt;&lt;a href=&#34;#cb21-37&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb21-38&#34;&gt;&lt;a href=&#34;#cb21-38&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that to build up &lt;code&gt;choiceValue&lt;/code&gt; for &lt;code&gt;Person&lt;/code&gt;, we can use our normal favorite &lt;code&gt;Appliciative&lt;/code&gt; combinators, like &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;! And at the top level, we use &lt;code&gt;decide&lt;/code&gt; like we did before with our general contravariant combinators.&lt;/p&gt;
&lt;p&gt;All of our running functions look pretty much the same as well:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/routing.hs#L87-L167&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb22-9&#34;&gt;&lt;a href=&#34;#cb22-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-10&#34;&gt;&lt;a href=&#34;#cb22-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-11&#34;&gt;&lt;a href=&#34;#cb22-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb22-12&#34;&gt;&lt;a href=&#34;#cb22-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb22-13&#34;&gt;&lt;a href=&#34;#cb22-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb22-14&#34;&gt;&lt;a href=&#34;#cb22-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-15&#34;&gt;&lt;a href=&#34;#cb22-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-16&#34;&gt;&lt;a href=&#34;#cb22-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-17&#34;&gt;&lt;a href=&#34;#cb22-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb22-18&#34;&gt;&lt;a href=&#34;#cb22-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb22-19&#34;&gt;&lt;a href=&#34;#cb22-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-20&#34;&gt;&lt;a href=&#34;#cb22-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb22-21&#34;&gt;&lt;a href=&#34;#cb22-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-22&#34;&gt;&lt;a href=&#34;#cb22-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-23&#34;&gt;&lt;a href=&#34;#cb22-23&#34;&gt;&lt;/a&gt;    fieldDoc &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc fieldName fieldValue&lt;/span&gt;
&lt;span id=&#34;cb22-24&#34;&gt;&lt;a href=&#34;#cb22-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-25&#34;&gt;&lt;a href=&#34;#cb22-25&#34;&gt;&lt;/a&gt;    choiceDoc &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc choiceName choiceValue&lt;/span&gt;
&lt;span id=&#34;cb22-26&#34;&gt;&lt;a href=&#34;#cb22-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-27&#34;&gt;&lt;a href=&#34;#cb22-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-28&#34;&gt;&lt;a href=&#34;#cb22-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-29&#34;&gt;&lt;a href=&#34;#cb22-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-30&#34;&gt;&lt;a href=&#34;#cb22-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-31&#34;&gt;&lt;a href=&#34;#cb22-31&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-32&#34;&gt;&lt;a href=&#34;#cb22-32&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-33&#34;&gt;&lt;a href=&#34;#cb22-33&#34;&gt;&lt;/a&gt;schemaParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-34&#34;&gt;&lt;a href=&#34;#cb22-34&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret fieldParser fs&lt;/span&gt;
&lt;span id=&#34;cb22-35&#34;&gt;&lt;a href=&#34;#cb22-35&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; postPlusT choiceParser cs&lt;/span&gt;
&lt;span id=&#34;cb22-36&#34;&gt;&lt;a href=&#34;#cb22-36&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;
&lt;span id=&#34;cb22-37&#34;&gt;&lt;a href=&#34;#cb22-37&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-38&#34;&gt;&lt;a href=&#34;#cb22-38&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-39&#34;&gt;&lt;a href=&#34;#cb22-39&#34;&gt;&lt;/a&gt;    fieldParser &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.key (T.pack fieldName) (schemaParser fieldValue)&lt;/span&gt;
&lt;span id=&#34;cb22-40&#34;&gt;&lt;a href=&#34;#cb22-40&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-41&#34;&gt;&lt;a href=&#34;#cb22-41&#34;&gt;&lt;/a&gt;    choiceParser &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-42&#34;&gt;&lt;a href=&#34;#cb22-42&#34;&gt;&lt;/a&gt;      tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb22-43&#34;&gt;&lt;a href=&#34;#cb22-43&#34;&gt;&lt;/a&gt;      unless (tag &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; choiceName) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-44&#34;&gt;&lt;a href=&#34;#cb22-44&#34;&gt;&lt;/a&gt;        A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;Tag does not match&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-45&#34;&gt;&lt;a href=&#34;#cb22-45&#34;&gt;&lt;/a&gt;      A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; schemaParser choiceValue&lt;/span&gt;
&lt;span id=&#34;cb22-46&#34;&gt;&lt;a href=&#34;#cb22-46&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-47&#34;&gt;&lt;a href=&#34;#cb22-47&#34;&gt;&lt;/a&gt;    primParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-48&#34;&gt;&lt;a href=&#34;#cb22-48&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withString &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-49&#34;&gt;&lt;a href=&#34;#cb22-49&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating string&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-50&#34;&gt;&lt;a href=&#34;#cb22-50&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withScientific &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-51&#34;&gt;&lt;a href=&#34;#cb22-51&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating number&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-52&#34;&gt;&lt;a href=&#34;#cb22-52&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withBool &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-53&#34;&gt;&lt;a href=&#34;#cb22-53&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating bool&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-54&#34;&gt;&lt;a href=&#34;#cb22-54&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-55&#34;&gt;&lt;a href=&#34;#cb22-55&#34;&gt;&lt;/a&gt;schemaToValue&lt;/span&gt;
&lt;span id=&#34;cb22-56&#34;&gt;&lt;a href=&#34;#cb22-56&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-57&#34;&gt;&lt;a href=&#34;#cb22-57&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-58&#34;&gt;&lt;a href=&#34;#cb22-58&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-59&#34;&gt;&lt;a href=&#34;#cb22-59&#34;&gt;&lt;/a&gt;schemaToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-60&#34;&gt;&lt;a href=&#34;#cb22-60&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; getOp (preDivisibleT fieldToValue fs)&lt;/span&gt;
&lt;span id=&#34;cb22-61&#34;&gt;&lt;a href=&#34;#cb22-61&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; getOp (interpret choiceToValue cs)&lt;/span&gt;
&lt;span id=&#34;cb22-62&#34;&gt;&lt;a href=&#34;#cb22-62&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primToValue p&lt;/span&gt;
&lt;span id=&#34;cb22-63&#34;&gt;&lt;a href=&#34;#cb22-63&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-64&#34;&gt;&lt;a href=&#34;#cb22-64&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb22-65&#34;&gt;&lt;a href=&#34;#cb22-65&#34;&gt;&lt;/a&gt;    fieldToValue &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-66&#34;&gt;&lt;a href=&#34;#cb22-66&#34;&gt;&lt;/a&gt;        [T.pack fieldName &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue fieldValue x]&lt;/span&gt;
&lt;span id=&#34;cb22-67&#34;&gt;&lt;a href=&#34;#cb22-67&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-68&#34;&gt;&lt;a href=&#34;#cb22-68&#34;&gt;&lt;/a&gt;    choiceToValue &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb22-69&#34;&gt;&lt;a href=&#34;#cb22-69&#34;&gt;&lt;/a&gt;        [ &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; T.pack choiceName&lt;/span&gt;
&lt;span id=&#34;cb22-70&#34;&gt;&lt;a href=&#34;#cb22-70&#34;&gt;&lt;/a&gt;        , &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue choiceValue x&lt;/span&gt;
&lt;span id=&#34;cb22-71&#34;&gt;&lt;a href=&#34;#cb22-71&#34;&gt;&lt;/a&gt;        ]&lt;/span&gt;
&lt;span id=&#34;cb22-72&#34;&gt;&lt;a href=&#34;#cb22-72&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-73&#34;&gt;&lt;a href=&#34;#cb22-73&#34;&gt;&lt;/a&gt;    primToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-74&#34;&gt;&lt;a href=&#34;#cb22-74&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.String&lt;/span&gt; (T.pack (f x))&lt;/span&gt;
&lt;span id=&#34;cb22-75&#34;&gt;&lt;a href=&#34;#cb22-75&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Number&lt;/span&gt; (f x)&lt;/span&gt;
&lt;span id=&#34;cb22-76&#34;&gt;&lt;a href=&#34;#cb22-76&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Bool&lt;/span&gt;   (f x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using &lt;code&gt;DivAp&lt;/code&gt;/&lt;code&gt;DecAlt&lt;/code&gt; and &lt;code&gt;PreT Ap&lt;/code&gt;/&lt;code&gt;PostT Dec&lt;/code&gt; are just two separate styles for you to consider if we want to go into combining &lt;em&gt;both&lt;/em&gt; covariant production &lt;em&gt;and&lt;/em&gt; contravariant consumption!&lt;/p&gt;
&lt;h2 id=&#34;concluding-thoughts&#34;&gt;Concluding Thoughts&lt;/h2&gt;
&lt;p&gt;If you’ve come this far, thank you for reading!&lt;/p&gt;
&lt;p&gt;The thought process described in this series was pretty much my actual thought process when writing something similar. I needed to provide documentation, a json parser, and a json serializer for a collection of data formats that I had. At first I had written three separate systems, and wrote all three separately for each format. I struggled with keeping all of them in sync, but everything clicked when I realized I could combine the documentation generator and the parser generation. I looked at my serializer system with regret on how it had to be a separate thing. But then I stared really really hard at it, and all of a sudden the idea of uniting all three of them became something I realized was worthwhile.&lt;/p&gt;
&lt;p&gt;It really was a truly “step-by-step” process…and I think it’s pretty rare that these fully formed united abstractions just pop out of your brain without going through the process of looking at each individual piece!&lt;/p&gt;
&lt;p&gt;In real code this pairing of the covariant and covariant is pretty prevalent. In another recent situation, I had to deal with “incoming” typed sockets (covariant outputters) and “outgoing” typed sockets (contravariant consumers)…the contexts where you get these sort of opposing dual pairs comes up a lot. Being able write a functor structure that lets you deal with them together can save a lot of code, reduce the space for errors, and relieve a lot of maintenance burden. For example, in the case of sockets, we could even write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | allocate an outgoing socket that only accepts values of your schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;makeOutSocket ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;OutSocket&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | allocate an incoming socket that awaits values of your schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-5&#34;&gt;&lt;a href=&#34;#cb23-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;makeInSocket ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;InSocket&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;code&gt;Schema a&lt;/code&gt; could represent a data protocol; under this system, you have the assurance that the protocol of sending a data type over a channel is always going to be the same as the protocol for receiving data, no matter what changes you make to your type. And you only have to write the code once, not twice!&lt;/p&gt;
&lt;p&gt;Try to investigate situations in your life where “structures” could be more useful as “functor structures”…and then maybe see if there’s even more value you could add by enhancing them with more functor-ness!&lt;/p&gt;
&lt;p&gt;Hopefully &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;functor-combinators&lt;/a&gt;&lt;/em&gt; and the &lt;em&gt;[functor combinatorpedia][]&lt;/em&gt; may be a useful guide along the way! You don’t have to build things “functor combinator style” like in this post (you could make everything from scratch without using &lt;code&gt;Ap&lt;/code&gt;/&lt;code&gt;Dec&lt;/code&gt;, etc.), but I have found that thinking in this style helps guide your search to solutions that already exist (like how we found &lt;code&gt;ListF&lt;/code&gt; by reading about &lt;code&gt;Ap&lt;/code&gt;), instead of reinventing the wheel every time. If anything, it can help you reframe the problem in a way that might make it more easy to grasp.&lt;/p&gt;
&lt;p&gt;Until next time, happy Haskelling!&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;These are unfortunate consequences of the fact that there is no general typeclass that contains both &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Divisible&lt;/code&gt; together, or no typeclass that contains both &lt;code&gt;Plus&lt;/code&gt; and &lt;code&gt;Conclude&lt;/code&gt; together. If these existed, we could just use &lt;code&gt;interpret&lt;/code&gt; for all four of those functions.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;There &lt;em&gt;could&lt;/em&gt; be a typeclass for “combination of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Divisible&lt;/code&gt;” and “combination of &lt;code&gt;Plus&lt;/code&gt; and &lt;code&gt;Conclude&lt;/code&gt;”:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivisibleApplicative&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;  conquerpure ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;  divideAp ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b, c)) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And every &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Divisible&lt;/code&gt; instance would be a valid instance of this. However, this doesn’t really exist in any common Haskell libraries…and I’m not sure it exists anywhere at all.&lt;/p&gt;
&lt;p&gt;Having this typeclass would also give us an &lt;code&gt;interpret&lt;/code&gt; that we can use for both &lt;code&gt;A.Parser ErrType&lt;/code&gt; and &lt;code&gt;Op Aeson.Value&lt;/code&gt;, so we don’t need the awkward two-different-interpreter situation we had before.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;This works out because each of the &lt;code&gt;Field&lt;/code&gt;s inside could work off of the same input type. Remember that &lt;code&gt;Div f a ~ [f a]&lt;/code&gt;, it’s just a list of things that consume the same &lt;code&gt;a&lt;/code&gt;.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;This works out because each of the &lt;code&gt;Choice&lt;/code&gt;s inside could be embedded into the same output type. Remember that we used &lt;code&gt;List f a ~ [f a]&lt;/code&gt; for our contravariant choice collection before, just a list of things that produce the same &lt;code&gt;a&lt;/code&gt;.&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html</guid><pubDate>Tue, 18 Aug 2020 16:45:11 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-08-18</date></item><item><title>Enhancing Functor Structures Step-By-Step (Part 1)</title><link>https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html</link><description>&lt;p&gt;A style of Haskell programming that I’ve been pretty excited about with over the past two years or so is something that I can maybe call a “functor structure” design pattern. In this post we’re going to be exploring the idea of enhancing normal data types with different types of functor structures step-by-step, by starting with a simple useful structure and enhancing it piece by piece in order to reap incremental benefits. This process reflects a lot of the way I personally work through these things — I normally don’t get the whole powerful structure all the way; instead I incrementally add things as I see how things fit together.&lt;/p&gt;
&lt;p&gt;We’re going build the tools to describe a &lt;em&gt;data type schema&lt;/em&gt;, which can represent algebraic data types — sums and products. We’ll start off just building things we can use to &lt;em&gt;describe&lt;/em&gt; the schema (by printing out documentation), and by the end of the journey we’ll also be able to use our schema to generate parsers and serializers through json.&lt;/p&gt;
&lt;p&gt;This interest in functor structures culminated in my &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html&#34;&gt;Functor Combinatorpedia&lt;/a&gt; post last year and the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;functor-combinators&lt;/a&gt;&lt;/em&gt; library. But personally I had never really explored the less commonly used lowercase-f functor abstractions in Hask — contravariant functors and invariant functors until recently.&lt;/p&gt;
&lt;p&gt;This series is designed for an intermediate Haskeller with familiarity in things like product/sum types, using &lt;code&gt;Applicative&lt;/code&gt;/&lt;code&gt;Alternative&lt;/code&gt;, and monadic parser combinators, and is written in sync with &lt;em&gt;functor-combinators-0.3.6.0&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-schema&#34;&gt;The Schema&lt;/h2&gt;
&lt;p&gt;Let’s start with the simplest level of describing our schema: a plain ol’ AST describing the possibilities our schema can take.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L9-L31&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     [&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-7&#34;&gt;&lt;a href=&#34;#cb1-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-8&#34;&gt;&lt;a href=&#34;#cb1-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-9&#34;&gt;&lt;a href=&#34;#cb1-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-10&#34;&gt;&lt;a href=&#34;#cb1-10&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-11&#34;&gt;&lt;a href=&#34;#cb1-11&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-12&#34;&gt;&lt;a href=&#34;#cb1-12&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb1-13&#34;&gt;&lt;a href=&#34;#cb1-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-14&#34;&gt;&lt;a href=&#34;#cb1-14&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-15&#34;&gt;&lt;a href=&#34;#cb1-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-16&#34;&gt;&lt;a href=&#34;#cb1-16&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-17&#34;&gt;&lt;a href=&#34;#cb1-17&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-18&#34;&gt;&lt;a href=&#34;#cb1-18&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb1-19&#34;&gt;&lt;a href=&#34;#cb1-19&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-20&#34;&gt;&lt;a href=&#34;#cb1-20&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-21&#34;&gt;&lt;a href=&#34;#cb1-21&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-22&#34;&gt;&lt;a href=&#34;#cb1-22&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-23&#34;&gt;&lt;a href=&#34;#cb1-23&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-24&#34;&gt;&lt;a href=&#34;#cb1-24&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-25&#34;&gt;&lt;a href=&#34;#cb1-25&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our schema will either represent a record of many different fields, a sum of many different options, or a primitive value. If it’s a sum type, it’ll be described by a list of &lt;code&gt;Choice&lt;/code&gt;, which describes each branch. If it’s a record type, it’ll be described by a list of &lt;code&gt;Field&lt;/code&gt;, which describes each field. If it’s a primitive type, it’ll a &lt;code&gt;Primitive&lt;/code&gt;, which is either a string, number, or boolean.&lt;/p&gt;
&lt;p&gt;Our end goal is to be able to write a schema for a type like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L33-L36&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;   {&lt;span class=&#34;ot&#34;&gt; cpName ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;,&lt;span class=&#34;ot&#34;&gt; cpAge ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; cbEmployees ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and be able to represent documenting, parsing, and printing it all within &lt;code&gt;Schema&lt;/code&gt;. For our basic &lt;code&gt;Schema&lt;/code&gt; above, this looks like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L38-L52&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;    [ &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;            [ &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;            , &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;            ]&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;    , &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-15&#34;&gt;&lt;a href=&#34;#cb3-15&#34;&gt;&lt;/a&gt;            [ &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Employees&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; } ]&lt;/span&gt;
&lt;span id=&#34;cb3-16&#34;&gt;&lt;a href=&#34;#cb3-16&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb3-17&#34;&gt;&lt;a href=&#34;#cb3-17&#34;&gt;&lt;/a&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a value like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;PCustomer&lt;/span&gt; { cpName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt;, cpAge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;40&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;might be represented by a json value using our schema like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode json&#34;&gt;&lt;code class=&#34;sourceCode json&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Customer&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;fl&#34;&gt;40.0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;Using our schema type, let’s make a documentation generator. It’ll take a &lt;code&gt;Schema&lt;/code&gt; and nicely formatted documentation describing the schema itself.&lt;/p&gt;
&lt;p&gt;To make our lives easier, we’ll be using the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/prettyprinter&#34;&gt;prettyprinter&lt;/a&gt;&lt;/em&gt; library, which will handle indentation, horizontal and vertical concatenation, and other printing concerns for us.&lt;/p&gt;
&lt;p&gt;Let’s build things up by defining documentation generators for our individual types, so they’ll be easier to assemble.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L54-L79&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb6-7&#34;&gt;&lt;a href=&#34;#cb6-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-8&#34;&gt;&lt;a href=&#34;#cb6-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb6-9&#34;&gt;&lt;a href=&#34;#cb6-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-10&#34;&gt;&lt;a href=&#34;#cb6-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb6-11&#34;&gt;&lt;a href=&#34;#cb6-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-12&#34;&gt;&lt;a href=&#34;#cb6-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;schemaDoc&lt;/code&gt; will take the name of our type and a schema, and generate a &lt;code&gt;PP.Doc x&lt;/code&gt;, the type of a text document in the &lt;em&gt;prettyprinter&lt;/em&gt; library. And &lt;code&gt;fieldDoc&lt;/code&gt;, &lt;code&gt;choiceDoc&lt;/code&gt;, and &lt;code&gt;primDoc&lt;/code&gt; just generate the documentation for each individual field or constructor.&lt;/p&gt;
&lt;p&gt;(I’m using &lt;code&gt;x&lt;/code&gt; as the name of the type variable (instead of something more traditional like &lt;code&gt;a&lt;/code&gt;) to indicate that it isn’t meant to be referenced or used anywhere in any consistent way. Just remember it doesn’t mean anything special syntactically!)&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;\case&lt;/code&gt; syntax is known as &lt;em&gt;LambdaCase syntax&lt;/em&gt;, and &lt;code&gt;\case blah -&amp;gt; blah&lt;/code&gt; is just sugar for &lt;code&gt;\x -&amp;gt; case x of blah -&amp;gt; blah&lt;/code&gt;; we use it extensively here to save us from having to think of a throwaway variable name.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L73-L83&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb7-8&#34;&gt;&lt;a href=&#34;#cb7-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-9&#34;&gt;&lt;a href=&#34;#cb7-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb7-10&#34;&gt;&lt;a href=&#34;#cb7-10&#34;&gt;&lt;/a&gt;primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-11&#34;&gt;&lt;a href=&#34;#cb7-11&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-12&#34;&gt;&lt;a href=&#34;#cb7-12&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-13&#34;&gt;&lt;a href=&#34;#cb7-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing too fancy here — since &lt;code&gt;Field&lt;/code&gt; and &lt;code&gt;Choice&lt;/code&gt; just have a name and a sub-schema, we can have them call &lt;code&gt;schemaDoc&lt;/code&gt;. &lt;code&gt;primDoc&lt;/code&gt; requires making our leaf documentation, so we can just print what type they have.&lt;/p&gt;
&lt;p&gt;We tie it all together with &lt;code&gt;schemaDoc&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L54-L71&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-16&#34;&gt;&lt;a href=&#34;#cb8-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-17&#34;&gt;&lt;a href=&#34;#cb8-17&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb8-18&#34;&gt;&lt;a href=&#34;#cb8-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb8-19&#34;&gt;&lt;a href=&#34;#cb8-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-20&#34;&gt;&lt;a href=&#34;#cb8-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use &lt;code&gt;PP.vsep&lt;/code&gt;, which takes a list of docs and concatenates them vertically, &lt;code&gt;PP.&amp;lt;+&amp;gt;&lt;/code&gt; which concatenates two docs horizontally, and &lt;code&gt;PP.indent&lt;/code&gt; which indents things before going down a level. We appropriately call &lt;code&gt;fieldDoc&lt;/code&gt;, &lt;code&gt;choiceDoc&lt;/code&gt;, and &lt;code&gt;primDoc&lt;/code&gt; when we actually need to print one of them.&lt;/p&gt;
&lt;p&gt;Hopefully that wasn’t too bad! There were a lot of moving parts because we have a recursive data type, but in the end hopefully each specific branch was self-contained enough to understand on their own. In the end the important thing to take away isn’t the mechanics of document generation, but rather how the data flows. Make sure you at least understand how the functions call each other, and how — this pattern is going to be very consistent across all the schema processors we write!&lt;/p&gt;
&lt;p&gt;We can test out our function on &lt;code&gt;customerSchema&lt;/code&gt;, taking advantage of the fact that &lt;code&gt;PP.Doc&lt;/code&gt;’s &lt;code&gt;Show&lt;/code&gt; instance will render the document:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ghci&amp;gt; schemaDoc &amp;quot;Customer&amp;quot; customerSchema
(Customer)
Choice of:
  {Person}
    *   Name: string
    *   Age: number
  {Business}
    *   Employees: number&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works!&lt;/p&gt;
&lt;h2 id=&#34;parsing-with-covariance&#34;&gt;Parsing with Covariance&lt;/h2&gt;
&lt;p&gt;Now, let’s talk about using our &lt;code&gt;Schema&lt;/code&gt; type to generate a &lt;em&gt;json parser&lt;/em&gt;. We want to be able to use our schema type and use it to parse information from a json value, of a given json format we are expecting.&lt;/p&gt;
&lt;p&gt;To do this, we’re going to rewrite &lt;code&gt;Schema&lt;/code&gt; to take a type parameter to represent the type we want to parse into. A &lt;code&gt;Schema a&lt;/code&gt; will be a schema that can be used to generate documentation &lt;em&gt;and&lt;/em&gt; describe a parser of &lt;code&gt;a&lt;/code&gt;s. In the end, we want &lt;code&gt;customerSchema :: Schema Customer&lt;/code&gt;, and a function like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to generate a json parser of &lt;code&gt;a&lt;/code&gt;s. We’ll be using the json parser type &lt;code&gt;Parse err a&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/aeson-better-errors&#34;&gt;aeson-better-errors&lt;/a&gt;&lt;/em&gt; (not because of the better errors, but just because it’s closer to an actual incremental/stateful parser than other alternatives out there), which can be run with &lt;code&gt;parse :: Parse err a -&amp;gt; ByteString -&amp;gt; Either (ParseError err) a&lt;/code&gt;. So our final interface will look like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L154-L155&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parseSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ByteString&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseError&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;parseSchema sc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.parse (schemaParser sc)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To do this, we now have to include information on “how to parse an &lt;code&gt;a&lt;/code&gt;” in our schema. “How to parse a record” and “how to parse a sum” are going to be handled universally for all schemas…so the only thing that really will vary from type to type (aside from the structure) is how to parse those primitive leaf types when we encounter them in the json. And so, the main thing we need to modify is just &lt;code&gt;Primitive&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L43-L47&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-4&#34;&gt;&lt;a href=&#34;#cb12-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-5&#34;&gt;&lt;a href=&#34;#cb12-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-6&#34;&gt;&lt;a href=&#34;#cb12-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-7&#34;&gt;&lt;a href=&#34;#cb12-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Primitive a&lt;/code&gt; now encodes a way to &lt;em&gt;parse&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; if given the appropriate json primitive. It can be &lt;code&gt;PString&lt;/code&gt;, &lt;code&gt;PNumber&lt;/code&gt;, or &lt;code&gt;PBool&lt;/code&gt;. To create a “String Parser”, you need to use &lt;code&gt;PString&lt;/code&gt; with a function on “what to do with the string you get”. To create a “Bool parser”, you need &lt;code&gt;PBool&lt;/code&gt; with a function on what to do with the bool you get. Note that the &lt;code&gt;PNumber&lt;/code&gt; parser takes a &lt;code&gt;Scientific&lt;/code&gt;, which is the type &lt;em&gt;aeson&lt;/em&gt; (the underlying json library) uses to represent valid JSON numbers (it’s basically &lt;code&gt;Either Integer Double&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We can write some helper primitives:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L49-L56&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pString ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;pString &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-6&#34;&gt;&lt;a href=&#34;#cb13-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pInt ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-7&#34;&gt;&lt;a href=&#34;#cb13-7&#34;&gt;&lt;/a&gt;pInt &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; toBoundedInteger&lt;/span&gt;
&lt;span id=&#34;cb13-8&#34;&gt;&lt;a href=&#34;#cb13-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-9&#34;&gt;&lt;a href=&#34;#cb13-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pBool ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-10&#34;&gt;&lt;a href=&#34;#cb13-10&#34;&gt;&lt;/a&gt;pBool &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pString :: Primitive String&lt;/code&gt; is the most basic way to parse a primitive json string: just return the &lt;code&gt;String&lt;/code&gt; itself. &lt;code&gt;pInt&lt;/code&gt; needs to reject any non-integer numbers, so &lt;code&gt;toBoundedInteger :: Scientific -&amp;gt; Maybe Int&lt;/code&gt; works well.&lt;/p&gt;
&lt;p&gt;We can now start writing our parsers for each branch of &lt;code&gt;Schema&lt;/code&gt;. The &lt;code&gt;SchemaLeaf&lt;/code&gt; branch should be the simplest. We can use &lt;em&gt;aeson-better-error&lt;/em&gt;’s primitive value parsers:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Parse successfuly only if the current value is a String, running the&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- validation function&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;withString     ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-5&#34;&gt;&lt;a href=&#34;#cb14-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;withScientific ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb14-6&#34;&gt;&lt;a href=&#34;#cb14-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;withBool       ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L131-L138&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;primParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-5&#34;&gt;&lt;a href=&#34;#cb15-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withString &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-6&#34;&gt;&lt;a href=&#34;#cb15-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating string&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb15-7&#34;&gt;&lt;a href=&#34;#cb15-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withScientific &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-8&#34;&gt;&lt;a href=&#34;#cb15-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating number&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb15-9&#34;&gt;&lt;a href=&#34;#cb15-9&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withBool &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-10&#34;&gt;&lt;a href=&#34;#cb15-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating bool&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing too fancy, mostly plumbing.&lt;/p&gt;
&lt;h3 id=&#34;deducing-ap&#34;&gt;Deducing Ap&lt;/h3&gt;
&lt;p&gt;However, this small change (and adding the type parameter) leaves in a predicament. What should &lt;code&gt;Schema&lt;/code&gt; look like?&lt;/p&gt;
&lt;p&gt;At first glance, we might think we could just write&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     [&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-7&#34;&gt;&lt;a href=&#34;#cb16-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L31-L37&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-8&#34;&gt;&lt;a href=&#34;#cb16-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-9&#34;&gt;&lt;a href=&#34;#cb16-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-10&#34;&gt;&lt;a href=&#34;#cb16-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-11&#34;&gt;&lt;a href=&#34;#cb16-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But there’s a problem here: &lt;code&gt;RecordType&lt;/code&gt; is a combination of &lt;code&gt;Field&lt;/code&gt;s, but…each &lt;code&gt;Field&lt;/code&gt; is of a different type! For example, in our &lt;code&gt;Customer&lt;/code&gt; example, the &lt;code&gt;Person&lt;/code&gt; branch has two fields: &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Age&lt;/code&gt;. Our name schema would look like &lt;code&gt;nameField :: Field String&lt;/code&gt;, and our age schema would look like &lt;code&gt;ageField :: Field Int&lt;/code&gt;…and so you can’t really put that into a list like &lt;code&gt;[Field a]&lt;/code&gt; since they each have different types. And further more, we want a final &lt;code&gt;Customer&lt;/code&gt; (in our &lt;code&gt;Schema Customer&lt;/code&gt;), a type which is different from both &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What we need is a way to express heterogeneous collection/sequence of &lt;code&gt;Field a&lt;/code&gt;, coupled with a way of “combining” all of them to create an aggregate value of a final type. A type that says “use a bunch of &lt;code&gt;Field&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;s of different types to generate a final &lt;code&gt;a&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;There are a couple of ways to arrive at this mystery type. One way is to recognize “combine a bunch of &lt;code&gt;f x&lt;/code&gt;s of different types to create an &lt;code&gt;f b&lt;/code&gt;” is essentially the M.O. of the &lt;em&gt;Applicative&lt;/em&gt; abstraction, and so essentially we want to give &lt;code&gt;Field&lt;/code&gt; some sort of &lt;code&gt;Applicative&lt;/code&gt; structure. And so we can reach for “the type that gives something an &lt;code&gt;Applicative&lt;/code&gt; structure”, the &lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html&#34;&gt;free applicative&lt;/a&gt;. (This is the strategy I talk about in my &lt;a href=&#34;https://blog.jle.im/entry/free-alternative-regexp.html&#34;&gt;Applicative Regular Expressions&lt;/a&gt; post: if you know exactly the interface you want, you can just use that interface’s free structure)&lt;/p&gt;
&lt;p&gt;Another way is to think about it as an enhancement along a functor combinator described in the &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html&#34;&gt;functor combinatorpedia&lt;/a&gt;. Here we know we want to enhance &lt;code&gt;Field&lt;/code&gt; in a specific way, so we can scan the list of functor combinators until there is one that we need. And scrolling down, we see:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html#ap-ap1&#34;&gt;&lt;strong&gt;Ap / Ap1 &lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html&#34;&gt;Control.Applicative.Free&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html&#34;&gt;Data.Functor.Apply.Free&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s that the interpreter &lt;em&gt;must&lt;/em&gt; consume &lt;em&gt;all&lt;/em&gt; of. (…)&lt;/p&gt;
&lt;p&gt;While &lt;code&gt;ListF&lt;/code&gt; may be considered “multiple options &lt;em&gt;offered&lt;/em&gt;”, &lt;code&gt;Ap&lt;/code&gt; can be considered “multiple actions all &lt;em&gt;required&lt;/em&gt;”. The interpreter must consume/interpret &lt;em&gt;all&lt;/em&gt; of the multiple &lt;code&gt;f&lt;/code&gt;s in order to interpret an &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that ordering is not enforced: while the consumer must handle each &lt;code&gt;f&lt;/code&gt; eventually, they are free to handle it in whatever order they desire. In fact, they could even all be handled in parallel. See &lt;code&gt;Free&lt;/code&gt; for a version where ordering is enforced.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;Because this has an &lt;code&gt;Applicative&lt;/code&gt; instance, you can use &lt;code&gt;(&amp;lt;*&amp;gt;) :: Ap f (a -&amp;gt; b) -&amp;gt; Ap f a -&amp;gt; Ap f b&lt;/code&gt; to sequence multiple &lt;code&gt;Ap f&lt;/code&gt;s together, and &lt;code&gt;pure :: a -&amp;gt; Ap f a&lt;/code&gt; to produce a “no-op” &lt;code&gt;Ap&lt;/code&gt; without any &lt;code&gt;f&lt;/code&gt;s.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That sounds like it matches to me! In order to parse a &lt;code&gt;RecordType&lt;/code&gt;, we need to parse &lt;em&gt;every&lt;/em&gt; &lt;code&gt;Field&lt;/code&gt;. It doesn’t make any sense to skip one field or the other: they all need to be processed and parsed. This sounds like just the thing we need.&lt;/p&gt;
&lt;p&gt;The description here also gives a clue for what we might want to use for &lt;code&gt;SumType&lt;/code&gt; (&lt;code&gt;ListF&lt;/code&gt; sounds like a good companion for the behavior we want sum type parsers to have)&lt;/p&gt;
&lt;h3 id=&#34;building-ap&#34;&gt;Building Ap&lt;/h3&gt;
&lt;p&gt;With this, we can write our final &lt;code&gt;Schema&lt;/code&gt; type.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L25-L47&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-6&#34;&gt;&lt;a href=&#34;#cb17-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-7&#34;&gt;&lt;a href=&#34;#cb17-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-8&#34;&gt;&lt;a href=&#34;#cb17-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-9&#34;&gt;&lt;a href=&#34;#cb17-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-10&#34;&gt;&lt;a href=&#34;#cb17-10&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-11&#34;&gt;&lt;a href=&#34;#cb17-11&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb17-12&#34;&gt;&lt;a href=&#34;#cb17-12&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb17-13&#34;&gt;&lt;a href=&#34;#cb17-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-14&#34;&gt;&lt;a href=&#34;#cb17-14&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-15&#34;&gt;&lt;a href=&#34;#cb17-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-16&#34;&gt;&lt;a href=&#34;#cb17-16&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-17&#34;&gt;&lt;a href=&#34;#cb17-17&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb17-18&#34;&gt;&lt;a href=&#34;#cb17-18&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb17-19&#34;&gt;&lt;a href=&#34;#cb17-19&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-20&#34;&gt;&lt;a href=&#34;#cb17-20&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-21&#34;&gt;&lt;a href=&#34;#cb17-21&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-22&#34;&gt;&lt;a href=&#34;#cb17-22&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-23&#34;&gt;&lt;a href=&#34;#cb17-23&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-24&#34;&gt;&lt;a href=&#34;#cb17-24&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-25&#34;&gt;&lt;a href=&#34;#cb17-25&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I switched from &lt;code&gt;[Choice a]&lt;/code&gt; to &lt;code&gt;ListF Choice a&lt;/code&gt; as hinted earlier — the two are the same, but the latter has the &lt;code&gt;Functor&lt;/code&gt; instance we want (&lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; ListF Choice a -&amp;gt; ListF Choice b&lt;/code&gt;), and is an instance of useful functor combinator typeclasses. Furthermore, it illustrates the symmetry between sum types and record, since &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;ListF&lt;/code&gt; are contrasting types: &lt;code&gt;Ap&lt;/code&gt; can be used to a represent the “product” between many required fields, and &lt;code&gt;ListF&lt;/code&gt; can be used to the option between many possible choices. It’s more clear how product types and sum types are “opposites” in a nice clean way.&lt;/p&gt;
&lt;p&gt;We can now make our &lt;code&gt;Customer&lt;/code&gt; schema:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L63-L77&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-5&#34;&gt;&lt;a href=&#34;#cb18-5&#34;&gt;&lt;/a&gt;      inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-6&#34;&gt;&lt;a href=&#34;#cb18-6&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-7&#34;&gt;&lt;a href=&#34;#cb18-7&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-8&#34;&gt;&lt;a href=&#34;#cb18-8&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-9&#34;&gt;&lt;a href=&#34;#cb18-9&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString }&lt;/span&gt;
&lt;span id=&#34;cb18-10&#34;&gt;&lt;a href=&#34;#cb18-10&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb18-11&#34;&gt;&lt;a href=&#34;#cb18-11&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb18-12&#34;&gt;&lt;a href=&#34;#cb18-12&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;op&#34;&gt;&amp;lt;!&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-13&#34;&gt;&lt;a href=&#34;#cb18-13&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-14&#34;&gt;&lt;a href=&#34;#cb18-14&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-15&#34;&gt;&lt;a href=&#34;#cb18-15&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-16&#34;&gt;&lt;a href=&#34;#cb18-16&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Employees&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt }&lt;/span&gt;
&lt;span id=&#34;cb18-17&#34;&gt;&lt;a href=&#34;#cb18-17&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main new thing is using &lt;code&gt;inject :: Choice a -&amp;gt; ListF Choice a&lt;/code&gt; and &lt;code&gt;inject :: Field a -&amp;gt; Ap Field a&lt;/code&gt; to lift our base types into their appropriate combinators. Then after that, we just use &lt;code&gt;Ap&lt;/code&gt;’s &lt;code&gt;Applicative&lt;/code&gt; instance and &lt;code&gt;ListF&lt;/code&gt;’s &lt;code&gt;Plus&lt;/code&gt; instance to combine them together. Overall it should look very similar to the schema we wrote for the documentation section.&lt;/p&gt;
&lt;h3 id=&#34;interpreting-ap&#34;&gt;Interpreting Ap&lt;/h3&gt;
&lt;p&gt;Now, the typical way to “run” an applied functor combinator is with interpreting functions, like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb19-2&#34;&gt;&lt;a href=&#34;#cb19-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; g        &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can interpret an &lt;code&gt;Ap f a&lt;/code&gt; into any &lt;code&gt;Applicative g&lt;/code&gt;, and you can interpret a &lt;code&gt;ListF f a&lt;/code&gt; into any &lt;a href=&#34;https://hackage.haskell.org/package/semigroupoids-5.3.4/docs/Data-Functor-Plus.html&#34;&gt;&lt;code&gt;Plus g&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Plus&lt;/code&gt; is basically &lt;code&gt;Alternative&lt;/code&gt; without an &lt;code&gt;Applicative&lt;/code&gt; requirement, supporting &lt;code&gt;(&amp;lt;!&amp;gt;) :: f a -&amp;gt; f a -&amp;gt; f a&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Basically, the strategy for using &lt;code&gt;interpret&lt;/code&gt; is that you write a function to interpret any individual &lt;code&gt;f&lt;/code&gt; you might find in the structure, and &lt;code&gt;interpret&lt;/code&gt; will accumulate them all together for you.&lt;/p&gt;
&lt;p&gt;In our case, if we decided to use &lt;code&gt;interpret&lt;/code&gt;, we could write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, if we have a way to parse each &lt;code&gt;Field&lt;/code&gt;, then we have a way to parse an &lt;code&gt;Ap Field a&lt;/code&gt;. If we have a way to parse each &lt;code&gt;Choice&lt;/code&gt;, then we have a way to parse a &lt;code&gt;ListF Choice a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s write those individual parsers for each smaller type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L128-L129&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;fieldParser (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.key (T.pack name) (schemaParser val)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use &lt;em&gt;aeson-better-errors&lt;/em&gt;’s &lt;code&gt;key :: Text -&amp;gt; Parser a -&amp;gt; Parser a&lt;/code&gt;, which takes a key and a parser, and runs that parser on whatever is under that key. For &lt;code&gt;fieldParser&lt;/code&gt;, we run the schema parser for our sub-schema under that key.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L121-L126&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;choiceParser (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;  tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;  unless (tag &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; name) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;    A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;Tag does not match&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;  A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; schemaParser val&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our sum type encoding has to be a bit more involved, because json doesn’t have any native sum type construct. The one we’re going to use for this post is the &lt;code&gt;{&#34;tag&#34;: &amp;lt;tag&amp;gt;, &#34;contents&#34;: &amp;lt;contents&amp;gt;}&#34;&lt;/code&gt; form. We’re going to parse whatever is in the key &lt;code&gt;&#34;tag&#34;&lt;/code&gt;, and if that tag matches our current choice’s constructor, we parse the schema parser for our sub-schema under that key. Otherwise, this choice isn’t what is currently in our json value.&lt;/p&gt;
&lt;p&gt;Finally, to bring it all together, we use the &lt;code&gt;interpret&lt;/code&gt; functions we talked about:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L115-L119&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;schemaParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-5&#34;&gt;&lt;a href=&#34;#cb23-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret choiceParser cs&lt;/span&gt;
&lt;span id=&#34;cb23-6&#34;&gt;&lt;a href=&#34;#cb23-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret fieldParser fs&lt;/span&gt;
&lt;span id=&#34;cb23-7&#34;&gt;&lt;a href=&#34;#cb23-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it!&lt;/p&gt;
&lt;p&gt;Ah well, not exactly so fast. Even though they could support it, &lt;em&gt;aeson-better-errors&lt;/em&gt; doesn’t provide &lt;code&gt;Plus&lt;/code&gt; a for &lt;code&gt;Parse&lt;/code&gt;. We can write them as orphans here just because this is a fun learning experience (but we usually do like to avoid defining instances for types or typeclasses that aren’t ours).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt; and &lt;code&gt;Plus&lt;/code&gt; represent fallback choices: &lt;code&gt;x &amp;lt;!&amp;gt; y&lt;/code&gt; will try &lt;code&gt;x&lt;/code&gt; first, then if &lt;code&gt;x&lt;/code&gt; fails, try &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L108-L111&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-3&#34;&gt;&lt;a href=&#34;#cb24-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseT&lt;/span&gt; e f) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-4&#34;&gt;&lt;a href=&#34;#cb24-4&#34;&gt;&lt;/a&gt;    (&lt;span class=&#34;op&#34;&gt;&amp;lt;!&amp;gt;&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;A.&amp;lt;|&amp;gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb24-5&#34;&gt;&lt;a href=&#34;#cb24-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; f) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-6&#34;&gt;&lt;a href=&#34;#cb24-6&#34;&gt;&lt;/a&gt;    zero  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;No options were validated&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that should work!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;set &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;XOverloadedStrings&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Person\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Name\&amp;quot;: \&amp;quot;Same\&amp;quot;, \&amp;quot;Age\&amp;quot;: 40 } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-3&#34;&gt;&lt;a href=&#34;#cb25-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; {cpName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Same&amp;quot;&lt;/span&gt;, cpAge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;30&lt;/span&gt;})&lt;/span&gt;
&lt;span id=&#34;cb25-4&#34;&gt;&lt;a href=&#34;#cb25-4&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Business\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Employees\&amp;quot;: 3 } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-5&#34;&gt;&lt;a href=&#34;#cb25-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; {cbEmployees &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We were able to generate a fully functional parser from our schema, by only providing parsers for the smaller, more specific types we had (&lt;code&gt;Field&lt;/code&gt; and &lt;code&gt;Choice&lt;/code&gt;), and having them all fit together in a way directed by their &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Plus&lt;/code&gt; typeclass instances.&lt;/p&gt;
&lt;h3 id=&#34;direct-structural-inspection&#34;&gt;Direct Structural Inspection&lt;/h3&gt;
&lt;p&gt;However, sometimes the typeclass instances aren’t really the best way to handle things. It gives us a nice principled shortcut — for example, to interpret out of an &lt;code&gt;Ap&lt;/code&gt;, GHC needs a way to know “how to sequence &lt;code&gt;Parse&lt;/code&gt;s”, and so &lt;code&gt;interpret&lt;/code&gt; uses the &lt;code&gt;Applicative&lt;/code&gt; instance for that. But we know there are usually different ways to sequence or combine actions — famously in IO, we have the option to “sequence” IO actions in series or in parallel, with the default &lt;code&gt;Applicative&lt;/code&gt; instance being series sequencing. So, offloading our logic to a typeclass can be a convenient route, but it’s not necessarily the behavior we want.&lt;/p&gt;
&lt;p&gt;In our case, the &lt;code&gt;Plus&lt;/code&gt; instance actually combines failed fallback behavior in an undesirable way: our errors become not too useful, because &lt;code&gt;&amp;lt;!&amp;gt;&lt;/code&gt; always picks the right side’s errors, and we eventually run into &lt;code&gt;A.throwCustomError &#34;No options were validated&#34;&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Business\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Employees\&amp;quot;: \&amp;quot;Mustard\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb26-2&#34;&gt;&lt;a href=&#34;#cb26-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;CustomError&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;No options were validated&amp;quot;&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&#34;cb26-3&#34;&gt;&lt;a href=&#34;#cb26-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Grape\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Color\&amp;quot;: \&amp;quot;purple\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb26-4&#34;&gt;&lt;a href=&#34;#cb26-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;CustomError&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;No options were validated&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the definition of &lt;code&gt;zero&lt;/code&gt; (which was our fault because we wrote it here as an orphan instance — oops!) always falls back to the same error, this is not very useful!&lt;/p&gt;
&lt;p&gt;As we see, &lt;code&gt;interpret&lt;/code&gt; for &lt;code&gt;ListF&lt;/code&gt;, while convenient, isn’t necessarily the best way to tear down a &lt;code&gt;ListF&lt;/code&gt;. Luckily, most functor combinators are just ADTs that we can pattern match and break down and access the structures manually. In the case of &lt;code&gt;ListF&lt;/code&gt;, the structure is pretty simple:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runListF ::&lt;/span&gt; [f a] }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our &lt;code&gt;ListF Choice a&lt;/code&gt; is just &lt;code&gt;[Choice a]&lt;/code&gt;. This is something we can work with! Let’s write a better &lt;code&gt;ListF Choice a&lt;/code&gt; processor by working with the list itself.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L140-L152&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-2&#34;&gt;&lt;a href=&#34;#cb28-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-3&#34;&gt;&lt;a href=&#34;#cb28-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb28-4&#34;&gt;&lt;a href=&#34;#cb28-4&#34;&gt;&lt;/a&gt;schemaParser2 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-5&#34;&gt;&lt;a href=&#34;#cb28-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret fieldParser fs&lt;/span&gt;
&lt;span id=&#34;cb28-6&#34;&gt;&lt;a href=&#34;#cb28-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-7&#34;&gt;&lt;a href=&#34;#cb28-7&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;let&lt;/span&gt; schemaMap &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; M.fromList &lt;/span&gt;
&lt;span id=&#34;cb28-8&#34;&gt;&lt;a href=&#34;#cb28-8&#34;&gt;&lt;/a&gt;            [ (nm, vl) &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; nm vl &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; runListF cs ]&lt;/span&gt;
&lt;span id=&#34;cb28-9&#34;&gt;&lt;a href=&#34;#cb28-9&#34;&gt;&lt;/a&gt;      tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb28-10&#34;&gt;&lt;a href=&#34;#cb28-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; M.lookup tag schemaMap &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-11&#34;&gt;&lt;a href=&#34;#cb28-11&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.throwCustomError &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-12&#34;&gt;&lt;a href=&#34;#cb28-12&#34;&gt;&lt;/a&gt;                &lt;span class=&#34;st&#34;&gt;&amp;quot;tag &amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; tag &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot; not recognized: Expected one of &amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-13&#34;&gt;&lt;a href=&#34;#cb28-13&#34;&gt;&lt;/a&gt;             &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; intercalate &lt;span class=&#34;st&#34;&gt;&amp;quot;, &amp;quot;&lt;/span&gt; (M.keys schemaMap)&lt;/span&gt;
&lt;span id=&#34;cb28-14&#34;&gt;&lt;a href=&#34;#cb28-14&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; sc &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; (schemaParser2 sc)&lt;/span&gt;
&lt;span id=&#34;cb28-15&#34;&gt;&lt;a href=&#34;#cb28-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use the structure of &lt;code&gt;ListF&lt;/code&gt; to generate a &lt;code&gt;Map&lt;/code&gt; associating any tags with the schemas they are meant to encode. We then parse the tag, look up what schema it represents (if any) and then use that schema under the contents key.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;λ&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt; parseSchema2 customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Business\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Employees\&amp;quot;: \&amp;quot;Mustard\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-2&#34;&gt;&lt;a href=&#34;#cb29-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;ObjectKey&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt;,&lt;span class=&#34;dt&#34;&gt;ObjectKey&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Employees&amp;quot;&lt;/span&gt;] (&lt;span class=&#34;dt&#34;&gt;WrongType&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TyNumber&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Mustard&amp;quot;&lt;/span&gt;)))&lt;/span&gt;
&lt;span id=&#34;cb29-3&#34;&gt;&lt;a href=&#34;#cb29-3&#34;&gt;&lt;/a&gt;λ&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt; parseSchema2 customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Grape\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Color\&amp;quot;: \&amp;quot;purple\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-4&#34;&gt;&lt;a href=&#34;#cb29-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;CustomError&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;tag Grape not recognized: Expected one of Business, Person&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Much better messages!&lt;/p&gt;
&lt;h3 id=&#34;backporting-documentation&#34;&gt;Backporting documentation&lt;/h3&gt;
&lt;p&gt;Remember that the whole point of this exercise was to &lt;em&gt;add&lt;/em&gt; functionality to our schema. That means we also have to upgrade our documentation function as well.&lt;/p&gt;
&lt;p&gt;Hopefully it is clear from the structure of our data type that we haven’t &lt;em&gt;lost&lt;/em&gt; any information. Updating our documentation generator should be just a matter of changing how to we get the items from our &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Following what we just learned, one way to do this would be to use &lt;code&gt;interpret&lt;/code&gt; or manually pattern match and take advantage of the structure. However, if we just want to get a list of monomorphic items from a functor combinator, there’s an abstraction in &lt;em&gt;functor-combinators&lt;/em&gt; that gives you a “higher-order” version of &lt;code&gt;toList&lt;/code&gt; called &lt;code&gt;htoList&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb30&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb30-1&#34;&gt;&lt;a href=&#34;#cb30-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;htoList ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;
&lt;span id=&#34;cb30-2&#34;&gt;&lt;a href=&#34;#cb30-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;htoList ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Give it a function to “get” a &lt;code&gt;b&lt;/code&gt; out of every &lt;code&gt;f&lt;/code&gt;, it collects the &lt;code&gt;b&lt;/code&gt; from every &lt;code&gt;f&lt;/code&gt; inside the structure and puts it in a list for us. Note that this type is very similar to the &lt;code&gt;map&lt;/code&gt; we used earlier:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb31&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb31-1&#34;&gt;&lt;a href=&#34;#cb31-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- what we used before&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-2&#34;&gt;&lt;a href=&#34;#cb31-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;     ::&lt;/span&gt; (          &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;   &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;]    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;
&lt;span id=&#34;cb31-3&#34;&gt;&lt;a href=&#34;#cb31-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- what we can use now&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-4&#34;&gt;&lt;a href=&#34;#cb31-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;htoList ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So it looks like &lt;code&gt;htoList&lt;/code&gt; should work as a drop-in replacement for &lt;code&gt;map&lt;/code&gt; …&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb32&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb32-1&#34;&gt;&lt;a href=&#34;#cb32-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L79-L106&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-2&#34;&gt;&lt;a href=&#34;#cb32-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-3&#34;&gt;&lt;a href=&#34;#cb32-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb32-4&#34;&gt;&lt;a href=&#34;#cb32-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-5&#34;&gt;&lt;a href=&#34;#cb32-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-6&#34;&gt;&lt;a href=&#34;#cb32-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-7&#34;&gt;&lt;a href=&#34;#cb32-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-8&#34;&gt;&lt;a href=&#34;#cb32-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb32-9&#34;&gt;&lt;a href=&#34;#cb32-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb32-10&#34;&gt;&lt;a href=&#34;#cb32-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-11&#34;&gt;&lt;a href=&#34;#cb32-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb32-12&#34;&gt;&lt;a href=&#34;#cb32-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb32-13&#34;&gt;&lt;a href=&#34;#cb32-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb32-14&#34;&gt;&lt;a href=&#34;#cb32-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb32-15&#34;&gt;&lt;a href=&#34;#cb32-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-16&#34;&gt;&lt;a href=&#34;#cb32-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-17&#34;&gt;&lt;a href=&#34;#cb32-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb32-18&#34;&gt;&lt;a href=&#34;#cb32-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb32-19&#34;&gt;&lt;a href=&#34;#cb32-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb32-20&#34;&gt;&lt;a href=&#34;#cb32-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb32-21&#34;&gt;&lt;a href=&#34;#cb32-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-22&#34;&gt;&lt;a href=&#34;#cb32-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-23&#34;&gt;&lt;a href=&#34;#cb32-23&#34;&gt;&lt;/a&gt;    fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb32-24&#34;&gt;&lt;a href=&#34;#cb32-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-25&#34;&gt;&lt;a href=&#34;#cb32-25&#34;&gt;&lt;/a&gt;    choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb32-26&#34;&gt;&lt;a href=&#34;#cb32-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-27&#34;&gt;&lt;a href=&#34;#cb32-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-28&#34;&gt;&lt;a href=&#34;#cb32-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-29&#34;&gt;&lt;a href=&#34;#cb32-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-30&#34;&gt;&lt;a href=&#34;#cb32-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, we just had to replace &lt;code&gt;map (\fld -&amp;gt; ..) fs&lt;/code&gt; with &lt;code&gt;htoList (\fld -&amp;gt; ...) fs&lt;/code&gt;, and &lt;code&gt;map choiceDoc cs&lt;/code&gt; with &lt;code&gt;htoList choiceDoc cs&lt;/code&gt;. We were able to re-use the exact same logic — we lose no power and upgrading was a straightforward mechanical transformation.&lt;/p&gt;
&lt;h2 id=&#34;contravariant-consumption&#34;&gt;Contravariant Consumption&lt;/h2&gt;
&lt;p&gt;Now, let’s consider instead the situation where we would want to &lt;em&gt;serialize&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; with a schema. We’ll make a type &lt;code&gt;Schema a&lt;/code&gt; that represents something that can encode an &lt;code&gt;a&lt;/code&gt; as a json value. The overall interface of using that type would be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb33&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb33-1&#34;&gt;&lt;a href=&#34;#cb33-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;Aeson.Value&lt;/code&gt; being the json representation from the &lt;em&gt;aeson&lt;/em&gt; library)&lt;/p&gt;
&lt;p&gt;To keep things simple, let’s forget all the parsing stuff for now; we’ll add it back in later. Let’s just create a type that can &lt;em&gt;only&lt;/em&gt; serialize by enhancing our documentation schema.&lt;/p&gt;
&lt;p&gt;Again, for the same reasons as before, we can get away with the only fundamental change being at the leaves/primitives. Our structure itself is defined by the ADT, and all of the variations outside of the structure itself comes from how each leaf is serialized.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb34&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb34-1&#34;&gt;&lt;a href=&#34;#cb34-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L36-L39&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-2&#34;&gt;&lt;a href=&#34;#cb34-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-3&#34;&gt;&lt;a href=&#34;#cb34-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-4&#34;&gt;&lt;a href=&#34;#cb34-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb34-5&#34;&gt;&lt;a href=&#34;#cb34-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb34-6&#34;&gt;&lt;a href=&#34;#cb34-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Primitive a&lt;/code&gt; will be a way to &lt;em&gt;serialize&lt;/em&gt; a json primitive — it can be &lt;code&gt;PString&lt;/code&gt;, &lt;code&gt;PNumber&lt;/code&gt;, or &lt;code&gt;PBool&lt;/code&gt;. To create a “String Serializer”, you need to use &lt;code&gt;PString&lt;/code&gt; with a function on “how to turn it into a &lt;code&gt;String&lt;/code&gt;”. To create a “Bool parser”, you need &lt;code&gt;PBool&lt;/code&gt; with a function on what how to turn the value into a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Again, it can be useful to add some helper primitives:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb35&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb35-1&#34;&gt;&lt;a href=&#34;#cb35-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L58-L65&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-2&#34;&gt;&lt;a href=&#34;#cb35-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-3&#34;&gt;&lt;a href=&#34;#cb35-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pString ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-4&#34;&gt;&lt;a href=&#34;#cb35-4&#34;&gt;&lt;/a&gt;pString &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-5&#34;&gt;&lt;a href=&#34;#cb35-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-6&#34;&gt;&lt;a href=&#34;#cb35-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pInt ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-7&#34;&gt;&lt;a href=&#34;#cb35-7&#34;&gt;&lt;/a&gt;pInt &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fromIntegral&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-8&#34;&gt;&lt;a href=&#34;#cb35-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-9&#34;&gt;&lt;a href=&#34;#cb35-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pBool ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-10&#34;&gt;&lt;a href=&#34;#cb35-10&#34;&gt;&lt;/a&gt;pBool &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pString :: Primitive String&lt;/code&gt; is the most basic way to serialize a primitive json string: just return the &lt;code&gt;String&lt;/code&gt; itself. &lt;code&gt;pInt&lt;/code&gt; needs to serialize the &lt;code&gt;Int&lt;/code&gt; into a &lt;code&gt;Scientific&lt;/code&gt; (the numeric type of the aeson library).&lt;/p&gt;
&lt;p&gt;We can start off by writing the serializer for &lt;code&gt;Primitive&lt;/code&gt; just go get a feel for how our serializer will work:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb36&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb36-1&#34;&gt;&lt;a href=&#34;#cb36-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L138-L142&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-2&#34;&gt;&lt;a href=&#34;#cb36-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-3&#34;&gt;&lt;a href=&#34;#cb36-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-4&#34;&gt;&lt;a href=&#34;#cb36-4&#34;&gt;&lt;/a&gt;primToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-5&#34;&gt;&lt;a href=&#34;#cb36-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.String&lt;/span&gt; (T.pack (f x))&lt;/span&gt;
&lt;span id=&#34;cb36-6&#34;&gt;&lt;a href=&#34;#cb36-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Number&lt;/span&gt; (f x)&lt;/span&gt;
&lt;span id=&#34;cb36-7&#34;&gt;&lt;a href=&#34;#cb36-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Bool&lt;/span&gt;   (f x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, nothing too fancy — mostly plumbing along the &lt;em&gt;aeson&lt;/em&gt; library’s primitive constructors.&lt;/p&gt;
&lt;h3 id=&#34;covariance-vs-contravariance&#34;&gt;Covariance vs Contravariance&lt;/h3&gt;
&lt;p&gt;Before we go further, let’s take a moment to pause and discuss the difference between covariant and contravariant functors, and the usefulness of those concepts. “Covariant” functors (or capital-F &lt;code&gt;Functor&lt;/code&gt;s in Haskell) are functors &lt;code&gt;f&lt;/code&gt; where you can consider &lt;code&gt;f a&lt;/code&gt; as a “producer” of &lt;code&gt;a&lt;/code&gt; — for example, &lt;code&gt;Schema a&lt;/code&gt; from our parsing section is a thing you can use to parse/produce an &lt;code&gt;a&lt;/code&gt; out of a bytestring. These are things where it makes sense to &lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;: if you have a producer of &lt;code&gt;a&lt;/code&gt;s, you can always “post-filter” the result with an &lt;code&gt;a -&amp;gt; b&lt;/code&gt; to get a producer of &lt;code&gt;b&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;“Contravariant” functors (&lt;code&gt;Contravariant&lt;/code&gt; in Haskell) are functors &lt;code&gt;f&lt;/code&gt; where you can consider &lt;code&gt;f a&lt;/code&gt; as a “consumer” of &lt;code&gt;a&lt;/code&gt;. For example, &lt;code&gt;Primtive a&lt;/code&gt; (and the &lt;code&gt;Schema a&lt;/code&gt; we want to make) from our serializing section is something that consums &lt;code&gt;a&lt;/code&gt;s and produces json values. These are things where it makes sense to &lt;code&gt;contramap&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb37&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb37-1&#34;&gt;&lt;a href=&#34;#cb37-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb37-2&#34;&gt;&lt;a href=&#34;#cb37-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    contramap ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which says: if you have a consumer of &lt;code&gt;b&lt;/code&gt;s, you can always “pre-filter” the input with an &lt;code&gt;a -&amp;gt; b&lt;/code&gt; to get a consumer of &lt;code&gt;a&lt;/code&gt;s.&lt;/p&gt;
&lt;h3 id=&#34;deducing-dec&#34;&gt;Deducing Dec&lt;/h3&gt;
&lt;p&gt;Now, back on to building our &lt;code&gt;Schema&lt;/code&gt; type. Again, we might want to write something like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb38&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb38-1&#34;&gt;&lt;a href=&#34;#cb38-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-2&#34;&gt;&lt;a href=&#34;#cb38-2&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb38-3&#34;&gt;&lt;a href=&#34;#cb38-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     [&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb38-4&#34;&gt;&lt;a href=&#34;#cb38-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb38-5&#34;&gt;&lt;a href=&#34;#cb38-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-6&#34;&gt;&lt;a href=&#34;#cb38-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L26-L31&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-7&#34;&gt;&lt;a href=&#34;#cb38-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-8&#34;&gt;&lt;a href=&#34;#cb38-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-9&#34;&gt;&lt;a href=&#34;#cb38-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-10&#34;&gt;&lt;a href=&#34;#cb38-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we have a problem here (incidentally, it’s the opposite of the problem we had in the previous case). &lt;code&gt;Choice a&lt;/code&gt; doesn’t quite make sense as the sum type consumer for &lt;code&gt;Schema a&lt;/code&gt;, because each &lt;code&gt;Choice&lt;/code&gt; is only meant to handle the types in a &lt;em&gt;specific&lt;/em&gt; branch. For example, in our &lt;code&gt;Customer&lt;/code&gt; example, for the &lt;code&gt;CPerson&lt;/code&gt; branch we need a &lt;code&gt;Choice (String, Int)&lt;/code&gt; to consume its contents, and in the &lt;code&gt;CBusiness&lt;/code&gt; branch we need a &lt;code&gt;Choice Int&lt;/code&gt; to consume its contents.&lt;/p&gt;
&lt;p&gt;What we need is a way to express a hetereogenous collection/sequence of &lt;code&gt;Choice a&lt;/code&gt;, coupled with a way of “choosing” exactly one of them to handle one form that our input &lt;code&gt;a&lt;/code&gt; can take. A type that says “use exactly one of a bunch of &lt;code&gt;Choice&lt;/code&gt;s of different &lt;code&gt;x&lt;/code&gt;s, and choose one to dispatch depending on what &lt;code&gt;a&lt;/code&gt; we get”. So how do we find the tool we need?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If&lt;/em&gt; you are already familiar with contravariant abstractions (but who is?) you might recognize this as the essence of the &lt;a href=&#34;https://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant-Divisible.html#g:6&#34;&gt;Decidable&lt;/a&gt; typeclass, from the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/contravariant&#34;&gt;contravariant&lt;/a&gt;&lt;/em&gt; library…or more accurately, “Decidable without a Divisible constraint”, which is &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Conclude.html&#34;&gt;Conclude&lt;/a&gt;. A &lt;code&gt;Conclude f&lt;/code&gt; allows you to combine two &lt;code&gt;f&lt;/code&gt; values, and one will be picked to use based on inspection of the input value. Upon recognizing this, we look for find a way to give &lt;code&gt;Choice&lt;/code&gt; some &lt;code&gt;Conclude&lt;/code&gt; interface and search up “the type that gives us a free &lt;code&gt;Conclude&lt;/code&gt; structure”. Following that search, we arrive at &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Divisible-Free.html&#34;&gt;&lt;code&gt;Dec&lt;/code&gt;&lt;/a&gt;, and so we use &lt;code&gt;Dec Choice a&lt;/code&gt; for our sum type consumer.&lt;/p&gt;
&lt;p&gt;But let’s say you’re like the vast majority of Haskell users and have never had any reason to look at the contravariant abstraction hierarchy. How would you think of this?&lt;/p&gt;
&lt;p&gt;Like before, we could also look through the &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html&#34;&gt;functor combinatorpedia&lt;/a&gt; (in specific, the contravariant section) and find:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html#dec-dec1&#34;&gt;&lt;strong&gt;Dec / Dec1&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s, one of which will be chosen to consume the overall input.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;f x&lt;/code&gt; is a consumer of &lt;code&gt;x&lt;/code&gt;s, then &lt;code&gt;Dec f a&lt;/code&gt; is a consumer of &lt;code&gt;a&lt;/code&gt;s that does its job by choosing a single one of those &lt;code&gt;f&lt;/code&gt;s to handle that consumption, based on what &lt;code&gt;a&lt;/code&gt; is received.&lt;/p&gt;
&lt;p&gt;Contrast this with &lt;code&gt;Div&lt;/code&gt;, where the multiple &lt;code&gt;f&lt;/code&gt; actions are &lt;em&gt;all&lt;/em&gt; used to consume the input. &lt;code&gt;Dec&lt;/code&gt; only uses &lt;em&gt;one single&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; action to consume the input, chosen at consumption time.&lt;/p&gt;
&lt;p&gt;For example, let’s say you had a type &lt;code&gt;Socket a&lt;/code&gt; which represents some IO channel or socket that is expecting to receive &lt;code&gt;a&lt;/code&gt;s. A &lt;code&gt;Dec Socket b&lt;/code&gt; would be a collection of sockets that expects a single &lt;code&gt;b&lt;/code&gt; overall, and will pick exactly one of those &lt;code&gt;Socket&lt;/code&gt;s to handle that &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sounds like exactly what we need! It also gives us a nice hint of what we might want to use for &lt;code&gt;RecordType&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;building-dec&#34;&gt;Building Dec&lt;/h3&gt;
&lt;p&gt;With this, we can write our final &lt;code&gt;Schema&lt;/code&gt; type.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb39&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb39-1&#34;&gt;&lt;a href=&#34;#cb39-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L21-L39&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-2&#34;&gt;&lt;a href=&#34;#cb39-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-3&#34;&gt;&lt;a href=&#34;#cb39-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-4&#34;&gt;&lt;a href=&#34;#cb39-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb39-5&#34;&gt;&lt;a href=&#34;#cb39-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb39-6&#34;&gt;&lt;a href=&#34;#cb39-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb39-7&#34;&gt;&lt;a href=&#34;#cb39-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-8&#34;&gt;&lt;a href=&#34;#cb39-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-9&#34;&gt;&lt;a href=&#34;#cb39-9&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-10&#34;&gt;&lt;a href=&#34;#cb39-10&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb39-11&#34;&gt;&lt;a href=&#34;#cb39-11&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb39-12&#34;&gt;&lt;a href=&#34;#cb39-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-13&#34;&gt;&lt;a href=&#34;#cb39-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-14&#34;&gt;&lt;a href=&#34;#cb39-14&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-15&#34;&gt;&lt;a href=&#34;#cb39-15&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb39-16&#34;&gt;&lt;a href=&#34;#cb39-16&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb39-17&#34;&gt;&lt;a href=&#34;#cb39-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-18&#34;&gt;&lt;a href=&#34;#cb39-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-19&#34;&gt;&lt;a href=&#34;#cb39-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb39-20&#34;&gt;&lt;a href=&#34;#cb39-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb39-21&#34;&gt;&lt;a href=&#34;#cb39-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I switched from &lt;code&gt;[Field a]&lt;/code&gt; to &lt;code&gt;Div Field a&lt;/code&gt; — the two are the same (&lt;code&gt;Div Field a&lt;/code&gt; is essentially a newtype wrapper over &lt;code&gt;[Field a]&lt;/code&gt;), but the latter has useful functor combinator typeclass instance methods like &lt;code&gt;interpret&lt;/code&gt; (like &lt;code&gt;ListF&lt;/code&gt; before)&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. And, again, I feel like it illustrates the symmetry between sum types and record types; &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt; are opposite types, as &lt;code&gt;Dec&lt;/code&gt; represents a contravariant choice between different choices, and &lt;code&gt;Div&lt;/code&gt; represents a contravariant merger between different consumers. It makes more clear the duality between product types and sum types.&lt;/p&gt;
&lt;p&gt;We can assemble our &lt;code&gt;Customer&lt;/code&gt; schema, in a way that looks a lot like our parser schema:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb40&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb40-1&#34;&gt;&lt;a href=&#34;#cb40-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L72-L87&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-2&#34;&gt;&lt;a href=&#34;#cb40-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-3&#34;&gt;&lt;a href=&#34;#cb40-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-4&#34;&gt;&lt;a href=&#34;#cb40-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-5&#34;&gt;&lt;a href=&#34;#cb40-5&#34;&gt;&lt;/a&gt;    decide (\&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; x y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (x, y); &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb40-6&#34;&gt;&lt;a href=&#34;#cb40-6&#34;&gt;&lt;/a&gt;      (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-7&#34;&gt;&lt;a href=&#34;#cb40-7&#34;&gt;&lt;/a&gt;        { choiceName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-8&#34;&gt;&lt;a href=&#34;#cb40-8&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; divided&lt;/span&gt;
&lt;span id=&#34;cb40-9&#34;&gt;&lt;a href=&#34;#cb40-9&#34;&gt;&lt;/a&gt;            (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString })&lt;/span&gt;
&lt;span id=&#34;cb40-10&#34;&gt;&lt;a href=&#34;#cb40-10&#34;&gt;&lt;/a&gt;            (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    })&lt;/span&gt;
&lt;span id=&#34;cb40-11&#34;&gt;&lt;a href=&#34;#cb40-11&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb40-12&#34;&gt;&lt;a href=&#34;#cb40-12&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;
&lt;span id=&#34;cb40-13&#34;&gt;&lt;a href=&#34;#cb40-13&#34;&gt;&lt;/a&gt;      (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-14&#34;&gt;&lt;a href=&#34;#cb40-14&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-15&#34;&gt;&lt;a href=&#34;#cb40-15&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-16&#34;&gt;&lt;a href=&#34;#cb40-16&#34;&gt;&lt;/a&gt;            inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb40-17&#34;&gt;&lt;a href=&#34;#cb40-17&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb40-18&#34;&gt;&lt;a href=&#34;#cb40-18&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use a few contravariant combinators to combine and merge contravariant functors values (like &lt;code&gt;Div Field a&lt;/code&gt; and &lt;code&gt;Dec Choice a&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;decide&lt;/code&gt; works like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb41&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb41-1&#34;&gt;&lt;a href=&#34;#cb41-1&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb41-2&#34;&gt;&lt;a href=&#34;#cb41-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb41-3&#34;&gt;&lt;a href=&#34;#cb41-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c)    &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-4&#34;&gt;&lt;a href=&#34;#cb41-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b                  &lt;span class=&#34;co&#34;&gt;-- ^ handle first branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-5&#34;&gt;&lt;a href=&#34;#cb41-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f c                  &lt;span class=&#34;co&#34;&gt;-- ^ handle second branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-6&#34;&gt;&lt;a href=&#34;#cb41-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a                  &lt;span class=&#34;co&#34;&gt;-- ^ overall handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-7&#34;&gt;&lt;a href=&#34;#cb41-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-8&#34;&gt;&lt;a href=&#34;#cb41-8&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb41-9&#34;&gt;&lt;a href=&#34;#cb41-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-10&#34;&gt;&lt;a href=&#34;#cb41-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)                 &lt;span class=&#34;co&#34;&gt;-- ^ handle CPerson branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-11&#34;&gt;&lt;a href=&#34;#cb41-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;                           &lt;span class=&#34;co&#34;&gt;-- ^ handle CBusiness branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-12&#34;&gt;&lt;a href=&#34;#cb41-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;divided&lt;/code&gt; works like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb42&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb42-1&#34;&gt;&lt;a href=&#34;#cb42-1&#34;&gt;&lt;/a&gt;divided&lt;/span&gt;
&lt;span id=&#34;cb42-2&#34;&gt;&lt;a href=&#34;#cb42-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb42-3&#34;&gt;&lt;a href=&#34;#cb42-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f a          &lt;span class=&#34;co&#34;&gt;-- ^ first handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-4&#34;&gt;&lt;a href=&#34;#cb42-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b          &lt;span class=&#34;co&#34;&gt;-- ^ second handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-5&#34;&gt;&lt;a href=&#34;#cb42-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f (a, b)     &lt;span class=&#34;co&#34;&gt;-- ^ merged handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-6&#34;&gt;&lt;a href=&#34;#cb42-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-7&#34;&gt;&lt;a href=&#34;#cb42-7&#34;&gt;&lt;/a&gt;divided&lt;/span&gt;
&lt;span id=&#34;cb42-8&#34;&gt;&lt;a href=&#34;#cb42-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpName field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-9&#34;&gt;&lt;a href=&#34;#cb42-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;             &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpAge field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-10&#34;&gt;&lt;a href=&#34;#cb42-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ handle both together&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;interpreting-dec&#34;&gt;Interpreting Dec&lt;/h3&gt;
&lt;p&gt;To write our schema serializers, we can use &lt;code&gt;interpret&lt;/code&gt; again:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb43&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb43-1&#34;&gt;&lt;a href=&#34;#cb43-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb43-2&#34;&gt;&lt;a href=&#34;#cb43-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; g  &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, what should we choose as our choice of &lt;code&gt;g&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb44&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb44-1&#34;&gt;&lt;a href=&#34;#cb44-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Well, how do we want to “use” a &lt;code&gt;Choice a&lt;/code&gt;? Remember that &lt;code&gt;Schema a&lt;/code&gt; encodes a way to serialize an &lt;code&gt;a&lt;/code&gt; to an json value. A &lt;code&gt;Choice a&lt;/code&gt; would encode a way to serialize an &lt;code&gt;a&lt;/code&gt; into a json value. We want to turn a &lt;code&gt;Choice a&lt;/code&gt; into an &lt;code&gt;a -&amp;gt; Aeson.Value&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb45&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb45-1&#34;&gt;&lt;a href=&#34;#cb45-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb45-2&#34;&gt;&lt;a href=&#34;#cb45-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb45-3&#34;&gt;&lt;a href=&#34;#cb45-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- is supposed to match up with&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb45-4&#34;&gt;&lt;a href=&#34;#cb45-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, we need to pick some &lt;code&gt;g&lt;/code&gt; where &lt;code&gt;g a&lt;/code&gt; is &lt;code&gt;a -&amp;gt; Aeson.Value&lt;/code&gt;. This is exactly &lt;code&gt;Op&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Contravariant.html&#34;&gt;Data.Functor.Contravariant&lt;/a&gt;&lt;/em&gt;, in &lt;em&gt;base&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb46&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb46-1&#34;&gt;&lt;a href=&#34;#cb46-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getOp ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, if we write&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb47&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb47-1&#34;&gt;&lt;a href=&#34;#cb47-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb47-2&#34;&gt;&lt;a href=&#34;#cb47-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb47-3&#34;&gt;&lt;a href=&#34;#cb47-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- a newtype wrapper away from&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb47-4&#34;&gt;&lt;a href=&#34;#cb47-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then we have&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb48&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb48-1&#34;&gt;&lt;a href=&#34;#cb48-1&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb48-2&#34;&gt;&lt;a href=&#34;#cb48-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb48-3&#34;&gt;&lt;a href=&#34;#cb48-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- a newtype wrapper away from&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb48-4&#34;&gt;&lt;a href=&#34;#cb48-4&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s write it!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb49&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb49-1&#34;&gt;&lt;a href=&#34;#cb49-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L128-L132&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb49-2&#34;&gt;&lt;a href=&#34;#cb49-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb49-3&#34;&gt;&lt;a href=&#34;#cb49-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb49-4&#34;&gt;&lt;a href=&#34;#cb49-4&#34;&gt;&lt;/a&gt;choiceToValue (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb49-5&#34;&gt;&lt;a href=&#34;#cb49-5&#34;&gt;&lt;/a&gt;    [ &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; T.pack name&lt;/span&gt;
&lt;span id=&#34;cb49-6&#34;&gt;&lt;a href=&#34;#cb49-6&#34;&gt;&lt;/a&gt;    , &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x&lt;/span&gt;
&lt;span id=&#34;cb49-7&#34;&gt;&lt;a href=&#34;#cb49-7&#34;&gt;&lt;/a&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now onto &lt;code&gt;RecordType&lt;/code&gt;’s &lt;code&gt;Div Field&lt;/code&gt;. Here, we want to build an object using &lt;code&gt;Aeson.object :: [Aeson.Pair] -&amp;gt; Aeson.Value&lt;/code&gt; (one way that the &lt;em&gt;aeson&lt;/em&gt; library allows us to build objects). Therefore, our type for &lt;code&gt;fieldToValue&lt;/code&gt; should be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb50&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb50-1&#34;&gt;&lt;a href=&#34;#cb50-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This looks familiar; it’s the same thing as before, but with &lt;code&gt;Op [Aeson.Pair]&lt;/code&gt; instead of &lt;code&gt;Op Aeson.Value&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb51&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb51-1&#34;&gt;&lt;a href=&#34;#cb51-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb51-2&#34;&gt;&lt;a href=&#34;#cb51-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-3&#34;&gt;&lt;a href=&#34;#cb51-3&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb51-4&#34;&gt;&lt;a href=&#34;#cb51-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-5&#34;&gt;&lt;a href=&#34;#cb51-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- a newtype wrapper away from&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-6&#34;&gt;&lt;a href=&#34;#cb51-6&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can go ahead and write it out, actually:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb52&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb52-1&#34;&gt;&lt;a href=&#34;#cb52-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L134-L136&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-2&#34;&gt;&lt;a href=&#34;#cb52-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-3&#34;&gt;&lt;a href=&#34;#cb52-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb52-4&#34;&gt;&lt;a href=&#34;#cb52-4&#34;&gt;&lt;/a&gt;fieldToValue (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-5&#34;&gt;&lt;a href=&#34;#cb52-5&#34;&gt;&lt;/a&gt;    [T.pack name &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that this behavior relies on the fact that the &lt;code&gt;interpret&lt;/code&gt; instance for &lt;code&gt;Div&lt;/code&gt; — using the &lt;code&gt;Divise&lt;/code&gt; instance for &lt;code&gt;Op r&lt;/code&gt; — will combine the &lt;code&gt;[Aeson.Pair]&lt;/code&gt; list monoidally, concatenating the results of calling &lt;code&gt;fieldToValue&lt;/code&gt; on every &lt;code&gt;Field&lt;/code&gt; in the &lt;code&gt;Div Field a&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;We should now have enough to write our entire serializer:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb53&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb53-1&#34;&gt;&lt;a href=&#34;#cb53-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L119-L126&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-2&#34;&gt;&lt;a href=&#34;#cb53-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-3&#34;&gt;&lt;a href=&#34;#cb53-3&#34;&gt;&lt;/a&gt;schemaToValue&lt;/span&gt;
&lt;span id=&#34;cb53-4&#34;&gt;&lt;a href=&#34;#cb53-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb53-5&#34;&gt;&lt;a href=&#34;#cb53-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb53-6&#34;&gt;&lt;a href=&#34;#cb53-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-7&#34;&gt;&lt;a href=&#34;#cb53-7&#34;&gt;&lt;/a&gt;schemaToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-8&#34;&gt;&lt;a href=&#34;#cb53-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; getOp (interpret choiceToValue cs)&lt;/span&gt;
&lt;span id=&#34;cb53-9&#34;&gt;&lt;a href=&#34;#cb53-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; getOp (interpret fieldToValue fs)&lt;/span&gt;
&lt;span id=&#34;cb53-10&#34;&gt;&lt;a href=&#34;#cb53-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primToValue p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running our &lt;code&gt;schemaToValue&lt;/code&gt; on a sample &lt;code&gt;Person&lt;/code&gt; gives the json value we expect:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ghci&amp;gt; Aeson.encode (schemaToValue customerSchema (CPerson &amp;quot;Sam&amp;quot; 40))
{&amp;quot;tag&amp;quot;:&amp;quot;Person&amp;quot;,&amp;quot;contents&amp;quot;:{&amp;quot;Age&amp;quot;:40,&amp;quot;Name&amp;quot;:&amp;quot;Sam&amp;quot;}}&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;some-convenience&#34;&gt;Some Convenience&lt;/h4&gt;
&lt;p&gt;Note that this contravariant interpretation pattern (wrapping in &lt;code&gt;Op&lt;/code&gt; and then unwrapping it again to run it) is so common that &lt;em&gt;functor-combinators&lt;/em&gt; has a helper function to make things a bit neater:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb55&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb55-1&#34;&gt;&lt;a href=&#34;#cb55-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;iapply  ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb55-2&#34;&gt;&lt;a href=&#34;#cb55-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;ifanout ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With these we could write&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb56&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb56-1&#34;&gt;&lt;a href=&#34;#cb56-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb56-2&#34;&gt;&lt;a href=&#34;#cb56-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb57&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb57-1&#34;&gt;&lt;a href=&#34;#cb57-1&#34;&gt;&lt;/a&gt;iapply&lt;span class=&#34;ot&#34;&gt; choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb57-2&#34;&gt;&lt;a href=&#34;#cb57-2&#34;&gt;&lt;/a&gt;ifanout&lt;span class=&#34;ot&#34;&gt; fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;backporting-documentation-1&#34;&gt;Backporting documentation&lt;/h3&gt;
&lt;p&gt;Because our new structure is pretty much the same as before (data types wrapped by functor combinators), and &lt;code&gt;Div&lt;/code&gt;/&lt;code&gt;Dec&lt;/code&gt; support &lt;code&gt;htoList&lt;/code&gt; just like &lt;code&gt;Ap&lt;/code&gt;/&lt;code&gt;ListF&lt;/code&gt; did before, the implementation of &lt;code&gt;schemaDoc&lt;/code&gt; is pretty much word-for-word identical as it was for our parser schema:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb58&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb58-1&#34;&gt;&lt;a href=&#34;#cb58-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L89-L116&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-2&#34;&gt;&lt;a href=&#34;#cb58-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-3&#34;&gt;&lt;a href=&#34;#cb58-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb58-4&#34;&gt;&lt;a href=&#34;#cb58-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-5&#34;&gt;&lt;a href=&#34;#cb58-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-6&#34;&gt;&lt;a href=&#34;#cb58-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-7&#34;&gt;&lt;a href=&#34;#cb58-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-8&#34;&gt;&lt;a href=&#34;#cb58-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb58-9&#34;&gt;&lt;a href=&#34;#cb58-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb58-10&#34;&gt;&lt;a href=&#34;#cb58-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-11&#34;&gt;&lt;a href=&#34;#cb58-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb58-12&#34;&gt;&lt;a href=&#34;#cb58-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb58-13&#34;&gt;&lt;a href=&#34;#cb58-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb58-14&#34;&gt;&lt;a href=&#34;#cb58-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb58-15&#34;&gt;&lt;a href=&#34;#cb58-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-16&#34;&gt;&lt;a href=&#34;#cb58-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-17&#34;&gt;&lt;a href=&#34;#cb58-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb58-18&#34;&gt;&lt;a href=&#34;#cb58-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb58-19&#34;&gt;&lt;a href=&#34;#cb58-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb58-20&#34;&gt;&lt;a href=&#34;#cb58-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb58-21&#34;&gt;&lt;a href=&#34;#cb58-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-22&#34;&gt;&lt;a href=&#34;#cb58-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-23&#34;&gt;&lt;a href=&#34;#cb58-23&#34;&gt;&lt;/a&gt;    fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb58-24&#34;&gt;&lt;a href=&#34;#cb58-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-25&#34;&gt;&lt;a href=&#34;#cb58-25&#34;&gt;&lt;/a&gt;    choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb58-26&#34;&gt;&lt;a href=&#34;#cb58-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-27&#34;&gt;&lt;a href=&#34;#cb58-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-28&#34;&gt;&lt;a href=&#34;#cb58-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-29&#34;&gt;&lt;a href=&#34;#cb58-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-30&#34;&gt;&lt;a href=&#34;#cb58-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat!&lt;/p&gt;
&lt;h2 id=&#34;looking-forward&#34;&gt;Looking Forward&lt;/h2&gt;
&lt;p&gt;We first started with a simple structure to represent our schema. We then added &lt;em&gt;covariant&lt;/em&gt; capabilities to get us parser generation. Then we added &lt;em&gt;contravariant&lt;/em&gt; capabilities to get us serializers.&lt;/p&gt;
&lt;p&gt;The next step might be to add &lt;em&gt;both&lt;/em&gt; enhancements to the same structure! The benefits for this seem pretty significant: we can write our structure once (less code, less bugs), and we also write our serializer, parser, and documenting functions in a way that are automatically kept in-sync, and can never be incompatible with each other. Solving the documentation rot and mismatched parser/serializer problem in one stroke!&lt;/p&gt;
&lt;p&gt;For this, we’ll wait until the next post, where we explore not one, but two ways to combine our two capabilities into something known as an &lt;em&gt;invariant&lt;/em&gt; functor!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html&#34;&gt;Proceed to the next post here!&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;And, if we want it, it has the more useful &lt;code&gt;Contravariant&lt;/code&gt; instance: &lt;code&gt;contramap :: (a -&amp;gt; b) -&amp;gt; Div Field b -&amp;gt; Div Field a&lt;/code&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html</guid><pubDate>Tue, 18 Aug 2020 16:45:04 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-08-18</date></item><item><title>Introducing the mutable library</title><link>https://blog.jle.im/entry/introducing-the-mutable-library.html</link><description>&lt;p&gt;&lt;strong&gt;mutable&lt;/strong&gt;: &lt;a href=&#34;https://mutable.jle.im/&#34;&gt;documentation&lt;/a&gt; / &lt;a href=&#34;http://hackage.haskell.org/package/mutable&#34;&gt;reference&lt;/a&gt; / &lt;a href=&#34;https://github.com/mstksg/mutable&#34;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Note:&lt;/em&gt; This post has been heavily revised to reflect &lt;em&gt;mutable-0.2.0.0&lt;/em&gt;, as of July 2020. For reference, &lt;a href=&#34;https://github.com/mstksg/inCode/blob/7c25dd3798955e8287d31774da6fe34015256b5a/entry/introducing-the-mutable-library.md&#34;&gt;the original post&lt;/a&gt; is available on github.)&lt;/p&gt;
&lt;p&gt;I’m excited to announce the release of the &lt;em&gt;&lt;a href=&#34;https://mutable.jle.im/&#34;&gt;mutable&lt;/a&gt;&lt;/em&gt; library!&lt;/p&gt;
&lt;p&gt;The library offers what I call &lt;em&gt;beautiful mutable values&lt;/em&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; — automatic, composable piecewise-mutable references for your data types. Sort of like an automatically generated &lt;code&gt;MVector&lt;/code&gt;, but for all your &lt;code&gt;ADT&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;My high-level goal was a composable and overhead-free solution for dealing with mutable values in Haskell in a type-safe and clean way. After all, why do imperative languages have to have all the fun? In Haskell, we can have the best of both worlds: efficient and clean mutable algorithms &lt;em&gt;and&lt;/em&gt; type safety.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://mutable.jle.im/&#34;&gt;official documentation and homepage is here&lt;/a&gt;, so it’s a good read if you want to be introduced to how to use the library and where it is most effective. But I’m going to use this blog post to talk about &lt;em&gt;why&lt;/em&gt; I wrote the library, some of the neat things you can do with it, and the techniques that went into writing it.&lt;/p&gt;
&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The original motivation for this comes from my development of &lt;em&gt;&lt;a href=&#34;https://backprop.jle.im/&#34;&gt;backprop&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&#34;https://github.com/mstksg/backprop-learn&#34;&gt;backprop-learn&lt;/a&gt;&lt;/em&gt;, as I was trying to adapt my &lt;a href=&#34;https://blog.jle.im/entries/series/+functional-models.html&#34;&gt;Functional Models&lt;/a&gt; framework to efficient Haskell code.&lt;/p&gt;
&lt;p&gt;To properly train Artificial Neural Networks with Haskell, you need to do a lot of independent piecewise mutations to matrices and vectors. This becomes inefficient, quickly, because you have to do a lot of copying in the process for pure vectors and neural network weights. This problem also comes up for efficient simulations that require mutating many different components independently under a tight loop.&lt;/p&gt;
&lt;h3 id=&#34;piecewise-mutable&#34;&gt;Piecewise-Mutable&lt;/h3&gt;
&lt;p&gt;First of all, what do I mean by “piecewise-mutable”? Well, a simple example is the mutable vector type, where piecewise-mutable edits are able to save a lot of time and memory allocation.&lt;/p&gt;
&lt;p&gt;If we want to edit the first item in a vector multiple times, this is extremely inefficient with a pure vector:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;addFirst ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;addFirst xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;iterate&lt;/span&gt; incr xs &lt;span class=&#34;op&#34;&gt;!!&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;    incr v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; v &lt;span class=&#34;op&#34;&gt;V.//&lt;/span&gt; [(&lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;, (v &lt;span class=&#34;op&#34;&gt;V.!&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s because &lt;code&gt;addFirst&lt;/code&gt; will copy over the entire vector for every step — every single item, even if not modified, will be copied one million times. It is &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?O%28n%2Al%29&#34; alt=&#34;O(n*l)&#34; title=&#34;O(n*l)&#34; /&gt; in memory updates — it is very bad for long vectors or large matrices.&lt;/p&gt;
&lt;p&gt;However, this is extremely efficient with a mutable vector:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;addFirst ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;addFirst xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;    v &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; V.thaw xs&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;        MV.modify v &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;    V.freeze v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(this action is run in &lt;code&gt;ST&lt;/code&gt;, the monad for mutable actions that is provided by GHC)&lt;/p&gt;
&lt;p&gt;This is because all of the other items in the vector are kept the same and not copied-over over the course of one million updates. It is &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?O%28n%2Bl%29&#34; alt=&#34;O(n+l)&#34; title=&#34;O(n+l)&#34; /&gt; in memory updates. It is very good even for long vectors or large matrices.&lt;/p&gt;
&lt;p&gt;This situation is somewhat contrived, but it isolates a problem that many programs face. A more common situation might be that you have two functions that each modify different items in a vector in sequence, and you want to run them many times interleaved, or one after the other.&lt;/p&gt;
&lt;h3 id=&#34;composite-datatype&#34;&gt;Composite Datatype&lt;/h3&gt;
&lt;p&gt;That was an example of using piecewise mutability for vectors, but it’s not exactly scalable. That’s because it always requires having a separate type for the &lt;em&gt;pure&lt;/em&gt; type and the &lt;em&gt;value&lt;/em&gt; type. We’re lucky enough to have one for &lt;code&gt;Vector&lt;/code&gt;…but what about for our own custom types? That’s a lot of headache.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TV&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; tv1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;                 ,&lt;span class=&#34;ot&#34;&gt; tv2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;                 }&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To use this in a “piecewise-mutable” way, we would need a separate “mutable” version:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVecRef&lt;/span&gt; s &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TVR&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; tvr1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MVector&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;                       ,&lt;span class=&#34;ot&#34;&gt; tvr2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MVector&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;                       }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we can do things like “mutate only the first item in the first vector” a million times, and be efficient with it.&lt;/p&gt;
&lt;p&gt;We’d have to write functions to “thaw” and “freeze”&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;thawTwoVec ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;TwoVecRef&lt;/span&gt; s)&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;thawTwoVec (&lt;span class=&#34;dt&#34;&gt;TV&lt;/span&gt; x y) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TVR&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; V.thaw x &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; V.thaw y&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;freezeTwoVec ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVecRef&lt;/span&gt; s &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;freezeTwoVec (&lt;span class=&#34;dt&#34;&gt;TVR&lt;/span&gt; u v) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TV&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; V.freeze u &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; V.freze v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It just doesn’t scale in a composable way. You’d have to create a second version of every data type.&lt;/p&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;p&gt;The library provides the &lt;code&gt;Mutable&lt;/code&gt; typeclass and the &lt;code&gt;GRef&lt;/code&gt; type, where &lt;code&gt;GRef s X&lt;/code&gt; is the automatically derived piecewise-mutable version of &lt;code&gt;X&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;GRef&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type &lt;code&gt;GRef s TwoVec&lt;/code&gt; is &lt;em&gt;exactly&lt;/em&gt; the &lt;code&gt;TwoVecRef&lt;/code&gt; that we defined earlier: it is a tuple of two &lt;code&gt;MVector&lt;/code&gt;s. It can do this because &lt;code&gt;Vector&lt;/code&gt; itself has a &lt;code&gt;Mutable&lt;/code&gt; instance, where its mutable version is &lt;code&gt;MVector&lt;/code&gt;. &lt;code&gt;GRef s TwoVec&lt;/code&gt; is essentially the “MVector” of &lt;code&gt;TwoVec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This now gives us &lt;code&gt;thawRef :: TwoVec -&amp;gt; ST s (GRef s TwoVec)&lt;/code&gt; and &lt;code&gt;freezeRef :: GRef s TwoVec -&amp;gt; ST s TwoVec&lt;/code&gt;, for free, so we can write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;addFirst ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;addFirst xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;    v &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; thawRef xs&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;      withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv1 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;        MV.modify u &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;    freezeRef v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will in-place edit only the first item in the &lt;code&gt;tv1&lt;/code&gt; field one million times, without ever needing to copy over the contents &lt;code&gt;tv2&lt;/code&gt;. Basically, it gives you a version of &lt;code&gt;TwoVec&lt;/code&gt; that you can modify in-place piecewise. You can compose two functions that each work piecewise on &lt;code&gt;TwoVec&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;mut1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s ()&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;mut1 v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv1 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv2 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;mut2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s ()&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;mut2 v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv1 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv2 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-16&#34;&gt;&lt;a href=&#34;#cb8-16&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;6&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-17&#34;&gt;&lt;a href=&#34;#cb8-17&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;7&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-18&#34;&gt;&lt;a href=&#34;#cb8-18&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-19&#34;&gt;&lt;a href=&#34;#cb8-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;doAMillion ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-20&#34;&gt;&lt;a href=&#34;#cb8-20&#34;&gt;&lt;/a&gt;doAMillion xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-21&#34;&gt;&lt;a href=&#34;#cb8-21&#34;&gt;&lt;/a&gt;    v &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; thawRef xs&lt;/span&gt;
&lt;span id=&#34;cb8-22&#34;&gt;&lt;a href=&#34;#cb8-22&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-23&#34;&gt;&lt;a href=&#34;#cb8-23&#34;&gt;&lt;/a&gt;      mut1 v&lt;/span&gt;
&lt;span id=&#34;cb8-24&#34;&gt;&lt;a href=&#34;#cb8-24&#34;&gt;&lt;/a&gt;      mut2 v&lt;/span&gt;
&lt;span id=&#34;cb8-25&#34;&gt;&lt;a href=&#34;#cb8-25&#34;&gt;&lt;/a&gt;    freezeRef v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The end result? You can now modify only a single component of your large composite data type (and even single items in vectors in them) without making nested copies every time.&lt;/p&gt;
&lt;h2 id=&#34;neat-consequences&#34;&gt;Neat Consequences&lt;/h2&gt;
&lt;h3 id=&#34;mutable-sum-types&#34;&gt;Mutable Sum Types&lt;/h3&gt;
&lt;p&gt;While developing the library, I accidentally also stumbled into a way of automatically deriving useful mutable sum types and data structures in Haskell. This was more or less a complete accident — I was writing the code to automatically generate &lt;code&gt;GRef&lt;/code&gt;, and needed to account for sum types somehow. The result was actually useful!&lt;/p&gt;
&lt;p&gt;For example, it is a publicly kept secret that Haskell’s list type — “linked lists”, are actually very different from the &lt;a href=&#34;https://en.wikipedia.org/wiki/Linked_list&#34;&gt;mutable linked lists&lt;/a&gt; encountered as a standard data structure in languages like Java and C++. As it turns out, using &lt;code&gt;GRef m [a]&lt;/code&gt; gives us exactly the mutable linked list type … for free!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nil&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Cons&lt;/span&gt; a (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;infixr&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;`Cons`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; m (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;GRef&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we are re-implementing the &lt;code&gt;List&lt;/code&gt; data structure from scratch just to show that there is nothing arbitrary going on with the default list — it works for any appropriately defined ADT. We could even do binary trees!&lt;/p&gt;
&lt;p&gt;Right away we can write functions to flesh out the API for a mutable linked list. For example, a function to check if a linked list is empty:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Check if a mutable linked list is currently empty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;isEmpty&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb10-5&#34;&gt;&lt;a href=&#34;#cb10-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-6&#34;&gt;&lt;a href=&#34;#cb10-6&#34;&gt;&lt;/a&gt;isEmpty &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; hasBranch (constrMB &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;_Nil)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is a function to “pop” a mutable linked list, giving us the first value and shifting the rest of the list up.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;popStack&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb11-5&#34;&gt;&lt;a href=&#34;#cb11-5&#34;&gt;&lt;/a&gt;popStack xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-6&#34;&gt;&lt;a href=&#34;#cb11-6&#34;&gt;&lt;/a&gt;    c &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; projectBranch (constrMB &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;_Cons) xs&lt;/span&gt;
&lt;span id=&#34;cb11-7&#34;&gt;&lt;a href=&#34;#cb11-7&#34;&gt;&lt;/a&gt;    forM c &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \(y, ys) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-8&#34;&gt;&lt;a href=&#34;#cb11-8&#34;&gt;&lt;/a&gt;      o &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; freezeRef y&lt;/span&gt;
&lt;span id=&#34;cb11-9&#34;&gt;&lt;a href=&#34;#cb11-9&#34;&gt;&lt;/a&gt;      moveRef xs ys&lt;/span&gt;
&lt;span id=&#34;cb11-10&#34;&gt;&lt;a href=&#34;#cb11-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; o&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a function to concatenate a second linked list to the end of a first one:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;concatLists&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-4&#34;&gt;&lt;a href=&#34;#cb12-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-5&#34;&gt;&lt;a href=&#34;#cb12-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s ()&lt;/span&gt;
&lt;span id=&#34;cb12-6&#34;&gt;&lt;a href=&#34;#cb12-6&#34;&gt;&lt;/a&gt;concatLists l1 l2 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-7&#34;&gt;&lt;a href=&#34;#cb12-7&#34;&gt;&lt;/a&gt;    c &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; projectBranch consBranch l1&lt;/span&gt;
&lt;span id=&#34;cb12-8&#34;&gt;&lt;a href=&#34;#cb12-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; c &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-9&#34;&gt;&lt;a href=&#34;#cb12-9&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;      &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; moveRef l1 l2&lt;/span&gt;
&lt;span id=&#34;cb12-10&#34;&gt;&lt;a href=&#34;#cb12-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; (_, xs) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; concatLists xs l2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;higher-kinded-data&#34;&gt;Higher-Kinded Data&lt;/h3&gt;
&lt;p&gt;I’m rather enamoured by the “&lt;a href=&#34;https://reasonablypolymorphic.com/blog/higher-kinded-data/&#34;&gt;higher-kinded data&lt;/a&gt;” pattern made popular by Sandy Maguire. It essentially eliminates the need for explicit getters and setters by making the data type &lt;em&gt;itself&lt;/em&gt; the thing that offers what you want, and you can get at it by just pattern matching.&lt;/p&gt;
&lt;p&gt;Because of this, if your data type is written in the “higher-kinded data” pattern, then &lt;code&gt;MyType f&lt;/code&gt; doubles as both the pure type &lt;em&gt;and&lt;/em&gt; the mutable type, just by choice of &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;MyTypeF Identity&lt;/code&gt; would be the pure version, and &lt;code&gt;MyTypeF (RefFor m)&lt;/code&gt; would be the mutable version.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; mtfInt    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HKD&lt;/span&gt; f &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; mtfDouble ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HKD&lt;/span&gt; f &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; mtfVec    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HKD&lt;/span&gt; f (&lt;span class=&#34;dt&#34;&gt;V.Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb13-6&#34;&gt;&lt;a href=&#34;#cb13-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-7&#34;&gt;&lt;a href=&#34;#cb13-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-8&#34;&gt;&lt;a href=&#34;#cb13-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-9&#34;&gt;&lt;a href=&#34;#cb13-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-10&#34;&gt;&lt;a href=&#34;#cb13-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-11&#34;&gt;&lt;a href=&#34;#cb13-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RefFor&lt;/span&gt; s)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can directly use it like a normal data type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;fl&#34;&gt;4.5&lt;/span&gt; (V.fromList [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;100&lt;/span&gt;])&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now, &lt;code&gt;MyTypeF (RefFor s)&lt;/code&gt; literally has mutable references as its fields. You can pattern match to get &lt;code&gt;rI :: MutVar s Int&lt;/code&gt;, &lt;code&gt;rD :: MutVar s Double&lt;/code&gt;, and &lt;code&gt;rV :: MVector s Double&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; rI rD&lt;span class=&#34;ot&#34;&gt; rV ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RefFor&lt;/span&gt; s)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the accessors work as well:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;mtfVec&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RefFor&lt;/span&gt; s)&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MVector&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can use it like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;    r&lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; rI rD rV) &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; thawRef &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;fl&#34;&gt;19.3&lt;/span&gt; (V.fromList [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;])&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-6&#34;&gt;&lt;a href=&#34;#cb17-6&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;co&#34;&gt;-- rI is just the &amp;#39;Int&amp;#39; ref&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-7&#34;&gt;&lt;a href=&#34;#cb17-7&#34;&gt;&lt;/a&gt;        modifyMutVar rI (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb17-8&#34;&gt;&lt;a href=&#34;#cb17-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-9&#34;&gt;&lt;a href=&#34;#cb17-9&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;co&#34;&gt;-- rV is the &amp;#39;MVector&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-10&#34;&gt;&lt;a href=&#34;#cb17-10&#34;&gt;&lt;/a&gt;        MV.modify rV (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;) &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-11&#34;&gt;&lt;a href=&#34;#cb17-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-12&#34;&gt;&lt;a href=&#34;#cb17-12&#34;&gt;&lt;/a&gt;    freezeRef r&lt;/span&gt;
&lt;span id=&#34;cb17-13&#34;&gt;&lt;a href=&#34;#cb17-13&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-14&#34;&gt;&lt;a href=&#34;#cb17-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- =&amp;gt; MTF 1000 19.3 [1001.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The “mutable version” of a type literally &lt;em&gt;is&lt;/em&gt; the ADT, if you use the higher-kinded data pattern!&lt;/p&gt;
&lt;h3 id=&#34;a-polymorphic-picture&#34;&gt;A Polymorphic Picture&lt;/h3&gt;
&lt;p&gt;One important thing to note when looking at the actual library — the examples in this post show the provided actions in &lt;code&gt;ST&lt;/code&gt;, the mutable actions monad provided by GHC. However, the library provides these actions polymorphic for all &lt;code&gt;PrimMonad m&lt;/code&gt;, an abstraction provided by the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/primitive&#34;&gt;primitive&lt;/a&gt;&lt;/em&gt; library to generalize for all “mutable monads” (like &lt;code&gt;IO&lt;/code&gt; and monad transformers applied to &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt;), as long as &lt;code&gt;PrimState m ~ s&lt;/code&gt;, so you can run them in whatever useful mutable monads you’d like.&lt;/p&gt;
&lt;h2 id=&#34;reflections-on-generic&#34;&gt;Reflections on Generic&lt;/h2&gt;
&lt;p&gt;This library is pretty much powered 95% by GHC Generics, as the name &lt;code&gt;GRef&lt;/code&gt; implies. GHC Generics is probably one of the single most powerful tools we have in Hasekll-the-language for writing typesafe abstractions and eliminating all the boilerplate.&lt;/p&gt;
&lt;p&gt;The structure of the &lt;code&gt;GRef&lt;/code&gt; data type is completely determined by using the &lt;em&gt;GHC.Generics&lt;/em&gt; &lt;code&gt;Rep&lt;/code&gt; of an algebraic data type with a &lt;code&gt;Generic&lt;/code&gt; instance. It breaks apart the products and sums and turns them into the mutable references you &lt;em&gt;would&lt;/em&gt; normally write by hand.&lt;/p&gt;
&lt;p&gt;Writing &lt;code&gt;GRef&lt;/code&gt; itself was actually very pleasant: it just involves matching up generic pieces with the references they represent. “What is the reference for a constant value? What is the reference for a product type? What is the reference for a sum type?” And, in the process of answering those questions, I ended up discovering something new (as shown in the section above about mutable linked lists).&lt;/p&gt;
&lt;p&gt;Generics also powers the &lt;em&gt;higher-kinded data&lt;/em&gt; based systems, which can add a lot of syntactic niceness to everything if you decide to use it.&lt;/p&gt;
&lt;p&gt;Still, I understand not everyone wants to restructure their data types in terms of higher-kinded data … there are a lot of practical issues to doing so, and it doesn’t really work well with nested data types. For that, I turned to &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/generic-lens&#34;&gt;generic-lens&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;generic-lens&lt;/em&gt; is what powers the OverloadedLabels-based field accessor methods that let you work with &lt;code&gt;GRef&lt;/code&gt;s in a seamless way, by being able to do &lt;code&gt;withField #blah&lt;/code&gt;, etc., instead of having to directly match on the &lt;code&gt;GRef&lt;/code&gt; value’s internal contents (which can be messy, admittedly). It also allows you to do &lt;code&gt;withPos @2&lt;/code&gt; to get the second item in your &lt;code&gt;GRef&lt;/code&gt;, and &lt;code&gt;withTuple&lt;/code&gt; to allow you to get the mutable fields in your data type as a tuple.&lt;/p&gt;
&lt;p&gt;I was originally going to implement the field accessors myself, looking to &lt;em&gt;generic-lens&lt;/em&gt; for inspiration. However, when I looked at the library’s internals, I realized there was a lot more going on than I had originally thought. But, looking at what was exported, I realized that the library was well-designed enough that I could actually directly use its generic implementations for &lt;em&gt;mutable&lt;/em&gt;! As a result, the field/position/tuple accessor code actually required no mucking around with generics at all — I could leverage &lt;em&gt;generic-lens&lt;/em&gt;, which was powerful enough to allow me to eliminate all of my generics code.&lt;/p&gt;
&lt;p&gt;I strongly recommend anyone looking to do things involving generic access to fields to look at &lt;em&gt;generic-lens&lt;/em&gt; to see if it can eliminate all your generics code as well!&lt;/p&gt;
&lt;p&gt;Unfortunately, I wasn’t able to re-use the code for the “constructor” access (as seen with &lt;code&gt;constrMB #_Cons&lt;/code&gt; earlier) — but I could use it as inspiration to write my own. The library offers a very clean and well-written pattern to doing things like this that I probably would have spent a long time trying to figure out, if I had to do it from scratch.&lt;/p&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;I learned a lot from GHC Generics writing this library — in a sense, the library is pretty much completely an application of GHC Generics, without much new concepts beyond that.&lt;/p&gt;
&lt;p&gt;My next step is to equip &lt;em&gt;backprop&lt;/em&gt; to use &lt;code&gt;Mutable&lt;/code&gt; instead of its &lt;code&gt;Backprop&lt;/code&gt; typeclass, so it can do in-place mutation of composite data types for much faster backpropagation.&lt;/p&gt;
&lt;p&gt;However, my newly gained experience with generics from writing this library can actually do a lot to improve the ergonomics of &lt;em&gt;backprop&lt;/em&gt; as well — in particular, with &lt;code&gt;BVar&lt;/code&gt;, which has always been very annoying to work with, even with the lens-based API offered. Working with a &lt;code&gt;BVar&lt;/code&gt; as if it were a normal value has always been annoying, especially with product types. There are a lot of ways GHC generics can help this, that I am now only learning about. Check back soon — hopefully I’ll have something to show by then.&lt;/p&gt;
&lt;p&gt;Until then, happy mutating! And please let me know if you find any interesting applications of the library :D&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Okay so I don’t actually think the library is beautiful, I just like the way that “beautiful mutable values” sounds when you say it out loud.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-mutable-library.html</guid><pubDate>Fri, 24 Jan 2020 02:16:52 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-01-24</date></item><item><title>Adjunctions in the wild: foldl</title><link>https://blog.jle.im/entry/foldl-adjunction.html</link><description>&lt;p&gt;I recently made a few connections that linked some different concepts in Haskell that I hadn’t realized before. They deal with one of my favorite “practical” libraries in Haskell, and also one of the more “profound” category theory-inspired abstractions in Haskell. In the process, it made the library a bit more useful to me, and also made the concept a bit more concrete and understandable to me.&lt;/p&gt;
&lt;p&gt;This post mainly goes through my thought process in finding this out — it’s very much a “how I think through this” sort of thing — in the end, the goal is to show how much this example made me further appreciate the conceptual idea of adjunctions and how they can pop up in interesting places in practical libraries. Unlike most of my other posts, it’s not about necessarily about how practically useful an abstraction is, but rather what insight it gives us to understanding its instances.&lt;/p&gt;
&lt;p&gt;The audience of this post is Haskellers with an understanding/appreciation of abstractions like &lt;code&gt;Applicative&lt;/code&gt;, but be aware that the final section is separately considered as a fun aside for those familiar with some of Haskell’s more esoteric types. The code samples used here (along with exercise solutions) are &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs&#34;&gt;available on github&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;foldl&#34;&gt;foldl&lt;/h2&gt;
&lt;p&gt;The first concept is the great &lt;em&gt;&lt;a href=&#34;http://hackage.haskell.org/package/foldl&#34;&gt;foldl&lt;/a&gt;&lt;/em&gt; library, which provides a nice “stream processor” type called &lt;code&gt;Fold&lt;/code&gt;, where &lt;code&gt;Fold r a&lt;/code&gt; is a stream processor that takes a stream of &lt;code&gt;r&lt;/code&gt;s and produces an &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Control.Foldl&lt;/span&gt;   (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt;(..))&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;qualified&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Control.Foldl&lt;/span&gt;   &lt;span class=&#34;kw&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;F&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;F.sum&lt;span class=&#34;ot&#34;&gt;  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Num&lt;/span&gt; a        &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a a&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;F.mean&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fractional&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a a&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;F.elem&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Eq&lt;/span&gt; a         &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-7&#34;&gt;&lt;a href=&#34;#cb1-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-8&#34;&gt;&lt;a href=&#34;#cb1-8&#34;&gt;&lt;/a&gt;F.fold F.sum  [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-9&#34;&gt;&lt;a href=&#34;#cb1-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; 10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-10&#34;&gt;&lt;a href=&#34;#cb1-10&#34;&gt;&lt;/a&gt;F.fold F.mean [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-11&#34;&gt;&lt;a href=&#34;#cb1-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; 2.5&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-12&#34;&gt;&lt;a href=&#34;#cb1-12&#34;&gt;&lt;/a&gt;F.fold (F.elem &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;) [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-13&#34;&gt;&lt;a href=&#34;#cb1-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; True&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-14&#34;&gt;&lt;a href=&#34;#cb1-14&#34;&gt;&lt;/a&gt;F.fold (F.elem &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt;) [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-15&#34;&gt;&lt;a href=&#34;#cb1-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; False&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most useful thing about the library is that it treats the folds as first-class objects, so you can create more complex folds by combining simpler folds (for example, with &lt;code&gt;-XApplicativeDo&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L22-L29&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;variance ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fractional&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a a&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;variance &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;    x  &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; F.mean&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;    x2 &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; lmap (&lt;span class=&#34;op&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;) F.mean     &lt;span class=&#34;co&#34;&gt;-- the mean of squared items&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-7&#34;&gt;&lt;a href=&#34;#cb2-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; (x2 &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;*&lt;/span&gt;x)&lt;/span&gt;
&lt;span id=&#34;cb2-8&#34;&gt;&lt;a href=&#34;#cb2-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-9&#34;&gt;&lt;a href=&#34;#cb2-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;varianceTooBig ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fractional&lt;/span&gt; a, &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-10&#34;&gt;&lt;a href=&#34;#cb2-10&#34;&gt;&lt;/a&gt;varianceTooBig &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; variance&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Most importantly, &lt;code&gt;Fold r&lt;/code&gt; is an instance of both &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Applicative&lt;/code&gt;, so you can map over and combine the results of different folds.&lt;/p&gt;
&lt;p&gt;To me, &lt;em&gt;foldl&lt;/em&gt; is one of the shining examples of how well Haskell works for data and stream processing, and a library I often show to people when they ask what the big deal is about Haskell abstractions like &lt;code&gt;Applicative&lt;/code&gt;, purity, and lists — this technique is often described as “&lt;a href=&#34;https://www.google.com/search?q=beautiful+folds&#34;&gt;beautiful folds&lt;/a&gt;”.&lt;/p&gt;
&lt;h2 id=&#34;adjunctions&#34;&gt;Adjunctions&lt;/h2&gt;
&lt;p&gt;The second concept is the idea of &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Adjoint_functors&#34;&gt;adjoint functors&lt;/a&gt;&lt;/em&gt; (see also &lt;a href=&#34;https://bartoszmilewski.com/2016/04/18/adjunctions/&#34;&gt;Bartosz Milewski’s introduction&lt;/a&gt; and &lt;a href=&#34;https://ncatlab.org/nlab/show/adjoint+functor&#34;&gt;nlab&lt;/a&gt;’s description, as well as &lt;a href=&#34;https://www.math3ma.com/blog/what-is-an-adjunction-part-1&#34;&gt;Tai-Danae Bradley’s motivation&lt;/a&gt;), represented in Haskell by the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html&#34;&gt;adjunctions library and typeclass&lt;/a&gt;&lt;/em&gt; (&lt;a href=&#34;https://chrispenner.ca/posts/adjunction-battleship&#34;&gt;Chris Penner&lt;/a&gt; has a nice article with an example of using the typeclass’s utility functions to simplify programs).&lt;/p&gt;
&lt;p&gt;For some functors, we can think of a “conceptual inverse”. We can ask “I have a nice functor &lt;code&gt;F&lt;/code&gt;. Conceptually, what functor represents the opposite idea/spirit of &lt;code&gt;F&lt;/code&gt;?” The concept of an adjunction is one way to formalize what this means.&lt;/p&gt;
&lt;p&gt;In Haskell&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, with the &lt;code&gt;Adjunctions&lt;/code&gt; typeclass (specifically, &lt;code&gt;Functor&lt;/code&gt; functors), this manifests as this: if &lt;code&gt;F -| U&lt;/code&gt; (&lt;code&gt;F&lt;/code&gt; is left adjoint to &lt;code&gt;U&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; is right adjoint to &lt;code&gt;F&lt;/code&gt;), then all the ways of going “out of” &lt;code&gt;F a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; are the same as all the ways of going “into” &lt;code&gt;U b&lt;/code&gt; from &lt;code&gt;a&lt;/code&gt;. Ways of going out can be encoded as ways of going in, and vice versa. They represent opposite ideas.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | The class saying you can always convert between:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- * `f a -&amp;gt; b` (the ways to go out of `f`)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- * `a -&amp;gt; u b` (the ways to go into `g`)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;    leftAdjunct&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;out of&amp;quot; `f`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;into&amp;quot; `u`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;    rightAdjunct&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;into&amp;quot; u&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;out of&amp;quot; f&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;p&gt;For example, one of the more famous adjunctions in Haskell is the adjunction between &lt;code&gt;(,) r&lt;/code&gt; and &lt;code&gt;(-&amp;gt;) r&lt;/code&gt;. “Tupling” represents some sort of “opposite” idea to “parameterizing”.&lt;/p&gt;
&lt;p&gt;The ways to get “out” of a tuple is &lt;code&gt;(r, a) -&amp;gt; b&lt;/code&gt;. The ways to go “into” a function is &lt;code&gt;a -&amp;gt; (r -&amp;gt; b)&lt;/code&gt;. Haskellers will recognize that these two types are the “same” (isomorphic) — any &lt;code&gt;(a, b) -&amp;gt; c&lt;/code&gt; can be re-written as &lt;code&gt;a -&amp;gt; (b -&amp;gt; c)&lt;/code&gt; (currying), and vice versa (uncurrying).&lt;/p&gt;
&lt;p&gt;Another common pair is with same-typed either and tuple:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L31-L34&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SameEither&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SE&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; a a)&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SameTuple&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; (a, a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;People familiar with &lt;code&gt;Either&lt;/code&gt; (sums) and &lt;code&gt;(,)&lt;/code&gt; (products) in Haskell will recognize them as “opposite” ideas — one is “or”, and the other is “and” (depending on if you are talking about using them or making them).&lt;/p&gt;
&lt;p&gt;We can formalize this idea of opposites using adjunctions: Going “out of” &lt;code&gt;Either a a&lt;/code&gt; into &lt;code&gt;b&lt;/code&gt; can be encoded as going “into” &lt;code&gt;(b, b)&lt;/code&gt; from &lt;code&gt;a&lt;/code&gt;, and vice versa: &lt;code&gt;Either a a -&amp;gt; b&lt;/code&gt; can be encoded as &lt;code&gt;a -&amp;gt; (b, b)&lt;/code&gt;, which can be encoded as &lt;code&gt;Either a a -&amp;gt; b&lt;/code&gt; — the two types are isomorphic. This is because to go out of &lt;code&gt;Either a a&lt;/code&gt;, you have to handle the situation of getting a &lt;code&gt;Left&lt;/code&gt; and the situation of getting a &lt;code&gt;Right&lt;/code&gt;. To go into &lt;code&gt;(b, b)&lt;/code&gt;, you have to able to ask what goes in the first field, and what goes in the right field. Both &lt;code&gt;Either a a -&amp;gt; b&lt;/code&gt; and &lt;code&gt;a -&amp;gt; (b, b)&lt;/code&gt; have to answer the same questions. (A fun exercise would be to write the functions to convert between the two — &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L55-L56&#34;&gt;one solution is here&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&#34;big-picture&#34;&gt;Big Picture&lt;/h3&gt;
&lt;p&gt;Aside from being an interesting curiosity (formalizing the idea of “opposite idea” is pretty neat), hunting for adjunctions can be useful in figuring out “why” a functor is useful, what you can do with it, and also what functors are intimately connected with it. There’s also the helper functions in the &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html&#34;&gt;Data.Functor.Adjunction&lt;/a&gt; module that implement some nice helper functions on your types if an adjoint happens to exist — you can do some neat things by going “back and forth” between adjoint functors.&lt;/p&gt;
&lt;h2 id=&#34;hunting-for-adjunctions&#34;&gt;Hunting for Adjunctions&lt;/h2&gt;
&lt;p&gt;So, from the build-up, you’ve probably guessed what we’re going to do next: find a functor that is adjoint to &lt;code&gt;Fold r&lt;/code&gt;. What’s the “conceptual opposite” of &lt;code&gt;Fold r&lt;/code&gt;? Let’s go adjunction hunting!&lt;/p&gt;
&lt;p&gt;Important note — the rest of this section is not a set of hard rules, but rather an intuitive process of heuristics to search for candidates that would be adjoint to a given functor of interest. There are no hard and fast rules, and the adjoint might not always exist (it usually doesn’t). But when it does, it can be a pleasant surprise.&lt;/p&gt;
&lt;h3 id=&#34;patterns-to-look-for&#34;&gt;Patterns to look for&lt;/h3&gt;
&lt;p&gt;Now, on to the hunting. Let’s say we have functor &lt;code&gt;Q&lt;/code&gt; and we want to identify any adjoints. We want to spot functions that use both &lt;code&gt;Q a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; with some other value, in &lt;a href=&#34;https://www.foldl.io/posts/pos-neg-functions/&#34;&gt;opposite positions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;(Of course, this is only the case if we are using a functor that comes from a library. If we are writing our own functor from scratch, and want to hunt for adjunctions there, we have to instead &lt;em&gt;think&lt;/em&gt; of ways to use &lt;code&gt;Q a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;One common pattern is functions for “converting between” the going-in and going-out functions. In &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html&#34;&gt;Data.Functor.Adjunctions&lt;/a&gt;, these are called &lt;code&gt;leftAdjunct&lt;/code&gt; and &lt;code&gt;rightAdjunct&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b)&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pair is significant because it is the adjunctions “in practice”: Sure, an &lt;code&gt;(r, a) -&amp;gt; b&lt;/code&gt; is useful, but “using” the adjunction means that you can convert &lt;em&gt;between&lt;/em&gt; &lt;code&gt;(r, a) -&amp;gt; b&lt;/code&gt; and &lt;code&gt;a -&amp;gt; r -&amp;gt; b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Another common pattern that you can spot are “indexing” and “tabulating” functions, in the case that you have a right-adjoint:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; u b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (f () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;indexAdjunction&lt;/code&gt; means: if it’s possible to “extract” from &lt;code&gt;u b&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; using only an &lt;code&gt;f ()&lt;/code&gt; as extra information, then &lt;code&gt;u&lt;/code&gt; might be right-adjoint to &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tabulateAdjunction&lt;/code&gt; means: if it’s possible to “generate” a &lt;code&gt;u b&lt;/code&gt; based on a function that “builds” a &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;f ()&lt;/code&gt;, then &lt;code&gt;u&lt;/code&gt; might right-adjoint to &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This pair is equivalent in power — you can implement &lt;code&gt;rightAdjunct&lt;/code&gt; in terms of &lt;code&gt;indexAdjunction&lt;/code&gt; and &lt;code&gt;leftAdjunct&lt;/code&gt; in terms of &lt;code&gt;tabulateAdjunction&lt;/code&gt; and vice versa. This comes from the fact that all Adjunctions in Haskell &lt;code&gt;Functor&lt;/code&gt;s arise from some idea of “indexability”. We’ll go into more detail later, but this is the general intuition.&lt;/p&gt;
&lt;h3 id=&#34;adjoints-to-fold&#34;&gt;Adjoints to &lt;code&gt;Fold&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Now, let’s look out for examples of these functions for &lt;code&gt;Fold&lt;/code&gt;! In the case of &lt;code&gt;Fold&lt;/code&gt;, there is actually only one function I can find that directly takes a &lt;code&gt;Fold r a&lt;/code&gt; and returns an &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fold ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(the type has been simplified and re-labeled, for illustration’s sake)&lt;/p&gt;
&lt;p&gt;You “give” a &lt;code&gt;Fold r b&lt;/code&gt; and “get” an &lt;code&gt;b&lt;/code&gt; (and so they have opposite polarities/positions). This sort of function would make &lt;code&gt;Fold r&lt;/code&gt; a &lt;em&gt;right adjoint&lt;/em&gt;, since the naked type &lt;code&gt;b&lt;/code&gt; (the final parameter of &lt;code&gt;Fold r b&lt;/code&gt;) is the final result, not the input.&lt;/p&gt;
&lt;p&gt;Of our common patterns, this one looks a looooot like &lt;code&gt;indexAdjunction&lt;/code&gt;.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fold            ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r]  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;Fold r b&lt;/code&gt; is right-adjoint to some functor &lt;code&gt;f&lt;/code&gt; where &lt;code&gt;f () = [r]&lt;/code&gt;. A good first guess (just a hunch?) would be to just have &lt;code&gt;f a = ([r], a)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L73-L74&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; [r] a&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Eq&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;EnvList r&lt;/code&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; adds a &lt;em&gt;list&lt;/em&gt; of &lt;code&gt;r&lt;/code&gt;s to a type. It is now also our suspect for a potential left-adjoint to &lt;code&gt;Fold r&lt;/code&gt;: a “conceptual opposite”.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L76-L77&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexFold ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;indexFold fld (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs _) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold fld rs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To seal the deal, let’s find its pair, &lt;code&gt;tabulateAdjunction&lt;/code&gt;. That means we are looking for:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateFold ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, to simplify the type by expanding the definition of &lt;code&gt;EnvList r ()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateFold ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This tells us that, given any list processor &lt;code&gt;[r] -&amp;gt; b&lt;/code&gt;, we can write a fold &lt;code&gt;Fold r b&lt;/code&gt; representing that list processor. Scanning things more, we can see that this actually looks a lot like &lt;code&gt;foldMap&lt;/code&gt; from the library:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;qualified&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Control.Foldl&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;F&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;F.foldMap&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; w&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; w)&lt;/span&gt;
&lt;span id=&#34;cb13-6&#34;&gt;&lt;a href=&#34;#cb13-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (w &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb13-7&#34;&gt;&lt;a href=&#34;#cb13-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb13-8&#34;&gt;&lt;a href=&#34;#cb13-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-9&#34;&gt;&lt;a href=&#34;#cb13-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-10&#34;&gt;&lt;a href=&#34;#cb13-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-11&#34;&gt;&lt;a href=&#34;#cb13-11&#34;&gt;&lt;/a&gt;F.foldMap (\r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r])&lt;/span&gt;
&lt;span id=&#34;cb13-12&#34;&gt;&lt;a href=&#34;#cb13-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb13-13&#34;&gt;&lt;a href=&#34;#cb13-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L79-L80&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateFold ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;tabulateFold f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) (\rs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs ()))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The fact the have &lt;em&gt;both&lt;/em&gt; of these gives us a pretty strong footing to claim that &lt;code&gt;EnvList r&lt;/code&gt; is the left-adjoint of &lt;code&gt;Fold r&lt;/code&gt;. Proof by hunch, for now.&lt;/p&gt;
&lt;p&gt;Note that if we had missed &lt;code&gt;fold&lt;/code&gt; during our adjunction hunt, we might have also lucked out by noticing &lt;code&gt;F.foldMap (:[])&lt;/code&gt; fitting the criteria for a candidate for &lt;code&gt;tabulateAdjunction&lt;/code&gt;, instead.&lt;/p&gt;
&lt;h2 id=&#34;opposite-concepts&#34;&gt;Opposite Concepts&lt;/h2&gt;
&lt;p&gt;We’ve identified a likely candidate for a left-adjoint to &lt;code&gt;Fold r&lt;/code&gt;! But … does any of this make any sense? Does this make sense as a left-adjoint, conceptually … and did we gain anything?&lt;/p&gt;
&lt;p&gt;Let’s think about this from the beginning: What is the conceptual opposite of “something that folds a list”?&lt;/p&gt;
&lt;p&gt;Well, what other thing is more naturally an opposite than “a list to be folded”!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnvList r&lt;/code&gt;: A list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fold r&lt;/code&gt;: Consumes a list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Or, in terms of the result of the functor application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnvList r a&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;… tupled with a list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fold r a&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;… parameterized by consumption of a list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It seems to “flip” the idea of “list vs. list consumer”, and &lt;em&gt;also&lt;/em&gt; the idea of “tupled vs. parameterizing” (which was our first example of an adjunction earlier, as well).&lt;/p&gt;
&lt;p&gt;In addition, lists seem to be at the heart of how to create and consume a &lt;code&gt;Fold r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fold&lt;/code&gt; can be thought of as the fundamental way to &lt;em&gt;consuming&lt;/em&gt; a &lt;code&gt;Fold r&lt;/code&gt;. This makes the adjunction with &lt;code&gt;EnvList r&lt;/code&gt; make sense: what good is the &lt;em&gt;ability&lt;/em&gt; to fold … if there is nothing &lt;em&gt;to fold&lt;/em&gt;? &lt;code&gt;EnvList r&lt;/code&gt; (a list of &lt;code&gt;[r]&lt;/code&gt;) is intimately related to &lt;code&gt;Fold r&lt;/code&gt;: they are the yin and yang, peanut butter and jelly, night and day. Their fates are intertwined from their very inception. You cannot have one without the other.&lt;/p&gt;
&lt;p&gt;In addition, &lt;code&gt;F.foldMap&lt;/code&gt; is arguably a fundamental (although maybe inefficient) way to &lt;em&gt;specify&lt;/em&gt; a &lt;code&gt;Fold r&lt;/code&gt;. A &lt;code&gt;Fold r&lt;/code&gt; is, fundamentally, a list processor — which is what &lt;code&gt;EnvList r a -&amp;gt; b&lt;/code&gt; literally is (an &lt;code&gt;[r] -&amp;gt; b&lt;/code&gt;). &lt;code&gt;Fold r&lt;/code&gt; and &lt;code&gt;EnvList r&lt;/code&gt; — &lt;a href=&#34;https://starwars.fandom.com/wiki/Dyad_in_the_Force&#34;&gt;dyads in the force&lt;/a&gt;. (Or, well…literally &lt;em&gt;monads&lt;/em&gt;, since all adjunctions give rise to monads, as we will see later.)&lt;/p&gt;
&lt;p&gt;The fact that &lt;code&gt;EnvList r&lt;/code&gt; and &lt;code&gt;Fold r&lt;/code&gt; form an adjunction together formalizes the fact that they are conceptually “opposite” concepts, and also that they are bound together by destiny in a close and fundamental way.&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;&lt;strong&gt;A Note on Representable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Note that in this case, a lot of what we are concluding simply stems from the fact that we can “index” a &lt;code&gt;Fold r a&lt;/code&gt; using an &lt;code&gt;[r]&lt;/code&gt;. This actually is more fundamentally associated with the concept of a &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Rep.html&#34;&gt;Representable Functor&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L87-L90&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Representable&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Rep&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; [r]&lt;/span&gt;
&lt;span id=&#34;cb15-5&#34;&gt;&lt;a href=&#34;#cb15-5&#34;&gt;&lt;/a&gt;    tabulate &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[])&lt;/span&gt;
&lt;span id=&#34;cb15-6&#34;&gt;&lt;a href=&#34;#cb15-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;index&lt;/span&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As it turns out, in Haskell, a functor being representable is &lt;em&gt;equivalent&lt;/em&gt; to it having a left adjoint. So thinking of &lt;code&gt;Fold r&lt;/code&gt; as a representable functor and thinking of it as a right adjoint are equivalent ideas. This article chooses to analyze it from the adjunctions perspective because we get to imagine the adjoint &lt;code&gt;Functor&lt;/code&gt;, which can sometimes reveal some extra insight over just looking at some index &lt;em&gt;value&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;the-helper-functions&#34;&gt;The Helper Functions&lt;/h2&gt;
&lt;p&gt;Let’s take a look at some of the useful helper functions that an instance of &lt;code&gt;Adjunction&lt;/code&gt; gives us for &lt;code&gt;Fold r&lt;/code&gt;, to see how their existence can better help us understand &lt;code&gt;Fold&lt;/code&gt;. For all of these, I’m going to write them first as &lt;code&gt;EnvList r a&lt;/code&gt;, and then also as &lt;code&gt;([r], a)&lt;/code&gt;, to help make things clearer.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;unit ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a)&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;unit ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r ([r], a)&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;counit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;counit ::&lt;/span&gt; [r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-7&#34;&gt;&lt;a href=&#34;#cb16-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b)&lt;/span&gt;
&lt;span id=&#34;cb16-8&#34;&gt;&lt;a href=&#34;#cb16-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b   ) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b)&lt;/span&gt;
&lt;span id=&#34;cb16-9&#34;&gt;&lt;a href=&#34;#cb16-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-10&#34;&gt;&lt;a href=&#34;#cb16-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb16-11&#34;&gt;&lt;a href=&#34;#cb16-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b   )&lt;/span&gt;
&lt;span id=&#34;cb16-12&#34;&gt;&lt;a href=&#34;#cb16-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-13&#34;&gt;&lt;a href=&#34;#cb16-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateAdjunction ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb16-14&#34;&gt;&lt;a href=&#34;#cb16-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateAdjunction ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)          &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb16-15&#34;&gt;&lt;a href=&#34;#cb16-15&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-16&#34;&gt;&lt;a href=&#34;#cb16-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb16-17&#34;&gt;&lt;a href=&#34;#cb16-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r]         &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb16-18&#34;&gt;&lt;a href=&#34;#cb16-18&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-19&#34;&gt;&lt;a href=&#34;#cb16-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;zipR ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r (a, b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unit :: a -&amp;gt; Fold r ([r], a)&lt;/code&gt;, when we specialize &lt;code&gt;a ~ ()&lt;/code&gt;, becomes:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;unit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r [r]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;unit&lt;/code&gt; for &lt;code&gt;Fold r&lt;/code&gt; folds a list &lt;code&gt;[r]&lt;/code&gt; into “itself”, while also tagging on a value&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;F.fold (unit &lt;span class=&#34;dt&#34;&gt;True&lt;/span&gt;) [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; EnvList [1,2,3] True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;counit :: [r] -&amp;gt; Fold r a -&amp;gt; a&lt;/code&gt; is essentially just &lt;code&gt;F.fold&lt;/code&gt; when we expand it. Neat!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;leftAdjunct :: ([r] -&amp;gt; a -&amp;gt; b) -&amp;gt; (a -&amp;gt; Fold r b)&lt;/code&gt; … if we write it as &lt;code&gt;leftAdjunct :: a -&amp;gt; (a -&amp;gt; [r] -&amp;gt; b) -&amp;gt; Fold r b&lt;/code&gt;, and feed the &lt;code&gt;a&lt;/code&gt; into the first function, we get:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct&amp;#39; ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is just &lt;code&gt;tabulateAdjunction&lt;/code&gt;, or &lt;code&gt;F.foldMap (:[])&lt;/code&gt;! It encodes our list processor &lt;code&gt;[r] -&amp;gt; b&lt;/code&gt; into a &lt;code&gt;Fold r b.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rightAdjunct :: (a -&amp;gt; Fold r b) -&amp;gt; ([r] -&amp;gt; a -&amp;gt; b)&lt;/code&gt; – if we again rewrite as &lt;code&gt;rightAdjunct :: a -&amp;gt; (a -&amp;gt; Fold r b) -&amp;gt; [r] -&amp;gt; b&lt;/code&gt;, and again feed the &lt;code&gt;a&lt;/code&gt; into the first function, becomes:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct&amp;#39; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which happens to just be &lt;code&gt;fold&lt;/code&gt;, or &lt;code&gt;counit&lt;/code&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tabulateAdjunction&lt;/code&gt; and &lt;code&gt;indexAdjunction&lt;/code&gt; we went over earlier, seeing them as &lt;code&gt;F.foldMap (:[])&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;zipR :: Fold r a -&amp;gt; Fold r b -&amp;gt; Fold r (a, b)&lt;/code&gt; takes two &lt;code&gt;Fold r&lt;/code&gt;s and combines them into a single fold. This is exactly the “combining fold” behavior that makes &lt;code&gt;Fold&lt;/code&gt;s so useful! The implementation of &lt;code&gt;zipR&lt;/code&gt; is less efficient than the implementation of &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;/&lt;code&gt;liftA2&lt;/code&gt; for &lt;code&gt;Fold r&lt;/code&gt;, but knowing that &lt;code&gt;zipR&lt;/code&gt; exists means that we know &lt;code&gt;Fold r&lt;/code&gt;s can be combined.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Seeing how these functions all fit together, we can write a full instance of &lt;code&gt;Adjunction&lt;/code&gt;. We can choose to provide &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;counit&lt;/code&gt;, or &lt;code&gt;leftAdjunct&lt;/code&gt; and &lt;code&gt;rightAdjunct&lt;/code&gt;&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;; the &lt;code&gt;unit&lt;/code&gt;/&lt;code&gt;counit&lt;/code&gt; definitions are the easiest to conceptualize, for me, but the other pair isn’t much tricker to write.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L92-L97&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r) (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;    unit x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) (&lt;span class=&#34;ot&#34;&gt;`EnvList`&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb21-5&#34;&gt;&lt;a href=&#34;#cb21-5&#34;&gt;&lt;/a&gt;    counit (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs fld) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold fld rs&lt;/span&gt;
&lt;span id=&#34;cb21-6&#34;&gt;&lt;a href=&#34;#cb21-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-7&#34;&gt;&lt;a href=&#34;#cb21-7&#34;&gt;&lt;/a&gt;    leftAdjunct f x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) (\rs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs x))&lt;/span&gt;
&lt;span id=&#34;cb21-8&#34;&gt;&lt;a href=&#34;#cb21-8&#34;&gt;&lt;/a&gt;    rightAdjunct f (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs x) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold (f x) rs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;induced-monad-and-comonad&#34;&gt;Induced Monad and Comonad&lt;/h3&gt;
&lt;p&gt;Another interesting thing we might want to look at is the monad and comonad that our adjunction defines. &lt;a href=&#34;https://bartoszmilewski.com/2016/12/27/monads-categorically/&#34;&gt;All adjunctions&lt;/a&gt; &lt;a href=&#34;http://www.stephendiehl.com/posts/adjunctions.html&#34;&gt;define a monad&lt;/a&gt;, so what does our new knowledge of the &lt;code&gt;Fold r&lt;/code&gt; adjunction give us?&lt;/p&gt;
&lt;h4 id=&#34;induced-monad&#34;&gt;Induced Monad&lt;/h4&gt;
&lt;p&gt;If we have &lt;code&gt;F -| U&lt;/code&gt;, then &lt;code&gt;U . F&lt;/code&gt; is a monad. In this case, we have &lt;code&gt;FoldEnv&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L99-L100&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FE&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getFE ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a) }&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r ([r], a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As it turns out, this is essentially equivalent to the famous &lt;a href=&#34;https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-State-Lazy.html&#34;&gt;State Monad&lt;/a&gt;! More specifically, it’s the &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Control-Monad-Representable-State.html&#34;&gt;&lt;em&gt;Representable&lt;/em&gt; State Monad&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; [r]&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or, more literally, from Control.Monad.Representable.State&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the induced monad from the adjunction we just found is essentially the same as the &lt;code&gt;State&lt;/code&gt; monad over a list — except with some potentially different performance characteristics.&lt;/p&gt;
&lt;p&gt;In the end, finding this adjunction gives us a neat way to represent stateful computations on lists, which is arguably an extension of what &lt;code&gt;Fold&lt;/code&gt; was really meant for in the first place.&lt;/p&gt;
&lt;h4 id=&#34;induced-comonad&#34;&gt;Induced Comonad&lt;/h4&gt;
&lt;p&gt;If we have &lt;code&gt;F -| U&lt;/code&gt;, then &lt;code&gt;F . U&lt;/code&gt; is a comonad. In this case, we have &lt;code&gt;EnvFold&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L111-L112&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-3&#34;&gt;&lt;a href=&#34;#cb24-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getEF ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a) }&lt;/span&gt;
&lt;span id=&#34;cb24-4&#34;&gt;&lt;a href=&#34;#cb24-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-5&#34;&gt;&lt;a href=&#34;#cb24-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-6&#34;&gt;&lt;a href=&#34;#cb24-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-7&#34;&gt;&lt;a href=&#34;#cb24-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; ([r], &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This one is exactly the &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Control-Comonad-Representable-Store.html&#34;&gt;Representable Store comonad&lt;/a&gt;. It’s essentially the normal &lt;a href=&#34;https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Store.html&#34;&gt;&lt;code&gt;Store&lt;/code&gt; comonad&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Store&lt;/span&gt; [r]&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-3&#34;&gt;&lt;a href=&#34;#cb25-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or, more literally, from Control.Comonad.Representable.Store&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-4&#34;&gt;&lt;a href=&#34;#cb25-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Store&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This comonad “stores” an &lt;code&gt;[r]&lt;/code&gt; as well as a way to produce an &lt;code&gt;a&lt;/code&gt; from an &lt;code&gt;[r]&lt;/code&gt;. All of the utility of this induced comonad basically is the same as the utility of &lt;code&gt;Store&lt;/code&gt;, except with potentially different performance profiles.&lt;/p&gt;
&lt;p&gt;In the end, finding this adjunction gives us a neat way to define a comonadic contextual projection on lists, which I would say is also an extension of the original purpose of &lt;code&gt;Fold&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In the end, in a “practical” sense, we got some nice helper functions, as well as a new way to extend the conceptual idea of &lt;code&gt;Fold&lt;/code&gt; using the induced monad and comonad.&lt;/p&gt;
&lt;p&gt;Admittedly, the selection of helper functions that &lt;code&gt;Adjunction&lt;/code&gt; gives us pales in comparison to abstractions like &lt;code&gt;Monoid&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;, etc., which makes &lt;code&gt;Adjunction&lt;/code&gt; (in my opinion) nowhere as practical when compared to them. A lot of these helper functions (like the induced state monad and store comonad) actually also just exist if we only talk about &lt;code&gt;Representable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, to me (and, as how I’ve seen other people use it), &lt;code&gt;Adjunction&lt;/code&gt; is most useful as a conceptual tool in Haskell. The idea of “opposites” or “duals” show up a lot in Haskell, starting from the most basic level – sums and products, products and functions. From day 1, Haskellers are introduced to natural pairs and opposites in concepts. The idea of opposites and how they interact with each other is always on the mind of a Haskeller, and close to their heart.&lt;/p&gt;
&lt;p&gt;So, what makes &lt;code&gt;Adjunction&lt;/code&gt; so useful to me is that it actually is able to formalize what we mean by “opposite concepts”. The process of identifying a functor’s “opposite concept” (if it exists) will only help is better understand the functor we’re thinking about, in terms of how it works and how it is used.&lt;/p&gt;
&lt;p&gt;Hopefully this blog post helps you appreciate both &lt;code&gt;Fold&lt;/code&gt; in a new way, and also the fundamental “idea” of adjunctions in Haskell.&lt;/p&gt;
&lt;h2 id=&#34;the-algebraic-way&#34;&gt;The Algebraic Way&lt;/h2&gt;
&lt;p&gt;This article is done! Our first guess for an adjunction seems to be morally correct. But as an aside … let’s see if we can take this idea further.&lt;/p&gt;
&lt;p&gt;In this section we’re going to get a bit mathy and look at the definition of &lt;code&gt;Fold&lt;/code&gt;, to see if we can &lt;em&gt;algebraically&lt;/em&gt; find an adjunction of &lt;code&gt;Fold&lt;/code&gt;, instead of just trying to hunt for API functions like before. In practice you don’t often have to make algebraic deductions like this, but it’s at least nice to know that something like this possible from a purely algebraic and logical sense. You never &lt;em&gt;need&lt;/em&gt; all this fancy math to be able to write Haskell … but many feel like it can make things a lot more fun! :)&lt;/p&gt;
&lt;p&gt;Be warned that this method &lt;em&gt;does&lt;/em&gt; require some familiarity (or at least awareness) of certain types that appear often in the more … esoteric corners of Haskelldom :)&lt;/p&gt;
&lt;p&gt;The game plan here is to start with the definition of &lt;code&gt;Fold&lt;/code&gt;, and then rearrange it using algebraic substitutions until it matches something that already has an &lt;code&gt;Adjunction&lt;/code&gt; instance in the &lt;em&gt;adjunctions&lt;/em&gt; library.&lt;/p&gt;
&lt;p&gt;First, the actual definition of &lt;code&gt;Fold&lt;/code&gt; in the &lt;em&gt;foldl&lt;/em&gt; library itself is:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maybe not the friendliest definition at first! But something in this looks a little familiar, maybe. Let’s do some re-arranging:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb27-2&#34;&gt;&lt;a href=&#34;#cb27-2&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb27-3&#34;&gt;&lt;a href=&#34;#cb27-3&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x, a))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah, this looks a &lt;em&gt;lot&lt;/em&gt; like the constructor &lt;code&gt;Nu&lt;/code&gt; for some &lt;code&gt;f&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f x) x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Nu&lt;/code&gt; is one of the three main famous &lt;a href=&#34;https://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html&#34;&gt;fixed-point type combinators&lt;/a&gt; in Haskell. The other two are &lt;code&gt;Mu&lt;/code&gt; and &lt;code&gt;Fix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f x) x&lt;/span&gt;
&lt;span id=&#34;cb29-2&#34;&gt;&lt;a href=&#34;#cb29-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fix&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fix&lt;/span&gt; (f (&lt;span class=&#34;dt&#34;&gt;Fix&lt;/span&gt; f))&lt;/span&gt;
&lt;span id=&#34;cb29-3&#34;&gt;&lt;a href=&#34;#cb29-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Haskell these are all equivalent&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;, but they have very different performance profiles for certain operations. &lt;code&gt;Nu&lt;/code&gt; is easy to “build up”, and &lt;code&gt;Mu&lt;/code&gt; is easy to “tear down” – and they exist sort of opposite to each other. &lt;code&gt;Fix&lt;/code&gt; exists in opposite to … itself. Sorry, &lt;code&gt;Fix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, looking at &lt;code&gt;Fold r a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb30&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb30-1&#34;&gt;&lt;a href=&#34;#cb30-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x, a))&lt;/span&gt;
&lt;span id=&#34;cb30-2&#34;&gt;&lt;a href=&#34;#cb30-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt;   f   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt;   x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it seems like we can pick an &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;Nu (F r a) = Fold r a&lt;/code&gt;. Let’s try…&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb31&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb31-1&#34;&gt;&lt;a href=&#34;#cb31-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; g) x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; (f (g x))&lt;/span&gt;
&lt;span id=&#34;cb31-2&#34;&gt;&lt;a href=&#34;#cb31-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-3&#34;&gt;&lt;a href=&#34;#cb31-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; (((,) a) &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; ((&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;) r))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From here, some might recognize the fixed point of &lt;code&gt;(,) a :.: f&lt;/code&gt; as &lt;code&gt;Cofree&lt;/code&gt;, from &lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Comonad-Cofree.html&#34;&gt;Control.Comonad.Cofree&lt;/a&gt; — one of the more commonly used fixed points.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb32&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb32-1&#34;&gt;&lt;a href=&#34;#cb32-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Cofree&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; ((,) a &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; f     )&lt;/span&gt;
&lt;span id=&#34;cb32-2&#34;&gt;&lt;a href=&#34;#cb32-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-3&#34;&gt;&lt;a href=&#34;#cb32-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; ((,) a &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; (&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;) r)&lt;/span&gt;
&lt;span id=&#34;cb32-4&#34;&gt;&lt;a href=&#34;#cb32-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r     &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Cofree&lt;/span&gt; ((&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;) r)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It looks like &lt;code&gt;Fold r&lt;/code&gt; is just &lt;code&gt;Cofree ((-&amp;gt;) r)&lt;/code&gt; &lt;a href=&#34;#fn6&#34; class=&#34;footnote-ref&#34; id=&#34;fnref6&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt; … and now we’ve hit the jackpot! That’s because &lt;code&gt;Cofree f&lt;/code&gt; has an instance of &lt;code&gt;Adjunction&lt;/code&gt;!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb33&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb33-1&#34;&gt;&lt;a href=&#34;#cb33-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt; f) (&lt;span class=&#34;dt&#34;&gt;Cofree&lt;/span&gt; u)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;Cofree u&lt;/code&gt; is right-adjoint to &lt;code&gt;Free f&lt;/code&gt;, if &lt;code&gt;f&lt;/code&gt; is right-adjoint to &lt;code&gt;u&lt;/code&gt;. Well, our &lt;code&gt;u&lt;/code&gt; here is &lt;code&gt;(-&amp;gt;) r&lt;/code&gt;, which was actually our very first example of a right-adjoint functor — it’s right-adjoint to &lt;code&gt;(,)&lt;/code&gt;. So, &lt;code&gt;Fold r&lt;/code&gt; is apparently a right-adjoint, like we guessed previously! More specifically, it looks like like &lt;code&gt;Fold r&lt;/code&gt; is right-adjoint to &lt;code&gt;Free ((,) r)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At least, we’ve reached our goal! We found an adjunction for &lt;code&gt;Fold r&lt;/code&gt; in a purely algebraic way, and deduced it to be right-adjunct to &lt;code&gt;Free ((,) r)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At this point we have our answer, so we can stop here. But it’s possible to go a little further, to find a true “perfect companion” for &lt;code&gt;Fold r&lt;/code&gt;. Its perfect match and conceptual opposite, as the adjunction mythos claims.&lt;/p&gt;
&lt;p&gt;We know that &lt;code&gt;Free f&lt;/code&gt; is, itself, a fixed-point – it’s the fixed point of &lt;code&gt;Sum (Const a) f&lt;/code&gt; (from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html&#34;&gt;Data.Functor.Sum&lt;/a&gt;&lt;/em&gt;). So &lt;code&gt;Free ((,) r) a&lt;/code&gt; is the fixed-point of &lt;code&gt;Sum (Const a) ((,) r)&lt;/code&gt;. Since we are looking at conceptual opposites, maybe let’s try using the &lt;code&gt;Mu&lt;/code&gt; fixed-point operator, to be opposite of the &lt;code&gt;Nu&lt;/code&gt; that &lt;code&gt;Fold r&lt;/code&gt; is. This also makes sense because this is something we’re going to “tear down” with a &lt;code&gt;Fold&lt;/code&gt;, and &lt;code&gt;Mu&lt;/code&gt; is good at being torn down.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb34&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb34-1&#34;&gt;&lt;a href=&#34;#cb34-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb34-2&#34;&gt;&lt;a href=&#34;#cb34-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-3&#34;&gt;&lt;a href=&#34;#cb34-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Sum&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Const&lt;/span&gt; a) ((,) r))&lt;/span&gt;
&lt;span id=&#34;cb34-4&#34;&gt;&lt;a href=&#34;#cb34-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-5&#34;&gt;&lt;a href=&#34;#cb34-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&#34;cb34-6&#34;&gt;&lt;a href=&#34;#cb34-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    runEL ::&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; a (r, x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb34-7&#34;&gt;&lt;a href=&#34;#cb34-7&#34;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&#34;cb34-8&#34;&gt;&lt;a href=&#34;#cb34-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-9&#34;&gt;&lt;a href=&#34;#cb34-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or, with some shuffling around, recognizing that `Either a b -&amp;gt; c` is&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-10&#34;&gt;&lt;a href=&#34;#cb34-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- equivalent to `(a -&amp;gt; c, b -&amp;gt; c)`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-11&#34;&gt;&lt;a href=&#34;#cb34-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&#34;cb34-12&#34;&gt;&lt;a href=&#34;#cb34-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    runEL ::&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb34-13&#34;&gt;&lt;a href=&#34;#cb34-13&#34;&gt;&lt;/a&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The new &lt;code&gt;EL&lt;/code&gt; is actually isomorphic to the &lt;code&gt;EnvList&lt;/code&gt; one we wrote earlier (as long as the list is finite), meaning that one can encode the other, and they have identical structure. Writing functions to convert between the two can be fun; &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L31-L39&#34;&gt;here is one solution&lt;/a&gt;, and there’s a &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L73-L79&#34;&gt;bonus solution&lt;/a&gt; if you can write it using only the &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L58-L71&#34;&gt;&lt;em&gt;new&lt;/em&gt; instance&lt;/a&gt; for &lt;code&gt;Adjunction (EL r) (Fold r)&lt;/code&gt; and &lt;code&gt;F.foldMap&lt;/code&gt;, since it can be shown that all adjuncts are unique up to isomorphism.&lt;/p&gt;
&lt;p&gt;And…this looks pretty neat, I think. In the end we discover that these two types are adjoints to each other:&lt;a href=&#34;#fn7&#34; class=&#34;footnote-ref&#34; id=&#34;fnref7&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb35&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb35-1&#34;&gt;&lt;a href=&#34;#cb35-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt;            (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)    (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)    x&lt;/span&gt;
&lt;span id=&#34;cb35-2&#34;&gt;&lt;a href=&#34;#cb35-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt;   r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt;   (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They look superficially syntactically similar and I don’t really know what to make of that … but a lot of “opposites” seem to be paired here. The existential &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;Fold&lt;/code&gt; becomes a Rank2 universal in &lt;code&gt;EList&lt;/code&gt;, and the &lt;code&gt;x -&amp;gt; a&lt;/code&gt; in &lt;code&gt;Fold&lt;/code&gt; becomes an &lt;code&gt;a -&amp;gt; x&lt;/code&gt; in &lt;code&gt;EList&lt;/code&gt;. Neat neat.&lt;/p&gt;
&lt;p&gt;Adjunctions: take an idea and just make everything opposite.&lt;/p&gt;
&lt;p&gt;One nice thing about this representation is that writing the fundamental operation of &lt;code&gt;Fold&lt;/code&gt; (that is, &lt;code&gt;fold&lt;/code&gt;) becomes really clean:&lt;a href=&#34;#fn8&#34; class=&#34;footnote-ref&#34; id=&#34;fnref8&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb36&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb36-1&#34;&gt;&lt;a href=&#34;#cb36-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L51-L52&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-2&#34;&gt;&lt;a href=&#34;#cb36-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-3&#34;&gt;&lt;a href=&#34;#cb36-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;foldEL ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb36-4&#34;&gt;&lt;a href=&#34;#cb36-4&#34;&gt;&lt;/a&gt;foldEL (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; step &lt;span class=&#34;fu&#34;&gt;init&lt;/span&gt; extr) el &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; extr (runEL el (&lt;span class=&#34;fu&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;init&lt;/span&gt;) step)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this is, maybe, the real treasure all along.&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Note that the intuition we are going to be going into is specifically for adjunctions between &lt;code&gt;Functor&lt;/code&gt; functors — functors that the &lt;code&gt;Functor&lt;/code&gt; typeclass models (aka, endofunctors in Hask). For a more general view of adjunctions in general, see the links above.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;As it so happens, &lt;code&gt;fold&lt;/code&gt; is actually exactly &lt;code&gt;index&lt;/code&gt; for &lt;code&gt;Representable (Fold r)&lt;/code&gt;, from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Rep.html&#34;&gt;Data.Functor.Rep&lt;/a&gt;&lt;/em&gt;. Here we are utilizing the fact that a representable Functor gives rise to a left-adjoint for free — the two ideas are equivalent in Haskell. We go into this in more detail in an upcoming aside.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;The name here is inspired by the &lt;a href=&#34;https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Trans-Env.html&#34;&gt;&lt;code&gt;Env&lt;/code&gt; comonad&lt;/a&gt; — &lt;code&gt;EnvList r&lt;/code&gt; is &lt;code&gt;Env [r]&lt;/code&gt;.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;We should also be able to define it using &lt;code&gt;tabulateAdjunction&lt;/code&gt; and &lt;code&gt;indexAdjunction&lt;/code&gt; … but this isn’t allowed for some reason?&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;They are only equivalent in Haskell because of laziness — in strict languages, they are different.&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Some might recognize &lt;code&gt;Cofree ((-&amp;gt;) r)&lt;/code&gt; as a common way of implementing a &lt;a href=&#34;https://en.wikipedia.org/wiki/Moore_machine&#34;&gt;Moore machine&lt;/a&gt; in Haskell. In fact, our derivation here is basically a backwards version of &lt;a href=&#34;https://www.schoolofhaskell.com/user/edwardk/moore/for-less&#34;&gt;the process described here by Edward Kmett&lt;/a&gt;.&lt;a href=&#34;#fnref6&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn7&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;The instance is &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L58-L71&#34;&gt;written out here&lt;/a&gt;.&lt;a href=&#34;#fnref7&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn8&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Implementing a &lt;code&gt;tabulate&lt;/code&gt; equivalent (&lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L54-L56&#34;&gt;solution here&lt;/a&gt;) reveals that this refactoring is only really useful for &lt;code&gt;index&lt;/code&gt; (to “consume” a &lt;code&gt;Fold&lt;/code&gt;) … using &lt;code&gt;tabulate&lt;/code&gt; or &lt;code&gt;leftAdjunct&lt;/code&gt; to “produce” a &lt;code&gt;Fold&lt;/code&gt; reveals how inefficient this is.&lt;a href=&#34;#fnref8&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Math</category><guid isPermaLink="true">https://blog.jle.im/entry/foldl-adjunction.html</guid><pubDate>Mon, 13 Jan 2020 21:04:16 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Math</subject><date>2020-01-13</date></item><language>en</language><copyright>Copyright 2020 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Sat, 12 Dec 2020 22:48:34 UTC</lastBuildDate><generator>feed-1.0.0.0 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><creator>Justin Le</creator><language>en</language><rights>Copyright 2020 Justin Le</rights><date>2020-12-12</date><description>Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
</description></channel></rss>