<?xml version="1.0" encoding="UTF-8"?><rss dc="http://purl.org/dc/elements/1.1/" version="2.0"><channel><title>in Code — Entries</title><link>https://blog.jle.im/</link><description>Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
</description><item><title>Shuffling things up: Applying Group Theory in Advent of Code</title><link>https://blog.jle.im/entry/shuffling-things-up.html</link><description>&lt;p&gt;So it’s November, and &lt;a href=&#34;https://adventofcode.com/&#34;&gt;Advent of Code&lt;/a&gt; season is in the air! It’s time for everyone’s favorite Santa-based light hearted learn-to-program-or-a-new-language holiday season programming challenge series. Every year a bunch of us gather around the fireplace, roast chestnuts, and brainstorm all of the interesting ways we can solve these cute themed puzzles every day. These puzzles are designed to accessible enough for most new programmers, but deep enough to provide entertainment for experienced ones. I’ve &lt;a href=&#34;https://blog.jle.im/entries/tagged/advent-of-code.html&#34;&gt;written many blog posts&lt;/a&gt; on some of the interesting insight some of the puzzles have yielded, and I also &lt;a href=&#34;https://github.com/mstksg/advent-of-code-2019/blob/master/reflections.md&#34;&gt;post my reflections on as many puzzles I can&lt;/a&gt; while solving them in Haskell. And if you’re solving things in Haskell, I also published an &lt;a href=&#34;https://hackage.haskell.org/package/advent-of-code-api&#34;&gt;open-sourced rate-limited API library&lt;/a&gt; so you can fetch and submit answers from the comfort of your command line.&lt;/p&gt;
&lt;p&gt;To kick off the season, I’ve decided to write about one of my favorite puzzles from Advent of Code 2019 – &lt;a href=&#34;https://adventofcode.com/2019/day/22&#34;&gt;Day 22: Slam Shuffle&lt;/a&gt;. To me, it stands out because it’s a perfect example of how Haskell’s approach to mathematical abstraction nudges you into the direction of an efficient solution — in a way that other languages would obscure or make less obvious.&lt;/p&gt;
&lt;p&gt;So, let’s dive in! In the end, hopefully this post can get you excited for this wonderful season, and maybe also shed some insight into what it means when we say that Haskell can help you leverage math to find good solutions to your real problems.&lt;/p&gt;
&lt;p&gt;Of course, this post has spoilers for Advent of Code 2019 Day 22, if you are planning on trying to figure it out from yourself. If you haven’t tried it, I recommend you give it a shot and come back after! :D&lt;/p&gt;
&lt;h2 id=&#34;slam-shuffle&#34;&gt;Slam Shuffle&lt;/h2&gt;
&lt;p&gt;If you haven’t already, take some time to &lt;a href=&#34;https://adventofcode.com/2019/day/22&#34;&gt;read through the problem statement&lt;/a&gt;. The basic idea is that we are given a series of operations to “shuffle” a deck of 10007 cards, such as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deal with increment 7
deal into new stack
deal into new stack
... etc&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After performing all of the many operations, the question then asks about the card at a given position (the 2019th card in the deck).&lt;/p&gt;
&lt;p&gt;Part 2, which you might not be able to see if you haven’t submitted an answer yet for Part 1, involves the same process with a deck of 119315717514047 cards, and repeating the entire shuffling sequence 101741582076661 times. It then asks you to find the card that ends up at index 2020.&lt;/p&gt;
&lt;p&gt;In this problem, it seems we have a list of “shuffles” that we want to run on a deck of cards. However, let’s think about this in a more data-driven approach: instead of thinking about successive shufflings of cards, let’s imagine the specification of a “shuffle” itself as our main data, and how we can combine shuffle operations together into new shuffle operations.&lt;/p&gt;
&lt;p&gt;We are looking for “take shuffle A and shuffle B, and return a new shuffle that represents doing B, then A”. This is “shuffle composition”, or “permutation composition” (&lt;a href=&#34;https://en.wikipedia.org/wiki/Permutation&#34;&gt;permutation&lt;/a&gt; being the mathematical word for “shuffling” here, basically)&lt;/p&gt;
&lt;p&gt;Since we’ve identified that we want to begin implementing a way of composing/combining permutations together, we can do a bit of reading to learn that one of the most famous properties of permutation composition is that they form a “group”, which means they can be composed (associatively), have an identity, and can be inverted. This means that if you have two permutations, you can “squish” them to create a new permutation, and work with that &lt;em&gt;new&lt;/em&gt; permutation.&lt;/p&gt;
&lt;p&gt;I’ve talked about &lt;a href=&#34;https://blog.jle.im/entry/alchemical-groups.html&#34;&gt;using group theory&lt;/a&gt; principles before in this blog to help guide us towards solutions and optimizations — the main principle is that if we express our program in terms of group operations, then we can take advantage of the large body of knowledge built up over centuries to understand, analyze, and potentially optimize our program.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;first&lt;/em&gt; big advantage in this situation is that we can treat our transformations &lt;em&gt;as data&lt;/em&gt;, and not as functions. And that if we have two transformations, we can always create a new one (just a normal data type value) that represents the composition of the two original ones.&lt;/p&gt;
&lt;h2 id=&#34;now-youre-thinking-with-groups&#34;&gt;Now You’re Thinking With Groups&lt;/h2&gt;
&lt;p&gt;Knowing permutations are a group, it means that once we settle on our representation of them, &lt;code&gt;Perm&lt;/code&gt;, we can write an instance of &lt;code&gt;Perm&lt;/code&gt; for &lt;code&gt;Semigroup&lt;/code&gt;, &lt;code&gt;Monoid&lt;/code&gt;, and &lt;code&gt;Group&lt;/code&gt;, abstractions in Haskell that many types are already instances of. Abstractions like &lt;code&gt;Semigroup&lt;/code&gt; and &lt;code&gt;Monoid&lt;/code&gt; are pretty much an everyday thing in Haskell, so this fits in quite nicely. &lt;code&gt;Group&lt;/code&gt; comes from the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/groups&#34;&gt;groups&lt;/a&gt;&lt;/em&gt; package, which also provides some nice applications of group theory.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;co&#34;&gt;-- let&amp;#39;s figure out the implementation later, where n is the number of cards&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Haskell, we express things like “&lt;code&gt;Perm&lt;/code&gt; is a Semigroup/Monoid/Group” by saying that they are instances of &lt;em&gt;typeclasses&lt;/em&gt;, which (for this purpose) are like interfaces in languages like Java.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | An instance m can be &amp;quot;combined&amp;quot; using `x &amp;lt;&amp;gt; y`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; m &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    (&amp;lt;&amp;gt;) ::&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | There is always an identity element for &amp;lt;&amp;gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- x &amp;lt;&amp;gt; mempty == x&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- mempty &amp;lt;&amp;gt; x == x&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; m &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    mempty ::&lt;/span&gt; m&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Every m has an inverse:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-15&#34;&gt;&lt;a href=&#34;#cb3-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- x &amp;lt;&amp;gt; invert x == mempty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-16&#34;&gt;&lt;a href=&#34;#cb3-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- invert x &amp;lt;&amp;gt; x == mempty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-17&#34;&gt;&lt;a href=&#34;#cb3-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-18&#34;&gt;&lt;a href=&#34;#cb3-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; m &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-19&#34;&gt;&lt;a href=&#34;#cb3-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    invert ::&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that if &lt;code&gt;Perm&lt;/code&gt; is an instance of &lt;code&gt;Group&lt;/code&gt; (which has superclasses &lt;code&gt;Semigroup&lt;/code&gt; and &lt;code&gt;Monoid&lt;/code&gt;), we can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compose permutations using &lt;code&gt;x &amp;lt;&amp;gt; y&lt;/code&gt;, which means “shuffle with strategy &lt;code&gt;y&lt;/code&gt;, then with strategy &lt;code&gt;x&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;Summon an “identity permutation” where &lt;code&gt;x &amp;lt;&amp;gt; mempty == x&lt;/code&gt; (the identity permutation, which is “leave things alone”).&lt;/li&gt;
&lt;li&gt;Invert any shuffling (if we have &lt;code&gt;x&lt;/code&gt;, we can reverse its effect with &lt;code&gt;invert x&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, the standard libraries also give us a useful function &lt;code&gt;stimes&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;stimes ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which lets us compose &lt;code&gt;x&lt;/code&gt; with itself (&lt;code&gt;stimes 5 x == x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x&lt;/code&gt;), but can do it in &lt;em&gt;log(n)&lt;/em&gt; time using &lt;a href=&#34;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&#34;&gt;repeated squaring&lt;/a&gt;. It’s extremely efficient in a lot of circumstances (more on that later) — more so than the naive compose-it-n-times implementation. This will definitely become useful in part 2, where we have to do 101741582076661 compositions.&lt;/p&gt;
&lt;h2 id=&#34;our-gameplan&#34;&gt;Our Gameplan&lt;/h2&gt;
&lt;p&gt;Just &lt;em&gt;knowing&lt;/em&gt; that permutations form a group naturally guides us to these abstractions — we already know what &lt;em&gt;interface&lt;/em&gt; our type will have, even before we write any code. We know that no matter &lt;em&gt;what&lt;/em&gt; our implementation of permutation will be, we will have &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;stimes&lt;/code&gt;, &lt;code&gt;mempty&lt;/code&gt;, &lt;code&gt;invert&lt;/code&gt; available to us to use. So, let’s do just that! We’ll use a stub data type &lt;code&gt;Perm&lt;/code&gt; to represent our permutation and “pretend” we have that interface on it. We’ll write our functions first and then fill in the interface later!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Represents a permutation of n cards&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;....&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Given a permutation, find the place where a given index ends up.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runPerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-7&#34;&gt;&lt;a href=&#34;#cb5-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Parse a string line into the permutation it represents&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-8&#34;&gt;&lt;a href=&#34;#cb5-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parsePerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb5-9&#34;&gt;&lt;a href=&#34;#cb5-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-10&#34;&gt;&lt;a href=&#34;#cb5-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Given a permutation list, find the place where 2019 ends up&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-11&#34;&gt;&lt;a href=&#34;#cb5-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part1 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-12&#34;&gt;&lt;a href=&#34;#cb5-12&#34;&gt;&lt;/a&gt;part1 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm bigPerm &lt;span class=&#34;dv&#34;&gt;2019&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-13&#34;&gt;&lt;a href=&#34;#cb5-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-14&#34;&gt;&lt;a href=&#34;#cb5-14&#34;&gt;&lt;/a&gt;    bigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;mconcat perms&lt;/code&gt; composes all of the permutations one after another: &lt;code&gt;mconcat [x,y,z] = x &amp;lt;&amp;gt; y &amp;lt;&amp;gt; z&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;And…that’s it! For the actual “logic” of our part 1! All we need to do is implement &lt;code&gt;runPerm&lt;/code&gt; and &lt;code&gt;parsePerm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here, I’m using &lt;code&gt;Finite n&lt;/code&gt; from the great &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/finite-typelits&#34;&gt;finite-typelits&lt;/a&gt;&lt;/em&gt; library, where &lt;code&gt;Finite 100&lt;/code&gt; represents “an index between 0 and 99”, etc. It’s just exactly the right “shape” to represent the index of a deck of cards. &lt;em&gt;finite-typelits&lt;/em&gt; wasn’t designed with group theory in mind, but it’s still a great tool here — which is a testament to how flexible these abstractions can actually be :)&lt;/p&gt;
&lt;p&gt;For example, it means that for a &lt;code&gt;Perm 10007&lt;/code&gt; (a permutation of 10007 cards), the type of &lt;code&gt;runPerm&lt;/code&gt; is &lt;code&gt;Perm 10007 -&amp;gt; Finite 10007 -&amp;gt; Finite 10007&lt;/code&gt;, and the type of &lt;code&gt;parsePerm&lt;/code&gt; is &lt;code&gt;String -&amp;gt; Perm 10007&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can plan out our part 2 as well:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Given a permutation list, find the index that will end up at 2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part2 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;part2 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm (invert biiigPerm) &lt;span class=&#34;dv&#34;&gt;2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    bigPerm   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;    biiigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; stimes &lt;span class=&#34;dv&#34;&gt;101741582076661&lt;/span&gt; bigPerm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Part 2, I think, is where the group theory really shines.&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;We take advantage of &lt;code&gt;stimes&lt;/code&gt;, which uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Exponentiation_by_squaring&#34;&gt;repeated squaring&lt;/a&gt;. That means that to compute &lt;code&gt;stimes 8 x&lt;/code&gt;, instead of using&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x &amp;lt;&amp;gt; x&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;it does&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let x2 = x &amp;lt;&amp;gt; x
    x4 = x2 &amp;lt;&amp;gt; x2
in  x4 &amp;lt;&amp;gt; x4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;essentially cutting down the number of multiplications exponentially. This means that to compute &lt;code&gt;stimes 101741582076661&lt;/code&gt;, we only need to do about 47 multiplications (log base 2), and not 101741582076661.&lt;/p&gt;
&lt;p&gt;This is only possible because we know that permutation composition is associative, so it doesn’t matter how we associate our parentheses. It is only “safe” to use repeated squaring if you &lt;em&gt;know&lt;/em&gt; that your operation is associative. Having a semigroup abstraction &lt;em&gt;in the first place&lt;/em&gt; guides us to this efficient solution — in a way that is pre-built just for us! This is made all the more powerful because &lt;em&gt;semigroup&lt;/em&gt; is a ubiquitous abstraction in Haskell, so we “think about” it all the time.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remember how &lt;code&gt;runPerm p 2019&lt;/code&gt; gives us the index that &lt;code&gt;2019&lt;/code&gt; is sent to? Well, we want something else in this case. We basically want the index that &lt;em&gt;will be sent to&lt;/em&gt; &lt;code&gt;2020&lt;/code&gt;. So, we want to &lt;em&gt;reverse the function&lt;/em&gt;. Luckily, since our function is just a permutation, it is easy to reverse this: just &lt;code&gt;invert&lt;/code&gt; the permutation!&lt;/p&gt;
&lt;p&gt;The idea that we can simply invert a permutation instead of having to write a whole new permutation representation just to do “backwards indexing” is something that we are &lt;em&gt;guided to&lt;/em&gt;, just by recognizing that permutations form a group.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;a-first-guess-at-implementation&#34;&gt;A first guess at implementation&lt;/h2&gt;
&lt;p&gt;Now, time to do what we have been putting off and actually write our permutation representation – the definition of &lt;code&gt;Perm n&lt;/code&gt;. A good &lt;em&gt;first guess&lt;/em&gt; might be to write our permutation as an actual function — a function from index to index, &lt;code&gt;Finite n -&amp;gt; Finite n&lt;/code&gt;. Then, we can just use function composition as our permutation composition.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runPerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;runPerm (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; f) x  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; f x&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parsePerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb9-7&#34;&gt;&lt;a href=&#34;#cb9-7&#34;&gt;&lt;/a&gt;parsePerm str &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;words&lt;/span&gt; str &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-8&#34;&gt;&lt;a href=&#34;#cb9-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb9-9&#34;&gt;&lt;a href=&#34;#cb9-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; i&lt;/span&gt;
&lt;span id=&#34;cb9-10&#34;&gt;&lt;a href=&#34;#cb9-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb9-11&#34;&gt;&lt;a href=&#34;#cb9-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-12&#34;&gt;&lt;a href=&#34;#cb9-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-13&#34;&gt;&lt;a href=&#34;#cb9-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; g)     &lt;span class=&#34;co&#34;&gt;-- apply g, then apply x&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-14&#34;&gt;&lt;a href=&#34;#cb9-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-15&#34;&gt;&lt;a href=&#34;#cb9-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;mempty&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-16&#34;&gt;&lt;a href=&#34;#cb9-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-17&#34;&gt;&lt;a href=&#34;#cb9-17&#34;&gt;&lt;/a&gt;    invert (&lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; f) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;?????&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that &lt;code&gt;Finite n&lt;/code&gt;’s &lt;code&gt;Num&lt;/code&gt; instance is modular arithmetic, so things like &lt;code&gt;negate&lt;/code&gt; and multiplication will “do the right thing”. We use &lt;code&gt;modulo&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;modulo ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which “reads” an &lt;code&gt;Integer&lt;/code&gt; into a &lt;code&gt;Finite n&lt;/code&gt;, making sure to wrap it in a cyclic way if it is negative or too high. &lt;code&gt;maxBound&lt;/code&gt; also gives us the highest index (the highest &lt;code&gt;Finite n&lt;/code&gt;).&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; modulo &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;finite &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; modulo &lt;span class=&#34;dv&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;finite &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-5&#34;&gt;&lt;a href=&#34;#cb11-5&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; modulo (&lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-6&#34;&gt;&lt;a href=&#34;#cb11-6&#34;&gt;&lt;/a&gt;finite &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;KnownNat&lt;/code&gt; instance is a constraint that &lt;code&gt;modulo&lt;/code&gt; needs in order to know what quotient to modulo into.&lt;/p&gt;
&lt;p&gt;This implementation &lt;em&gt;seems&lt;/em&gt; to work, except for one apparent major problem: how do we write &lt;code&gt;invert&lt;/code&gt;? Also, &lt;code&gt;stimes&lt;/code&gt; doesn’t help us &lt;em&gt;too&lt;/em&gt; much here, because repeated squaring of function composition is…still a lot of function compositions in the end.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; So, while composition with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is cheap, application with &lt;code&gt;runPerm&lt;/code&gt; is expensive (and &lt;code&gt;stimes&lt;/code&gt; works best when composition is expensive and application is cheap). So, back to the drawing board.&lt;/p&gt;
&lt;h2 id=&#34;a-second-implementation-attempt-lookin-affine-today&#34;&gt;A Second Implementation Attempt: Lookin’ Affine Today&lt;/h2&gt;
&lt;p&gt;If we look carefully at &lt;code&gt;parsePerm&lt;/code&gt;, we might start to see a pattern in all of our permutations. In fact, they all seem to follow the same form:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They all seem to be some “scaling” and “adding” of &lt;code&gt;i&lt;/code&gt;. If we align things up, this becomes a little more clear:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;                &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n)&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;               &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Perm&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;  modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n) &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; i&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Each of these seems to be some sort of scaling-and-adding of &lt;code&gt;i&lt;/code&gt;…also known as an &lt;a href=&#34;https://en.wikipedia.org/wiki/Affine_transformation&#34;&gt;Affine Transformation&lt;/a&gt;, but modulo some cyclic rotation.&lt;/p&gt;
&lt;p&gt;Well…affine transformations on cyclic indices are a subset of permutations in general. More importantly, we know (after some googling) that they are also &lt;em&gt;closed with respect to composition and inversion&lt;/em&gt; … which means that they are, themselves, a group! Maybe we can represent this as our permutation type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L16-L28&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; aScale ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-5&#34;&gt;&lt;a href=&#34;#cb14-5&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; aShift ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-6&#34;&gt;&lt;a href=&#34;#cb14-6&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb14-7&#34;&gt;&lt;a href=&#34;#cb14-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-8&#34;&gt;&lt;a href=&#34;#cb14-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runPerm ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-9&#34;&gt;&lt;a href=&#34;#cb14-9&#34;&gt;&lt;/a&gt;runPerm (&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b) x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; a &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; x &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb14-10&#34;&gt;&lt;a href=&#34;#cb14-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-11&#34;&gt;&lt;a href=&#34;#cb14-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parseAffine ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n&lt;/span&gt;
&lt;span id=&#34;cb14-12&#34;&gt;&lt;a href=&#34;#cb14-12&#34;&gt;&lt;/a&gt;parseAffine str &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;words&lt;/span&gt; str &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-13&#34;&gt;&lt;a href=&#34;#cb14-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;cut&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_           &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt;                &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;  (&lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n))&lt;/span&gt;
&lt;span id=&#34;cb14-14&#34;&gt;&lt;a href=&#34;#cb14-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;into&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt;        (&lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)          &lt;span class=&#34;fu&#34;&gt;maxBound&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-15&#34;&gt;&lt;a href=&#34;#cb14-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;st&#34;&gt;&amp;quot;deal&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;st&#34;&gt;&amp;quot;with&amp;quot;&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;n&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;_ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; (modulo (&lt;span class=&#34;fu&#34;&gt;read&lt;/span&gt; n))                 &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is “defunctionalization”: if we notice a pattern in our functions, we can instead abstract out the data that defines each instance of that pattern, and work with that data instead.&lt;/p&gt;
&lt;p&gt;So far so good! Now to think about how to define composition.&lt;/p&gt;
&lt;p&gt;If we want to do &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?f%28x%29%20%3D%20a%27%20x%20%2B%20b&#34; alt=&#34;f(x) = a&amp;#39; x + b&#34; title=&#34;f(x) = a&amp;#39; x + b&#34; /&gt; after &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?g%28x%29%20%3D%20a%20x%20%2B%20b&#34; alt=&#34;g(x) = a x + b&#34; title=&#34;g(x) = a x + b&#34; /&gt;, it’s:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%28f%20%5Ccirc%20g%29%28x%29%20%26%20%3D%20a%27%20%28a%20x%20%2B%20b%29%20%2B%20b%27%5C%5C%0A%20%20%28f%20%5Ccirc%20g%29%28x%29%20%26%20%3D%20a%27%20x%20%2B%20a%27%20b%20%2B%20b%27%0A%5Cend%7Baligned%7D%0A&#34; alt=&#34;
\begin{aligned}
(f \circ g)(x) &amp;amp; = a&amp;#39; (a x + b) + b&amp;#39;\\
  (f \circ g)(x) &amp;amp; = a&amp;#39; x + a&amp;#39; b + b&amp;#39;
\end{aligned}
&#34; title=&#34;
\begin{aligned}
(f \circ g)(x) &amp;amp; = a&amp;#39; (a x + b) + b&amp;#39;\\
  (f \circ g)(x) &amp;amp; = a&amp;#39; x + a&amp;#39; b + b&amp;#39;
\end{aligned}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;So composing &lt;code&gt;a&#39; x + b&#39;&lt;/code&gt; after &lt;code&gt;a x + b&lt;/code&gt; is is &lt;code&gt;a&#39; a x + a&#39; b + b&#39;&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L30-L31&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Semigroup&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; a) (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; b &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; b&amp;#39;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat! We can now compose &lt;em&gt;and&lt;/em&gt; run &lt;code&gt;Affine&lt;/code&gt;s efficiently, which makes &lt;code&gt;stimes&lt;/code&gt; useful! And the &lt;code&gt;Num&lt;/code&gt; instance (which requires &lt;code&gt;KnownNat n&lt;/code&gt;) for &lt;code&gt;Finite n&lt;/code&gt; takes care of automatically doing modular arithmetic for us.&lt;/p&gt;
&lt;p&gt;To define a &lt;code&gt;Monoid&lt;/code&gt; instance, we need an identity permutation. This would just leave x alone, so it makes sense that it’s &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?f%28x%29%20%3D%201%20x%20%2B%200&#34; alt=&#34;f(x) = 1 x + 0&#34; title=&#34;f(x) = 1 x + 0&#34; /&gt;, &lt;code&gt;1 x + 0&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L33-L34&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;mempty&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let’s define the inverse, which is a bit trickier.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;    invert (&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;        a&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;co&#34;&gt;-- ??&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;        b&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;co&#34;&gt;-- ??&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Inverting&lt;/em&gt; something means that we want &lt;code&gt;invert p &amp;lt;&amp;gt; p == mempty&lt;/code&gt;. That means we want to find &lt;code&gt;a&#39;&lt;/code&gt; and &lt;code&gt;b&#39;&lt;/code&gt; such that:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From our definition of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; earlier, that means we have to find &lt;code&gt;a&#39;&lt;/code&gt; and &lt;code&gt;b&#39;&lt;/code&gt; where:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; a) (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; b &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; b&amp;#39;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we need &lt;code&gt;a&#39; * a = 1&lt;/code&gt;, and &lt;code&gt;a&#39; * b + b&#39; = 0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To solve &lt;code&gt;a&#39; * a = 1&lt;/code&gt;, we can imagine that cycling &lt;code&gt;a&lt;/code&gt; through the whole deck gets you back to &lt;code&gt;a&lt;/code&gt;. (If &lt;code&gt;n&lt;/code&gt; is prime, then &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a*a&lt;/code&gt;, &lt;code&gt;a*a*a&lt;/code&gt;, etc. will all be unique…so you will keep on getting unique numbers until you exhaust the entire space at &lt;code&gt;a^size&lt;/code&gt; to arrive back at &lt;code&gt;a&lt;/code&gt;) So:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         a^n = a
=&amp;gt; a^(n-1)*a = a    -- definition of exponentiation
=&amp;gt; a^(n-1)   = 1    -- a^(n-1) leaves a unchanged, so it must be 1
=&amp;gt; a^(n-2)*a = 1    -- definition of exponentiation&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From this we can see that if &lt;code&gt;a&#39; * a = 1&lt;/code&gt;, then &lt;code&gt;a&#39;&lt;/code&gt; must be &lt;code&gt;a^(n-2)&lt;/code&gt; for prime &lt;code&gt;n&lt;/code&gt;.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The second case is a little simpler: we can just shuffle around &lt;code&gt;a&#39; * b + b&#39; = 0&lt;/code&gt; to get &lt;code&gt;b&#39; = -(a&#39; * b)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This gives us everything we need to write &lt;code&gt;invert&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L36-L41&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Group instance only works if n is prime&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;KnownNat&lt;/span&gt; n &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Group&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; n) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-5&#34;&gt;&lt;a href=&#34;#cb21-5&#34;&gt;&lt;/a&gt;    invert (&lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a b) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aff&lt;/span&gt; a&amp;#39; b&amp;#39;&lt;/span&gt;
&lt;span id=&#34;cb21-6&#34;&gt;&lt;a href=&#34;#cb21-6&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-7&#34;&gt;&lt;a href=&#34;#cb21-7&#34;&gt;&lt;/a&gt;        a&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; a &lt;span class=&#34;op&#34;&gt;^&lt;/span&gt; (natVal (&lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;n) &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb21-8&#34;&gt;&lt;a href=&#34;#cb21-8&#34;&gt;&lt;/a&gt;        b&amp;#39; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; (a&amp;#39; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt; b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…we’re done! This actually is pretty efficient with repeated squaring (which is how &lt;code&gt;^&lt;/code&gt; is implemented) because we are just squaring numbers. &lt;code&gt;natVal (Proxy @n)&lt;/code&gt; is how to get &lt;code&gt;n&lt;/code&gt; as an integer at the value level so we can use it as the exponent.&lt;/p&gt;
&lt;h2 id=&#34;the-full-implementation&#34;&gt;The Full Implementation&lt;/h2&gt;
&lt;p&gt;Just to close us out, I’ll re-paste the code we planned before, now with the context that we have implemented the appropriate permutation types. We get the &lt;code&gt;[Affine n]&lt;/code&gt;s by using &lt;code&gt;parseAffine&lt;/code&gt; on the &lt;code&gt;lines&lt;/code&gt; of our puzzle input and reversing that list.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs#L43-L54&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Part 1: Given a permutation list, find the place where 2019 ends up&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part1 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10007&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;part1 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm bigPerm &lt;span class=&#34;dv&#34;&gt;2019&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;    bigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-9&#34;&gt;&lt;a href=&#34;#cb22-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Part 2: Given a permutation list, find the index that will end up at 2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-10&#34;&gt;&lt;a href=&#34;#cb22-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;part2 ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Affine&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Finite&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;119315717514047&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-11&#34;&gt;&lt;a href=&#34;#cb22-11&#34;&gt;&lt;/a&gt;part2 perms &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runPerm (invert biiigPerm) &lt;span class=&#34;dv&#34;&gt;2020&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-12&#34;&gt;&lt;a href=&#34;#cb22-12&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-13&#34;&gt;&lt;a href=&#34;#cb22-13&#34;&gt;&lt;/a&gt;    bigPerm   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;mconcat&lt;/span&gt; perms&lt;/span&gt;
&lt;span id=&#34;cb22-14&#34;&gt;&lt;a href=&#34;#cb22-14&#34;&gt;&lt;/a&gt;    biiigPerm &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; stimes &lt;span class=&#34;dv&#34;&gt;101741582076661&lt;/span&gt; bigPerm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can load the finished code for this entire challenge &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/misc/advent-shuffle.hs&#34;&gt;here&lt;/a&gt;. I’ve also included the sample input string for my advent of code account, and also parsed it conveniently into a list of properly ordered &lt;code&gt;Affine n&lt;/code&gt;s for you to test it yourself:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./advent-shuffle.hs
ghci&amp;gt; part1 myShuffles
finite 6978
ghci&amp;gt; part2 myShuffles
finite 24460989449140&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, Haskell performs these ~47 multiplication steps pretty quickly, and part 2 is only about 3 times slower than part 1 (~40μs vs. ~14μs on my machine).&lt;/p&gt;
&lt;h2 id=&#34;the-big-picture&#34;&gt;The Big Picture&lt;/h2&gt;
&lt;p&gt;Every time I make a post about how Haskell lets you “use” math, there’s a lot of room for confusion and misunderstanding. A common misconception is that you need to know math to use Haskell, or that writing a Haskell program is like solving a math equation.&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Instead, when we say we “use” math in Haskell, it means that Haskell naturally nudges us to phrase our problems in a way that can help illuminate connections to the groundwork that has already been laid for us through centuries of mathematical discoveries — and in many cases, allow us to translate those insights into making helpful improvements and optimizations in our actual code.&lt;/p&gt;
&lt;p&gt;Haskell is “functional programming”, but I think that betrays the major insight here: we got our main conceptual leap when we thought about shuffling not as “a function”, but rather &lt;em&gt;as data&lt;/em&gt;: our shuffle is itself &lt;em&gt;data&lt;/em&gt; (here, integers), and not an “algorithm”. Had we latched onto an algorithmic approach from the beginning, we might have gotten stuck in the mire of finding a way to “optimize an algorithm”. But because we initially started thinking about permutations and shuffles as &lt;em&gt;data structures&lt;/em&gt;, we actually end up thinking about how to most effectively manipulate the data structures themselves. Instead of manipulating the cards, we manipulate the shuffle! We combine and invert the &lt;em&gt;shuffles&lt;/em&gt;, not the cards. And math — especially abstract algebra — is all about different properties of how objects can combine and universal properties about certain operations.&lt;/p&gt;
&lt;p&gt;As we head into this wonderful season, stay safe and happy haskellings, everyone! :D&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;We only allocate a few function pointers (once for each &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, where &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/jwl93i/shuffling_things_up_solving_advent_of_code_with/gcudwg4?utm_source=share&amp;amp;utm_medium=web2x&amp;amp;context=3&#34;&gt;both sides themselves point to the same function pointer&lt;/a&gt;), so it’s very efficient in space as well, but to actually “run” that final function, we need to still traverse all of those nested pointers the full number of times.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;You can also use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm&#34;&gt;Extended Euclidean Algorithm&lt;/a&gt; to find the multiplicative inverse here as well if you are a (cool) nerd. But I wanted to show a way to do this without requiring knowledge of any ring theory.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;As &lt;a href=&#34;https://www.reddit.com/r/haskell/comments/jwl93i/shuffling_things_up_solving_advent_of_code_with/gct4ihy/?context=3&#34;&gt;pointed out by rogercaptain on reddit&lt;/a&gt;, this also “works” in the case where &lt;code&gt;n&lt;/code&gt; is not prime too: only &lt;em&gt;some&lt;/em&gt; (and not all) &lt;code&gt;Affine n&lt;/code&gt;s represent permutations when &lt;code&gt;n&lt;/code&gt; is not prime, and for those specific &lt;code&gt;Affine n&lt;/code&gt;s (namely, where &lt;code&gt;a&lt;/code&gt; is coprime to &lt;code&gt;n&lt;/code&gt;), this technique does work.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Admittedly, we did do that a few times here. But that’s not &lt;em&gt;all&lt;/em&gt; we do :)&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Math</category><guid isPermaLink="true">https://blog.jle.im/entry/shuffling-things-up.html</guid><pubDate>Wed, 18 Nov 2020 18:17:52 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Math</subject><date>2020-11-18</date></item><item><title>Enhancing Functor Structures Step-By-Step (Part 2)</title><link>https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html</link><description>&lt;p&gt;Welcome to Part 2 of the &lt;a href=&#34;https://blog.jle.im/entries/series/+enhancing-functor-structures.html&#34;&gt;“Enhancing Functor Structures” series&lt;/a&gt;! Here we are taking a base structure describing a data type schema and enhancing it step-by-step with new functory capabilities: first, covariant capabilities (to generate parsers), then contravariant capabilities (to generate serializers)…who knows what might be in store next?&lt;/p&gt;
&lt;p&gt;Please do check out &lt;a href=&#34;https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html&#34;&gt;Part 1&lt;/a&gt; if you haven’t already, since this post pretty much jumps straight into things!&lt;/p&gt;
&lt;h2 id=&#34;parsing-and-serializing-invariantly&#34;&gt;Parsing and Serializing Invariantly&lt;/h2&gt;
&lt;p&gt;As we left off our project, we had done three things:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Started with a simple ADT representing the structure we want to be able to express&lt;/li&gt;
&lt;li&gt;Enhanced that simple ADT with Covariant Functor capabilities, in order to interpret it as a parser&lt;/li&gt;
&lt;li&gt;Enhanced that original simple ADT with Contravariant Functor, in order to interpret it as a serializer.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From this, it seems the next logical step would be to add &lt;em&gt;both&lt;/em&gt; enhancements to the same structure!&lt;/p&gt;
&lt;p&gt;There are some clear benefits to this — on the surface, it means we only have to write code once to get all three things (documentation, parsing, and serialization). Less code means less bugs!&lt;/p&gt;
&lt;p&gt;Even deeper, we can now ensure that our “serialization” and “parsing” functions are always “in sync”. If we defined a separate process/type for serializing and a separate process/type for parsing, then it’s possible we might accidentally make errors in keeping them in sync…one might use a different tag, or we might make changes to one but not the other during refactoring. There’s a good chance you have been bitten by situations where documentation becomes out of sync with actual code.&lt;/p&gt;
&lt;h3 id=&#34;adding-invariance&#34;&gt;Adding Invariance&lt;/h3&gt;
&lt;p&gt;Like before, the main thing we need to change at the fundamental level is &lt;code&gt;Primitive&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L39-L42&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)     (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;) (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)       (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We’re just basically combining the additions we made to enable parsing with the additions we made to enable serialization. Our new &lt;code&gt;Primitive&lt;/code&gt; type gives us the capability to do both!&lt;/p&gt;
&lt;p&gt;We can say this new &lt;code&gt;Primitive&lt;/code&gt; is an &lt;a href=&#34;https://hackage.haskell.org/package/invariant/docs/Data-Functor-Invariant.html&#34;&gt;“Invariant” Functor&lt;/a&gt;: these are functors that give you “both” capabilities: interpreting covariantly &lt;em&gt;and&lt;/em&gt; contravariantly.&lt;/p&gt;
&lt;p&gt;Because we must be able to eventually &lt;em&gt;use&lt;/em&gt; either covariant or contravariant interpretation on an invariant functor, the corresponding mapping function takes functions in both ways in order to support both on consumption-time.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Invariant&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    invmap ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;divap-and-decalt&#34;&gt;DivAp and DecAlt&lt;/h3&gt;
&lt;p&gt;By now, we know the drill. We also need to change our &lt;code&gt;RecordType&lt;/code&gt; and &lt;code&gt;SumType&lt;/code&gt; constructors to get the right type of container.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- Covariant Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L25-L29&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- Contravariant Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L21-L24&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb4-6&#34;&gt;&lt;a href=&#34;#cb4-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb4-7&#34;&gt;&lt;a href=&#34;#cb4-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For the covariant &lt;code&gt;RecordType&lt;/code&gt;, we used &lt;code&gt;Ap Field a&lt;/code&gt;. For the contravariant &lt;code&gt;RecordType&lt;/code&gt;, we used &lt;code&gt;Div Field a&lt;/code&gt;. Is there a type that combines &lt;em&gt;both&lt;/em&gt; &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;Div&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If we browse around, we see that we have &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DivAp.html&#34;&gt;DivAp&lt;/a&gt;&lt;/em&gt; from the &lt;em&gt;functor-combinatotrs&lt;/em&gt; library…which appears to be named to in a way to invoke the idea of having both &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;Div&lt;/code&gt; capabilities, combined together.&lt;/p&gt;
&lt;p&gt;For the covariant &lt;code&gt;SumType&lt;/code&gt;, we used &lt;code&gt;ListF Choice a&lt;/code&gt;. For the contravariant &lt;code&gt;SumType&lt;/code&gt;, we used &lt;code&gt;Dec Choice a&lt;/code&gt;. Is there a type that combines &lt;em&gt;both&lt;/em&gt; &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If we look nearby &lt;code&gt;DivAp&lt;/code&gt;, we see the answer: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Invariant-DecAlt.html&#34;&gt;DecAlt&lt;/a&gt;&lt;/em&gt;! It combines both &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;building-an-invariant-schema&#34;&gt;Building an Invariant Schema&lt;/h3&gt;
&lt;p&gt;Let’s wire it up:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L24-L42&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-7&#34;&gt;&lt;a href=&#34;#cb5-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-8&#34;&gt;&lt;a href=&#34;#cb5-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-9&#34;&gt;&lt;a href=&#34;#cb5-9&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-10&#34;&gt;&lt;a href=&#34;#cb5-10&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb5-11&#34;&gt;&lt;a href=&#34;#cb5-11&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb5-12&#34;&gt;&lt;a href=&#34;#cb5-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-13&#34;&gt;&lt;a href=&#34;#cb5-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-14&#34;&gt;&lt;a href=&#34;#cb5-14&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-15&#34;&gt;&lt;a href=&#34;#cb5-15&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb5-16&#34;&gt;&lt;a href=&#34;#cb5-16&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb5-17&#34;&gt;&lt;a href=&#34;#cb5-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-18&#34;&gt;&lt;a href=&#34;#cb5-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-19&#34;&gt;&lt;a href=&#34;#cb5-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)     (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-20&#34;&gt;&lt;a href=&#34;#cb5-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;) (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb5-21&#34;&gt;&lt;a href=&#34;#cb5-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)       (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Writing a schema using this type is going to be very similar to writing one for our other schema types:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L55-L72&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    swerve (\&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; x y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (x,y); &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;           (&lt;span class=&#34;fu&#34;&gt;uncurry&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb6-7&#34;&gt;&lt;a href=&#34;#cb6-7&#34;&gt;&lt;/a&gt;           &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-8&#34;&gt;&lt;a href=&#34;#cb6-8&#34;&gt;&lt;/a&gt;        (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-9&#34;&gt;&lt;a href=&#34;#cb6-9&#34;&gt;&lt;/a&gt;          { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-10&#34;&gt;&lt;a href=&#34;#cb6-10&#34;&gt;&lt;/a&gt;          , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; gathered&lt;/span&gt;
&lt;span id=&#34;cb6-11&#34;&gt;&lt;a href=&#34;#cb6-11&#34;&gt;&lt;/a&gt;              (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString })&lt;/span&gt;
&lt;span id=&#34;cb6-12&#34;&gt;&lt;a href=&#34;#cb6-12&#34;&gt;&lt;/a&gt;              (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    })&lt;/span&gt;
&lt;span id=&#34;cb6-13&#34;&gt;&lt;a href=&#34;#cb6-13&#34;&gt;&lt;/a&gt;          }&lt;/span&gt;
&lt;span id=&#34;cb6-14&#34;&gt;&lt;a href=&#34;#cb6-14&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;
&lt;span id=&#34;cb6-15&#34;&gt;&lt;a href=&#34;#cb6-15&#34;&gt;&lt;/a&gt;        (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-16&#34;&gt;&lt;a href=&#34;#cb6-16&#34;&gt;&lt;/a&gt;          { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-17&#34;&gt;&lt;a href=&#34;#cb6-17&#34;&gt;&lt;/a&gt;          , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-18&#34;&gt;&lt;a href=&#34;#cb6-18&#34;&gt;&lt;/a&gt;              inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt }&lt;/span&gt;
&lt;span id=&#34;cb6-19&#34;&gt;&lt;a href=&#34;#cb6-19&#34;&gt;&lt;/a&gt;          }&lt;/span&gt;
&lt;span id=&#34;cb6-20&#34;&gt;&lt;a href=&#34;#cb6-20&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main difference is, while &lt;code&gt;decide&lt;/code&gt; expects the &lt;code&gt;a -&amp;gt; Either b c&lt;/code&gt; splitting function, &lt;code&gt;swerve&lt;/code&gt; (the invariant &lt;code&gt;DecAlt&lt;/code&gt; equivalent) expects also the functions to “recombine” the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; back to &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;swerve&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c)    &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)             &lt;span class=&#34;co&#34;&gt;-- ^ put the branch back into the original input&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)             &lt;span class=&#34;co&#34;&gt;-- ^ put the branch back into the original input&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; f b           &lt;span class=&#34;co&#34;&gt;-- ^ handle first branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; f c           &lt;span class=&#34;co&#34;&gt;-- ^ handle second branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; f a           &lt;span class=&#34;co&#34;&gt;-- ^ overall handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-8&#34;&gt;&lt;a href=&#34;#cb7-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-9&#34;&gt;&lt;a href=&#34;#cb7-9&#34;&gt;&lt;/a&gt;swerve&lt;/span&gt;
&lt;span id=&#34;cb7-10&#34;&gt;&lt;a href=&#34;#cb7-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-11&#34;&gt;&lt;a href=&#34;#cb7-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ((&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;)              &lt;span class=&#34;co&#34;&gt;-- ^ put the CPerson branch back into a Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-12&#34;&gt;&lt;a href=&#34;#cb7-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;)                        &lt;span class=&#34;co&#34;&gt;-- ^ put the CBusiness branch back into a Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-13&#34;&gt;&lt;a href=&#34;#cb7-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)              &lt;span class=&#34;co&#34;&gt;-- ^ handle CPerson branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-14&#34;&gt;&lt;a href=&#34;#cb7-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;                        &lt;span class=&#34;co&#34;&gt;-- ^ handle CBusiness branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-15&#34;&gt;&lt;a href=&#34;#cb7-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DecAlt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-16&#34;&gt;&lt;a href=&#34;#cb7-16&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-17&#34;&gt;&lt;a href=&#34;#cb7-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- compare to what we used last time:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-18&#34;&gt;&lt;a href=&#34;#cb7-18&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb7-19&#34;&gt;&lt;a href=&#34;#cb7-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-20&#34;&gt;&lt;a href=&#34;#cb7-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)                 &lt;span class=&#34;co&#34;&gt;-- ^ handle CPerson branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-21&#34;&gt;&lt;a href=&#34;#cb7-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;                           &lt;span class=&#34;co&#34;&gt;-- ^ handle CBusiness branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-22&#34;&gt;&lt;a href=&#34;#cb7-22&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We also note that the invariant version of &lt;code&gt;divided&lt;/code&gt; is &lt;code&gt;gathered&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;gathered&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; f a          &lt;span class=&#34;co&#34;&gt;-- ^ first handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; f b          &lt;span class=&#34;co&#34;&gt;-- ^ second handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; f (a, b)     &lt;span class=&#34;co&#34;&gt;-- ^ merged handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;gathered&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpName field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;             &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpAge field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivAp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ handle both together&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- compare to what we used last time:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;divided&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpName field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;             &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpAge field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ handle both together&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;using-invariant-schema&#34;&gt;Using Invariant Schema&lt;/h3&gt;
&lt;p&gt;Let’s look into writing our interpreters. Luckily, we already did most of the work in the previous post. Writing &lt;code&gt;schemaDoc&lt;/code&gt;, &lt;code&gt;schemaParser&lt;/code&gt;, and &lt;code&gt;schemaToValue&lt;/code&gt;, we can re-use pretty much all of our code!&lt;/p&gt;
&lt;p&gt;The main (unfortunate) difference is that instead of using &lt;code&gt;interpret&lt;/code&gt; in every case, we must use &lt;code&gt;runCoDivAp&lt;/code&gt; to run our &lt;code&gt;DivAp&lt;/code&gt; in a covariant setting, and &lt;code&gt;runContraDivAp&lt;/code&gt; to run our &lt;code&gt;DivAp&lt;/code&gt; in a contravariant setting (similarly for &lt;code&gt;runCoDecAlt&lt;/code&gt; and &lt;code&gt;runContraDecAlt&lt;/code&gt;).&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L74-L150&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-7&#34;&gt;&lt;a href=&#34;#cb9-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-8&#34;&gt;&lt;a href=&#34;#cb9-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb9-9&#34;&gt;&lt;a href=&#34;#cb9-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-10&#34;&gt;&lt;a href=&#34;#cb9-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-11&#34;&gt;&lt;a href=&#34;#cb9-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb9-12&#34;&gt;&lt;a href=&#34;#cb9-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb9-13&#34;&gt;&lt;a href=&#34;#cb9-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb9-14&#34;&gt;&lt;a href=&#34;#cb9-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-15&#34;&gt;&lt;a href=&#34;#cb9-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-16&#34;&gt;&lt;a href=&#34;#cb9-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-17&#34;&gt;&lt;a href=&#34;#cb9-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb9-18&#34;&gt;&lt;a href=&#34;#cb9-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb9-19&#34;&gt;&lt;a href=&#34;#cb9-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-20&#34;&gt;&lt;a href=&#34;#cb9-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb9-21&#34;&gt;&lt;a href=&#34;#cb9-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-22&#34;&gt;&lt;a href=&#34;#cb9-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-23&#34;&gt;&lt;a href=&#34;#cb9-23&#34;&gt;&lt;/a&gt;    fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb9-24&#34;&gt;&lt;a href=&#34;#cb9-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-25&#34;&gt;&lt;a href=&#34;#cb9-25&#34;&gt;&lt;/a&gt;    choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb9-26&#34;&gt;&lt;a href=&#34;#cb9-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-27&#34;&gt;&lt;a href=&#34;#cb9-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-28&#34;&gt;&lt;a href=&#34;#cb9-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-29&#34;&gt;&lt;a href=&#34;#cb9-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-30&#34;&gt;&lt;a href=&#34;#cb9-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-31&#34;&gt;&lt;a href=&#34;#cb9-31&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-32&#34;&gt;&lt;a href=&#34;#cb9-32&#34;&gt;&lt;/a&gt;schemaParser&lt;/span&gt;
&lt;span id=&#34;cb9-33&#34;&gt;&lt;a href=&#34;#cb9-33&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-34&#34;&gt;&lt;a href=&#34;#cb9-34&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-35&#34;&gt;&lt;a href=&#34;#cb9-35&#34;&gt;&lt;/a&gt;schemaParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-36&#34;&gt;&lt;a href=&#34;#cb9-36&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; runCoDivAp  fieldParser  fs&lt;/span&gt;
&lt;span id=&#34;cb9-37&#34;&gt;&lt;a href=&#34;#cb9-37&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; runCoDecAlt choiceParser cs&lt;/span&gt;
&lt;span id=&#34;cb9-38&#34;&gt;&lt;a href=&#34;#cb9-38&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;
&lt;span id=&#34;cb9-39&#34;&gt;&lt;a href=&#34;#cb9-39&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-40&#34;&gt;&lt;a href=&#34;#cb9-40&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb9-41&#34;&gt;&lt;a href=&#34;#cb9-41&#34;&gt;&lt;/a&gt;    choiceParser (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-42&#34;&gt;&lt;a href=&#34;#cb9-42&#34;&gt;&lt;/a&gt;      tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb9-43&#34;&gt;&lt;a href=&#34;#cb9-43&#34;&gt;&lt;/a&gt;      unless (tag &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; name) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-44&#34;&gt;&lt;a href=&#34;#cb9-44&#34;&gt;&lt;/a&gt;        A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;Tag does not match&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-45&#34;&gt;&lt;a href=&#34;#cb9-45&#34;&gt;&lt;/a&gt;      A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; schemaParser val&lt;/span&gt;
&lt;span id=&#34;cb9-46&#34;&gt;&lt;a href=&#34;#cb9-46&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb9-47&#34;&gt;&lt;a href=&#34;#cb9-47&#34;&gt;&lt;/a&gt;    fieldParser (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.key (T.pack name) (schemaParser val)&lt;/span&gt;
&lt;span id=&#34;cb9-48&#34;&gt;&lt;a href=&#34;#cb9-48&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb9-49&#34;&gt;&lt;a href=&#34;#cb9-49&#34;&gt;&lt;/a&gt;    primParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-50&#34;&gt;&lt;a href=&#34;#cb9-50&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withString &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-51&#34;&gt;&lt;a href=&#34;#cb9-51&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating string&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-52&#34;&gt;&lt;a href=&#34;#cb9-52&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withScientific &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-53&#34;&gt;&lt;a href=&#34;#cb9-53&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating number&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-54&#34;&gt;&lt;a href=&#34;#cb9-54&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withBool &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-55&#34;&gt;&lt;a href=&#34;#cb9-55&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating bool&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-56&#34;&gt;&lt;a href=&#34;#cb9-56&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-57&#34;&gt;&lt;a href=&#34;#cb9-57&#34;&gt;&lt;/a&gt;schemaToValue&lt;/span&gt;
&lt;span id=&#34;cb9-58&#34;&gt;&lt;a href=&#34;#cb9-58&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-59&#34;&gt;&lt;a href=&#34;#cb9-59&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb9-60&#34;&gt;&lt;a href=&#34;#cb9-60&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-61&#34;&gt;&lt;a href=&#34;#cb9-61&#34;&gt;&lt;/a&gt;schemaToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-62&#34;&gt;&lt;a href=&#34;#cb9-62&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb9-63&#34;&gt;&lt;a href=&#34;#cb9-63&#34;&gt;&lt;/a&gt;                   &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; getOp (runContraDivAp  fieldToValue  fs)&lt;/span&gt;
&lt;span id=&#34;cb9-64&#34;&gt;&lt;a href=&#34;#cb9-64&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; getOp (runContraDecAlt choiceToValue cs)&lt;/span&gt;
&lt;span id=&#34;cb9-65&#34;&gt;&lt;a href=&#34;#cb9-65&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primToValue p&lt;/span&gt;
&lt;span id=&#34;cb9-66&#34;&gt;&lt;a href=&#34;#cb9-66&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-67&#34;&gt;&lt;a href=&#34;#cb9-67&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb9-68&#34;&gt;&lt;a href=&#34;#cb9-68&#34;&gt;&lt;/a&gt;    choiceToValue (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb9-69&#34;&gt;&lt;a href=&#34;#cb9-69&#34;&gt;&lt;/a&gt;      [ &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; T.pack name&lt;/span&gt;
&lt;span id=&#34;cb9-70&#34;&gt;&lt;a href=&#34;#cb9-70&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x&lt;/span&gt;
&lt;span id=&#34;cb9-71&#34;&gt;&lt;a href=&#34;#cb9-71&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb9-72&#34;&gt;&lt;a href=&#34;#cb9-72&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] x&lt;/span&gt;
&lt;span id=&#34;cb9-73&#34;&gt;&lt;a href=&#34;#cb9-73&#34;&gt;&lt;/a&gt;    fieldToValue (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-74&#34;&gt;&lt;a href=&#34;#cb9-74&#34;&gt;&lt;/a&gt;        [T.pack name &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x]&lt;/span&gt;
&lt;span id=&#34;cb9-75&#34;&gt;&lt;a href=&#34;#cb9-75&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-76&#34;&gt;&lt;a href=&#34;#cb9-76&#34;&gt;&lt;/a&gt;    primToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-77&#34;&gt;&lt;a href=&#34;#cb9-77&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.String&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; T.pack &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-78&#34;&gt;&lt;a href=&#34;#cb9-78&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Number&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb9-79&#34;&gt;&lt;a href=&#34;#cb9-79&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Bool&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And there we have it — a fully functional bidirectional parser schema type that we assembled step-by-step, adding each piece incrementally and exploring the space until we found something useful for us. We have a single schema that can represent documentation, parsing, and serialization in a way that they are all kept in sync, after writing things only once!&lt;/p&gt;
&lt;p&gt;A cute function we could write to tie things together would be one that does a round-trip, serializing and then parsing, to make sure things worked properly.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/invariant.hs#L152-L156&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;testRoundTrip&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb10-5&#34;&gt;&lt;a href=&#34;#cb10-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb10-6&#34;&gt;&lt;a href=&#34;#cb10-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseError&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb10-7&#34;&gt;&lt;a href=&#34;#cb10-7&#34;&gt;&lt;/a&gt;testRoundTrip sch &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.parseValue (schemaParser sch) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; schemaToValue sch&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; testRoundTrip customerSchema (&lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;40&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; {cpName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt;, cpAge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;40&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looks solid to me!&lt;/p&gt;
&lt;h2 id=&#34;an-alternative-invariant-strategy&#34;&gt;An Alternative Invariant Strategy&lt;/h2&gt;
&lt;p&gt;The thought process “I want to use both &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Ap&lt;/code&gt;, let’s just look for &lt;code&gt;DivAp&lt;/code&gt;” is kind of nice and straightforward. However, there’s a major downside in using &lt;code&gt;DivAp&lt;/code&gt; and &lt;code&gt;DecAlt&lt;/code&gt; that make their ergonomics not so great when building them up.&lt;/p&gt;
&lt;p&gt;A major part about what makes &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;ListF&lt;/code&gt; (and, to an extent, &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt;) so nice to use is that they are instances of popular Haskell typeclasses like &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Alternative&lt;/code&gt; (or &lt;code&gt;Plus&lt;/code&gt;) and using &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Alternative&lt;/code&gt; interfaces are pretty common in Haskell. Because of this, they are pretty comfortable for most Haskellers to use.&lt;/p&gt;
&lt;p&gt;However, &lt;code&gt;DivAp&lt;/code&gt; and &lt;code&gt;DecAlt&lt;/code&gt; aren’t really instances of any commonly used typeclass (aside from &lt;code&gt;Invariant&lt;/code&gt;).&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; So you really don’t have any nice interface for them other than just using functions specifically written for them, like &lt;code&gt;gather&lt;/code&gt; and &lt;code&gt;swerve&lt;/code&gt;, which may feel ad-hoc.&lt;/p&gt;
&lt;p&gt;Luckily, there’s another way to achieve the same goals and also be able to take advantage of our favorite familiar interfaces. We can “add Contravariance” directly into &lt;code&gt;Ap&lt;/code&gt; itself, using &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Route.html#t:Pre&#34;&gt;&lt;code&gt;Pre&lt;/code&gt;&lt;/a&gt;. This is a trick I first saw used in the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/unjson&#34;&gt;unjson&lt;/a&gt;&lt;/em&gt; library.&lt;/p&gt;
&lt;p&gt;Recall that &lt;code&gt;Ap Field a&lt;/code&gt; is a collection that contains a bunch of &lt;code&gt;Field x&lt;/code&gt;s of different &lt;code&gt;x&lt;/code&gt;s, and can be used to covariantly &lt;em&gt;produce&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; by combining all of the &lt;code&gt;x&lt;/code&gt;s back together.&lt;/p&gt;
&lt;p&gt;Now, a value of type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will “produce” &lt;code&gt;a&lt;/code&gt;s covariantly…but will “consume” &lt;code&gt;r&lt;/code&gt;s contravariantly. You can think of the &lt;code&gt;Pre r&lt;/code&gt; as adding an “tunnel” to guide the &lt;code&gt;r&lt;/code&gt; to each &lt;code&gt;Field&lt;/code&gt; in the &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;Ap&lt;/code&gt; is &lt;code&gt;Ap&lt;/code&gt; (famous for its &lt;code&gt;Applicative&lt;/code&gt; instance), we can use normal Applicative combinators to combine our fake invariant type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;(&lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb14-5&#34;&gt;&lt;a href=&#34;#cb14-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb14-6&#34;&gt;&lt;a href=&#34;#cb14-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) b&lt;/span&gt;
&lt;span id=&#34;cb14-7&#34;&gt;&lt;a href=&#34;#cb14-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-8&#34;&gt;&lt;a href=&#34;#cb14-8&#34;&gt;&lt;/a&gt;liftA2&lt;/span&gt;
&lt;span id=&#34;cb14-9&#34;&gt;&lt;a href=&#34;#cb14-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; c)&lt;/span&gt;
&lt;span id=&#34;cb14-10&#34;&gt;&lt;a href=&#34;#cb14-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb14-11&#34;&gt;&lt;a href=&#34;#cb14-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) b&lt;/span&gt;
&lt;span id=&#34;cb14-12&#34;&gt;&lt;a href=&#34;#cb14-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;) c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that the &lt;code&gt;Applicative&lt;/code&gt; combinators will recombine our “output” covariant types appropriately, but will keep the “input” contravariant type constant&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can construct a value of type &lt;code&gt;Ap (Pre r Field) a&lt;/code&gt; using &lt;code&gt;injectPre&lt;/code&gt;, which asks us to provide that “get an &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;r&lt;/code&gt;” function up-front:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;injectPre ::&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; r f) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How do we interpret out of &lt;code&gt;Ap (Pre r f) a&lt;/code&gt;? Well, there’s a useful newtype wrapper over &lt;code&gt;Pre&lt;/code&gt; called &lt;code&gt;PreT&lt;/code&gt; that makes consuming and interpreting it very clean, by requiring the &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; to be the same:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; t f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; (t (&lt;span class=&#34;dt&#34;&gt;Pre&lt;/span&gt; a f) a)&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | `inject` works just like it did before with `Ap` and `Div`: put that `f`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- into a `PreT`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inject ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-7&#34;&gt;&lt;a href=&#34;#cb16-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | interpret for PreT treats `PreT Ap f a` as if it were just `Ap f a`, so we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-8&#34;&gt;&lt;a href=&#34;#cb16-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- interpret into an `Applicative` context, like we did with the parsers when&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-9&#34;&gt;&lt;a href=&#34;#cb16-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- we used `Ap f a`.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-10&#34;&gt;&lt;a href=&#34;#cb16-10&#34;&gt;&lt;/a&gt;interpret&lt;/span&gt;
&lt;span id=&#34;cb16-11&#34;&gt;&lt;a href=&#34;#cb16-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb16-12&#34;&gt;&lt;a href=&#34;#cb16-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb16-13&#34;&gt;&lt;a href=&#34;#cb16-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-14&#34;&gt;&lt;a href=&#34;#cb16-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb16-15&#34;&gt;&lt;a href=&#34;#cb16-15&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-16&#34;&gt;&lt;a href=&#34;#cb16-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | But we can also interpret into a `Divisible` context!  Just like when we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-17&#34;&gt;&lt;a href=&#34;#cb16-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- used `Div f a` to write our serializer!&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-18&#34;&gt;&lt;a href=&#34;#cb16-18&#34;&gt;&lt;/a&gt;preDivisibleT&lt;/span&gt;
&lt;span id=&#34;cb16-19&#34;&gt;&lt;a href=&#34;#cb16-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb16-20&#34;&gt;&lt;a href=&#34;#cb16-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb16-21&#34;&gt;&lt;a href=&#34;#cb16-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-22&#34;&gt;&lt;a href=&#34;#cb16-22&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb16-23&#34;&gt;&lt;a href=&#34;#cb16-23&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-24&#34;&gt;&lt;a href=&#34;#cb16-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | We can also use htoList like before&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-25&#34;&gt;&lt;a href=&#34;#cb16-25&#34;&gt;&lt;/a&gt;htoList&lt;/span&gt;
&lt;span id=&#34;cb16-26&#34;&gt;&lt;a href=&#34;#cb16-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb16-27&#34;&gt;&lt;a href=&#34;#cb16-27&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb16-28&#34;&gt;&lt;a href=&#34;#cb16-28&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that &lt;code&gt;interpret&lt;/code&gt; for &lt;code&gt;PreT Ap f a&lt;/code&gt; works just like &lt;code&gt;interpret&lt;/code&gt; for &lt;code&gt;Ap f a&lt;/code&gt;; we don’t lose any power, it’s the same as always if we wanted to just use &lt;code&gt;Ap f a&lt;/code&gt; covariantly to interpret into a parser. Exactly what we did when we wrote our parser generation.&lt;/p&gt;
&lt;p&gt;But, we also gain &lt;code&gt;preDivisibleT&lt;/code&gt;, which lets us &lt;code&gt;interpret&lt;/code&gt; into a contravariant &lt;code&gt;Divisible&lt;/code&gt; context! Just like as if we had &lt;code&gt;Div f a&lt;/code&gt;! This is exactly what we did when we wrote our serializers.&lt;/p&gt;
&lt;p&gt;So using &lt;code&gt;Pre&lt;/code&gt; and &lt;code&gt;PreT&lt;/code&gt;, we get to &lt;em&gt;assemble&lt;/em&gt; it using our favorite &lt;code&gt;Applicative&lt;/code&gt; combinators…then when we wrap it in &lt;code&gt;PreT&lt;/code&gt;, we get to &lt;em&gt;interpret&lt;/em&gt; it in whatever way we want by choosing different interpreters. It’s the best of both worlds!&lt;/p&gt;
&lt;p&gt;We can do the opposite thing with &lt;code&gt;Dec&lt;/code&gt; as well: we can use &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Route.html#t:Post&#34;&gt;&lt;code&gt;Post&lt;/code&gt;&lt;/a&gt; to embed covariant capabilities in &lt;code&gt;Dec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Recall that &lt;code&gt;Div Choice a&lt;/code&gt; is a collection that contains a bunch of &lt;code&gt;Choice x&lt;/code&gt;s of different &lt;code&gt;x&lt;/code&gt;s, and can be used to contravariantly &lt;em&gt;consume&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; (by sending the &lt;code&gt;a&lt;/code&gt; to one of the different &lt;code&gt;Choice x&lt;/code&gt;s).&lt;/p&gt;
&lt;p&gt;A value of type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will “consume” &lt;code&gt;a&lt;/code&gt;s contravariantly (like a normal &lt;code&gt;Dec&lt;/code&gt;), but will also produce &lt;code&gt;r&lt;/code&gt;s covariantly. You can think of the &lt;code&gt;Post r&lt;/code&gt; as adding an “tunnel” allowing the output of each &lt;code&gt;Choice&lt;/code&gt; to exit out of the &lt;code&gt;Dec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This means we can now use normal &lt;code&gt;Conclude&lt;/code&gt; contravariant typeclass-based combinators to combine our fake invariant type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c)        &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) b    &lt;span class=&#34;co&#34;&gt;-- ^ handle first branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) c    &lt;span class=&#34;co&#34;&gt;-- ^ handle second branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-5&#34;&gt;&lt;a href=&#34;#cb18-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;) a    &lt;span class=&#34;co&#34;&gt;-- ^ overall handler&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that &lt;code&gt;decide&lt;/code&gt; will recombine our “input” contravariant types appropriately, but will keep the “output” covariant type constant&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Again, we can construct a value of type &lt;code&gt;Dec (Post r Choice) a&lt;/code&gt; using &lt;code&gt;injectPost&lt;/code&gt;, which asks us to provide that “embed the &lt;code&gt;a&lt;/code&gt; in the &lt;code&gt;r&lt;/code&gt;” function up-front:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;injectPost ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; r f) a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And again, we have the newtype wrapper &lt;code&gt;PostT&lt;/code&gt; that gives us convenient interpreting functions:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; t f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; (t (&lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; a f) a)&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-3&#34;&gt;&lt;a href=&#34;#cb20-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | `inject` works just like it did before with `Dec` and `ListF`: put that `f`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-4&#34;&gt;&lt;a href=&#34;#cb20-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- into a `PostT`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-5&#34;&gt;&lt;a href=&#34;#cb20-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inject ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-6&#34;&gt;&lt;a href=&#34;#cb20-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-7&#34;&gt;&lt;a href=&#34;#cb20-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | interpret for PostT treats `PostT Dec f a` as if it were just `Dec f a`, so we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-8&#34;&gt;&lt;a href=&#34;#cb20-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- interpret into a `Conclude` context, like we did with the serializers when&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-9&#34;&gt;&lt;a href=&#34;#cb20-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- we used `Dec f a`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-10&#34;&gt;&lt;a href=&#34;#cb20-10&#34;&gt;&lt;/a&gt;interpret&lt;/span&gt;
&lt;span id=&#34;cb20-11&#34;&gt;&lt;a href=&#34;#cb20-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb20-12&#34;&gt;&lt;a href=&#34;#cb20-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb20-13&#34;&gt;&lt;a href=&#34;#cb20-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-14&#34;&gt;&lt;a href=&#34;#cb20-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb20-15&#34;&gt;&lt;a href=&#34;#cb20-15&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-16&#34;&gt;&lt;a href=&#34;#cb20-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | But we can also interpret into a `Plus` context!  Just like when we&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-17&#34;&gt;&lt;a href=&#34;#cb20-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- used `ListF f a` to write our parser generation!&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-18&#34;&gt;&lt;a href=&#34;#cb20-18&#34;&gt;&lt;/a&gt;postPlusT&lt;/span&gt;
&lt;span id=&#34;cb20-19&#34;&gt;&lt;a href=&#34;#cb20-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb20-20&#34;&gt;&lt;a href=&#34;#cb20-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb20-21&#34;&gt;&lt;a href=&#34;#cb20-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-22&#34;&gt;&lt;a href=&#34;#cb20-22&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb20-23&#34;&gt;&lt;a href=&#34;#cb20-23&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-24&#34;&gt;&lt;a href=&#34;#cb20-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | We can also use htoList like before&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-25&#34;&gt;&lt;a href=&#34;#cb20-25&#34;&gt;&lt;/a&gt;htoList&lt;/span&gt;
&lt;span id=&#34;cb20-26&#34;&gt;&lt;a href=&#34;#cb20-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb20-27&#34;&gt;&lt;a href=&#34;#cb20-27&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb20-28&#34;&gt;&lt;a href=&#34;#cb20-28&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get the same benefits as for &lt;code&gt;PreT&lt;/code&gt;: if we want to interpret into a &lt;code&gt;Conclude&lt;/code&gt; (like we did for our serializers), we can use &lt;code&gt;interpret&lt;/code&gt;. If we want to interpret into a &lt;code&gt;Plus&lt;/code&gt; (like we did for our parser generation), we can use &lt;code&gt;postPlusT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With these new tools, we can imagine a different invariant &lt;code&gt;Schema&lt;/code&gt; type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/routing.hs#L36-L85&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb21-5&#34;&gt;&lt;a href=&#34;#cb21-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-6&#34;&gt;&lt;a href=&#34;#cb21-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-7&#34;&gt;&lt;a href=&#34;#cb21-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-8&#34;&gt;&lt;a href=&#34;#cb21-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-9&#34;&gt;&lt;a href=&#34;#cb21-9&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-10&#34;&gt;&lt;a href=&#34;#cb21-10&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb21-11&#34;&gt;&lt;a href=&#34;#cb21-11&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb21-12&#34;&gt;&lt;a href=&#34;#cb21-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-13&#34;&gt;&lt;a href=&#34;#cb21-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-14&#34;&gt;&lt;a href=&#34;#cb21-14&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-15&#34;&gt;&lt;a href=&#34;#cb21-15&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb21-16&#34;&gt;&lt;a href=&#34;#cb21-16&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb21-17&#34;&gt;&lt;a href=&#34;#cb21-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-18&#34;&gt;&lt;a href=&#34;#cb21-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-19&#34;&gt;&lt;a href=&#34;#cb21-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)     (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-20&#34;&gt;&lt;a href=&#34;#cb21-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;) (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-21&#34;&gt;&lt;a href=&#34;#cb21-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)       (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb21-22&#34;&gt;&lt;a href=&#34;#cb21-22&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-23&#34;&gt;&lt;a href=&#34;#cb21-23&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-24&#34;&gt;&lt;a href=&#34;#cb21-24&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PostT&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-25&#34;&gt;&lt;a href=&#34;#cb21-25&#34;&gt;&lt;/a&gt;    decide (\&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; x y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (x, y); &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb21-26&#34;&gt;&lt;a href=&#34;#cb21-26&#34;&gt;&lt;/a&gt;      (injectPost (&lt;span class=&#34;fu&#34;&gt;uncurry&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-27&#34;&gt;&lt;a href=&#34;#cb21-27&#34;&gt;&lt;/a&gt;        { choiceName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-28&#34;&gt;&lt;a href=&#34;#cb21-28&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PreT&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; (,)&lt;/span&gt;
&lt;span id=&#34;cb21-29&#34;&gt;&lt;a href=&#34;#cb21-29&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; injectPre &lt;span class=&#34;fu&#34;&gt;fst&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString }&lt;/span&gt;
&lt;span id=&#34;cb21-30&#34;&gt;&lt;a href=&#34;#cb21-30&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; injectPre &lt;span class=&#34;fu&#34;&gt;snd&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb21-31&#34;&gt;&lt;a href=&#34;#cb21-31&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb21-32&#34;&gt;&lt;a href=&#34;#cb21-32&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;
&lt;span id=&#34;cb21-33&#34;&gt;&lt;a href=&#34;#cb21-33&#34;&gt;&lt;/a&gt;      (injectPost &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt;         &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-34&#34;&gt;&lt;a href=&#34;#cb21-34&#34;&gt;&lt;/a&gt;        { choiceName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-35&#34;&gt;&lt;a href=&#34;#cb21-35&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; inject &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-36&#34;&gt;&lt;a href=&#34;#cb21-36&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb21-37&#34;&gt;&lt;a href=&#34;#cb21-37&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb21-38&#34;&gt;&lt;a href=&#34;#cb21-38&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that to build up &lt;code&gt;choiceValue&lt;/code&gt; for &lt;code&gt;Person&lt;/code&gt;, we can use our normal favorite &lt;code&gt;Appliciative&lt;/code&gt; combinators, like &lt;code&gt;&amp;lt;$&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;! And at the top level, we use &lt;code&gt;decide&lt;/code&gt; like we did before with our general contravariant combinators.&lt;/p&gt;
&lt;p&gt;All of our running functions look pretty much the same as well:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/routing.hs#L87-L167&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb22-9&#34;&gt;&lt;a href=&#34;#cb22-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-10&#34;&gt;&lt;a href=&#34;#cb22-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-11&#34;&gt;&lt;a href=&#34;#cb22-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb22-12&#34;&gt;&lt;a href=&#34;#cb22-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb22-13&#34;&gt;&lt;a href=&#34;#cb22-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb22-14&#34;&gt;&lt;a href=&#34;#cb22-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-15&#34;&gt;&lt;a href=&#34;#cb22-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-16&#34;&gt;&lt;a href=&#34;#cb22-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-17&#34;&gt;&lt;a href=&#34;#cb22-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb22-18&#34;&gt;&lt;a href=&#34;#cb22-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb22-19&#34;&gt;&lt;a href=&#34;#cb22-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-20&#34;&gt;&lt;a href=&#34;#cb22-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb22-21&#34;&gt;&lt;a href=&#34;#cb22-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-22&#34;&gt;&lt;a href=&#34;#cb22-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-23&#34;&gt;&lt;a href=&#34;#cb22-23&#34;&gt;&lt;/a&gt;    fieldDoc &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc fieldName fieldValue&lt;/span&gt;
&lt;span id=&#34;cb22-24&#34;&gt;&lt;a href=&#34;#cb22-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-25&#34;&gt;&lt;a href=&#34;#cb22-25&#34;&gt;&lt;/a&gt;    choiceDoc &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc choiceName choiceValue&lt;/span&gt;
&lt;span id=&#34;cb22-26&#34;&gt;&lt;a href=&#34;#cb22-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-27&#34;&gt;&lt;a href=&#34;#cb22-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-28&#34;&gt;&lt;a href=&#34;#cb22-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-29&#34;&gt;&lt;a href=&#34;#cb22-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-30&#34;&gt;&lt;a href=&#34;#cb22-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-31&#34;&gt;&lt;a href=&#34;#cb22-31&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-32&#34;&gt;&lt;a href=&#34;#cb22-32&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-33&#34;&gt;&lt;a href=&#34;#cb22-33&#34;&gt;&lt;/a&gt;schemaParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-34&#34;&gt;&lt;a href=&#34;#cb22-34&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret fieldParser fs&lt;/span&gt;
&lt;span id=&#34;cb22-35&#34;&gt;&lt;a href=&#34;#cb22-35&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; postPlusT choiceParser cs&lt;/span&gt;
&lt;span id=&#34;cb22-36&#34;&gt;&lt;a href=&#34;#cb22-36&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;
&lt;span id=&#34;cb22-37&#34;&gt;&lt;a href=&#34;#cb22-37&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-38&#34;&gt;&lt;a href=&#34;#cb22-38&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-39&#34;&gt;&lt;a href=&#34;#cb22-39&#34;&gt;&lt;/a&gt;    fieldParser &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.key (T.pack fieldName) (schemaParser fieldValue)&lt;/span&gt;
&lt;span id=&#34;cb22-40&#34;&gt;&lt;a href=&#34;#cb22-40&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-41&#34;&gt;&lt;a href=&#34;#cb22-41&#34;&gt;&lt;/a&gt;    choiceParser &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-42&#34;&gt;&lt;a href=&#34;#cb22-42&#34;&gt;&lt;/a&gt;      tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb22-43&#34;&gt;&lt;a href=&#34;#cb22-43&#34;&gt;&lt;/a&gt;      unless (tag &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; choiceName) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-44&#34;&gt;&lt;a href=&#34;#cb22-44&#34;&gt;&lt;/a&gt;        A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;Tag does not match&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-45&#34;&gt;&lt;a href=&#34;#cb22-45&#34;&gt;&lt;/a&gt;      A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; schemaParser choiceValue&lt;/span&gt;
&lt;span id=&#34;cb22-46&#34;&gt;&lt;a href=&#34;#cb22-46&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-47&#34;&gt;&lt;a href=&#34;#cb22-47&#34;&gt;&lt;/a&gt;    primParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-48&#34;&gt;&lt;a href=&#34;#cb22-48&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withString &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-49&#34;&gt;&lt;a href=&#34;#cb22-49&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating string&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-50&#34;&gt;&lt;a href=&#34;#cb22-50&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withScientific &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-51&#34;&gt;&lt;a href=&#34;#cb22-51&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating number&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-52&#34;&gt;&lt;a href=&#34;#cb22-52&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; _ f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withBool &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-53&#34;&gt;&lt;a href=&#34;#cb22-53&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating bool&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-54&#34;&gt;&lt;a href=&#34;#cb22-54&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-55&#34;&gt;&lt;a href=&#34;#cb22-55&#34;&gt;&lt;/a&gt;schemaToValue&lt;/span&gt;
&lt;span id=&#34;cb22-56&#34;&gt;&lt;a href=&#34;#cb22-56&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-57&#34;&gt;&lt;a href=&#34;#cb22-57&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-58&#34;&gt;&lt;a href=&#34;#cb22-58&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-59&#34;&gt;&lt;a href=&#34;#cb22-59&#34;&gt;&lt;/a&gt;schemaToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-60&#34;&gt;&lt;a href=&#34;#cb22-60&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; getOp (preDivisibleT fieldToValue fs)&lt;/span&gt;
&lt;span id=&#34;cb22-61&#34;&gt;&lt;a href=&#34;#cb22-61&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; getOp (interpret choiceToValue cs)&lt;/span&gt;
&lt;span id=&#34;cb22-62&#34;&gt;&lt;a href=&#34;#cb22-62&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primToValue p&lt;/span&gt;
&lt;span id=&#34;cb22-63&#34;&gt;&lt;a href=&#34;#cb22-63&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-64&#34;&gt;&lt;a href=&#34;#cb22-64&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb22-65&#34;&gt;&lt;a href=&#34;#cb22-65&#34;&gt;&lt;/a&gt;    fieldToValue &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-66&#34;&gt;&lt;a href=&#34;#cb22-66&#34;&gt;&lt;/a&gt;        [T.pack fieldName &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue fieldValue x]&lt;/span&gt;
&lt;span id=&#34;cb22-67&#34;&gt;&lt;a href=&#34;#cb22-67&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-68&#34;&gt;&lt;a href=&#34;#cb22-68&#34;&gt;&lt;/a&gt;    choiceToValue &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;{&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;} &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb22-69&#34;&gt;&lt;a href=&#34;#cb22-69&#34;&gt;&lt;/a&gt;        [ &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; T.pack choiceName&lt;/span&gt;
&lt;span id=&#34;cb22-70&#34;&gt;&lt;a href=&#34;#cb22-70&#34;&gt;&lt;/a&gt;        , &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue choiceValue x&lt;/span&gt;
&lt;span id=&#34;cb22-71&#34;&gt;&lt;a href=&#34;#cb22-71&#34;&gt;&lt;/a&gt;        ]&lt;/span&gt;
&lt;span id=&#34;cb22-72&#34;&gt;&lt;a href=&#34;#cb22-72&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-73&#34;&gt;&lt;a href=&#34;#cb22-73&#34;&gt;&lt;/a&gt;    primToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-74&#34;&gt;&lt;a href=&#34;#cb22-74&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.String&lt;/span&gt; (T.pack (f x))&lt;/span&gt;
&lt;span id=&#34;cb22-75&#34;&gt;&lt;a href=&#34;#cb22-75&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Number&lt;/span&gt; (f x)&lt;/span&gt;
&lt;span id=&#34;cb22-76&#34;&gt;&lt;a href=&#34;#cb22-76&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   f _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Bool&lt;/span&gt;   (f x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using &lt;code&gt;DivAp&lt;/code&gt;/&lt;code&gt;DecAlt&lt;/code&gt; and &lt;code&gt;PreT Ap&lt;/code&gt;/&lt;code&gt;PostT Dec&lt;/code&gt; are just two separate styles for you to consider if we want to go into combining &lt;em&gt;both&lt;/em&gt; covariant production &lt;em&gt;and&lt;/em&gt; contravariant consumption!&lt;/p&gt;
&lt;h2 id=&#34;concluding-thoughts&#34;&gt;Concluding Thoughts&lt;/h2&gt;
&lt;p&gt;If you’ve come this far, thank you for reading!&lt;/p&gt;
&lt;p&gt;The thought process described in this series was pretty much my actual thought process when writing something similar. I needed to provide documentation, a json parser, and a json serializer for a collection of data formats that I had. At first I had written three separate systems, and wrote all three separately for each format. I struggled with keeping all of them in sync, but everything clicked when I realized I could combine the documentation generator and the parser generation. I looked at my serializer system with regret on how it had to be a separate thing. But then I stared really really hard at it, and all of a sudden the idea of uniting all three of them became something I realized was worthwhile.&lt;/p&gt;
&lt;p&gt;It really was a truly “step-by-step” process…and I think it’s pretty rare that these fully formed united abstractions just pop out of your brain without going through the process of looking at each individual piece!&lt;/p&gt;
&lt;p&gt;In real code this pairing of the covariant and covariant is pretty prevalent. In another recent situation, I had to deal with “incoming” typed sockets (covariant outputters) and “outgoing” typed sockets (contravariant consumers)…the contexts where you get these sort of opposing dual pairs comes up a lot. Being able write a functor structure that lets you deal with them together can save a lot of code, reduce the space for errors, and relieve a lot of maintenance burden. For example, in the case of sockets, we could even write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | allocate an outgoing socket that only accepts values of your schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;makeOutSocket ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;OutSocket&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | allocate an incoming socket that awaits values of your schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-5&#34;&gt;&lt;a href=&#34;#cb23-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;makeInSocket ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;InSocket&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;code&gt;Schema a&lt;/code&gt; could represent a data protocol; under this system, you have the assurance that the protocol of sending a data type over a channel is always going to be the same as the protocol for receiving data, no matter what changes you make to your type. And you only have to write the code once, not twice!&lt;/p&gt;
&lt;p&gt;Try to investigate situations in your life where “structures” could be more useful as “functor structures”…and then maybe see if there’s even more value you could add by enhancing them with more functor-ness!&lt;/p&gt;
&lt;p&gt;Hopefully &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;functor-combinators&lt;/a&gt;&lt;/em&gt; and the &lt;em&gt;[functor combinatorpedia][]&lt;/em&gt; may be a useful guide along the way! You don’t have to build things “functor combinator style” like in this post (you could make everything from scratch without using &lt;code&gt;Ap&lt;/code&gt;/&lt;code&gt;Dec&lt;/code&gt;, etc.), but I have found that thinking in this style helps guide your search to solutions that already exist (like how we found &lt;code&gt;ListF&lt;/code&gt; by reading about &lt;code&gt;Ap&lt;/code&gt;), instead of reinventing the wheel every time. If anything, it can help you reframe the problem in a way that might make it more easy to grasp.&lt;/p&gt;
&lt;p&gt;Until next time, happy Haskelling!&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;These are unfortunate consequences of the fact that there is no general typeclass that contains both &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Divisible&lt;/code&gt; together, or no typeclass that contains both &lt;code&gt;Plus&lt;/code&gt; and &lt;code&gt;Conclude&lt;/code&gt; together. If these existed, we could just use &lt;code&gt;interpret&lt;/code&gt; for all four of those functions.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;There &lt;em&gt;could&lt;/em&gt; be a typeclass for “combination of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Divisible&lt;/code&gt;” and “combination of &lt;code&gt;Plus&lt;/code&gt; and &lt;code&gt;Conclude&lt;/code&gt;”:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DivisibleApplicative&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;  conquerpure ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;  divideAp ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b, c)) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And every &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Divisible&lt;/code&gt; instance would be a valid instance of this. However, this doesn’t really exist in any common Haskell libraries…and I’m not sure it exists anywhere at all.&lt;/p&gt;
&lt;p&gt;Having this typeclass would also give us an &lt;code&gt;interpret&lt;/code&gt; that we can use for both &lt;code&gt;A.Parser ErrType&lt;/code&gt; and &lt;code&gt;Op Aeson.Value&lt;/code&gt;, so we don’t need the awkward two-different-interpreter situation we had before.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;This works out because each of the &lt;code&gt;Field&lt;/code&gt;s inside could work off of the same input type. Remember that &lt;code&gt;Div f a ~ [f a]&lt;/code&gt;, it’s just a list of things that consume the same &lt;code&gt;a&lt;/code&gt;.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;This works out because each of the &lt;code&gt;Choice&lt;/code&gt;s inside could be embedded into the same output type. Remember that we used &lt;code&gt;List f a ~ [f a]&lt;/code&gt; for our contravariant choice collection before, just a list of things that produce the same &lt;code&gt;a&lt;/code&gt;.&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html</guid><pubDate>Tue, 18 Aug 2020 16:45:11 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-08-18</date></item><item><title>Enhancing Functor Structures Step-By-Step (Part 1)</title><link>https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html</link><description>&lt;p&gt;A style of Haskell programming that I’ve been pretty excited about with over the past two years or so is something that I can maybe call a “functor structure” design pattern. In this post we’re going to be exploring the idea of enhancing normal data types with different types of functor structures step-by-step, by starting with a simple useful structure and enhancing it piece by piece in order to reap incremental benefits. This process reflects a lot of the way I personally work through these things — I normally don’t get the whole powerful structure all the way; instead I incrementally add things as I see how things fit together.&lt;/p&gt;
&lt;p&gt;We’re going build the tools to describe a &lt;em&gt;data type schema&lt;/em&gt;, which can represent algebraic data types — sums and products. We’ll start off just building things we can use to &lt;em&gt;describe&lt;/em&gt; the schema (by printing out documentation), and by the end of the journey we’ll also be able to use our schema to generate parsers and serializers through json.&lt;/p&gt;
&lt;p&gt;This interest in functor structures culminated in my &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html&#34;&gt;Functor Combinatorpedia&lt;/a&gt; post last year and the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;functor-combinators&lt;/a&gt;&lt;/em&gt; library. But personally I had never really explored the less commonly used lowercase-f functor abstractions in Hask — contravariant functors and invariant functors until recently.&lt;/p&gt;
&lt;p&gt;This series is designed for an intermediate Haskeller with familiarity in things like product/sum types, using &lt;code&gt;Applicative&lt;/code&gt;/&lt;code&gt;Alternative&lt;/code&gt;, and monadic parser combinators, and is written in sync with &lt;em&gt;functor-combinators-0.3.6.0&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-schema&#34;&gt;The Schema&lt;/h2&gt;
&lt;p&gt;Let’s start with the simplest level of describing our schema: a plain ol’ AST describing the possibilities our schema can take.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L9-L31&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     [&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-7&#34;&gt;&lt;a href=&#34;#cb1-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-8&#34;&gt;&lt;a href=&#34;#cb1-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-9&#34;&gt;&lt;a href=&#34;#cb1-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-10&#34;&gt;&lt;a href=&#34;#cb1-10&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-11&#34;&gt;&lt;a href=&#34;#cb1-11&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-12&#34;&gt;&lt;a href=&#34;#cb1-12&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb1-13&#34;&gt;&lt;a href=&#34;#cb1-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-14&#34;&gt;&lt;a href=&#34;#cb1-14&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-15&#34;&gt;&lt;a href=&#34;#cb1-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-16&#34;&gt;&lt;a href=&#34;#cb1-16&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-17&#34;&gt;&lt;a href=&#34;#cb1-17&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-18&#34;&gt;&lt;a href=&#34;#cb1-18&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb1-19&#34;&gt;&lt;a href=&#34;#cb1-19&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-20&#34;&gt;&lt;a href=&#34;#cb1-20&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-21&#34;&gt;&lt;a href=&#34;#cb1-21&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-22&#34;&gt;&lt;a href=&#34;#cb1-22&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-23&#34;&gt;&lt;a href=&#34;#cb1-23&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-24&#34;&gt;&lt;a href=&#34;#cb1-24&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-25&#34;&gt;&lt;a href=&#34;#cb1-25&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our schema will either represent a record of many different fields, a sum of many different options, or a primitive value. If it’s a sum type, it’ll be described by a list of &lt;code&gt;Choice&lt;/code&gt;, which describes each branch. If it’s a record type, it’ll be described by a list of &lt;code&gt;Field&lt;/code&gt;, which describes each field. If it’s a primitive type, it’ll a &lt;code&gt;Primitive&lt;/code&gt;, which is either a string, number, or boolean.&lt;/p&gt;
&lt;p&gt;Our end goal is to be able to write a schema for a type like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L33-L36&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;   {&lt;span class=&#34;ot&#34;&gt; cpName ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;,&lt;span class=&#34;ot&#34;&gt; cpAge ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; cbEmployees ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and be able to represent documenting, parsing, and printing it all within &lt;code&gt;Schema&lt;/code&gt;. For our basic &lt;code&gt;Schema&lt;/code&gt; above, this looks like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L38-L52&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;    [ &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;            [ &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;            , &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; }&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;            ]&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;    , &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-15&#34;&gt;&lt;a href=&#34;#cb3-15&#34;&gt;&lt;/a&gt;            [ &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Employees&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; } ]&lt;/span&gt;
&lt;span id=&#34;cb3-16&#34;&gt;&lt;a href=&#34;#cb3-16&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb3-17&#34;&gt;&lt;a href=&#34;#cb3-17&#34;&gt;&lt;/a&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a value like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;PCustomer&lt;/span&gt; { cpName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt;, cpAge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;40&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;might be represented by a json value using our schema like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode json&#34;&gt;&lt;code class=&#34;sourceCode json&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Customer&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;,&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Sam&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt;&lt;span class=&#34;fu&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;fl&#34;&gt;40.0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;documentation&#34;&gt;Documentation&lt;/h2&gt;
&lt;p&gt;Using our schema type, let’s make a documentation generator. It’ll take a &lt;code&gt;Schema&lt;/code&gt; and nicely formatted documentation describing the schema itself.&lt;/p&gt;
&lt;p&gt;To make our lives easier, we’ll be using the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/prettyprinter&#34;&gt;prettyprinter&lt;/a&gt;&lt;/em&gt; library, which will handle indentation, horizontal and vertical concatenation, and other printing concerns for us.&lt;/p&gt;
&lt;p&gt;Let’s build things up by defining documentation generators for our individual types, so they’ll be easier to assemble.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L54-L79&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb6-7&#34;&gt;&lt;a href=&#34;#cb6-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-8&#34;&gt;&lt;a href=&#34;#cb6-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb6-9&#34;&gt;&lt;a href=&#34;#cb6-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-10&#34;&gt;&lt;a href=&#34;#cb6-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb6-11&#34;&gt;&lt;a href=&#34;#cb6-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-12&#34;&gt;&lt;a href=&#34;#cb6-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;schemaDoc&lt;/code&gt; will take the name of our type and a schema, and generate a &lt;code&gt;PP.Doc x&lt;/code&gt;, the type of a text document in the &lt;em&gt;prettyprinter&lt;/em&gt; library. And &lt;code&gt;fieldDoc&lt;/code&gt;, &lt;code&gt;choiceDoc&lt;/code&gt;, and &lt;code&gt;primDoc&lt;/code&gt; just generate the documentation for each individual field or constructor.&lt;/p&gt;
&lt;p&gt;(I’m using &lt;code&gt;x&lt;/code&gt; as the name of the type variable (instead of something more traditional like &lt;code&gt;a&lt;/code&gt;) to indicate that it isn’t meant to be referenced or used anywhere in any consistent way. Just remember it doesn’t mean anything special syntactically!)&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;\case&lt;/code&gt; syntax is known as &lt;em&gt;LambdaCase syntax&lt;/em&gt;, and &lt;code&gt;\case blah -&amp;gt; blah&lt;/code&gt; is just sugar for &lt;code&gt;\x -&amp;gt; case x of blah -&amp;gt; blah&lt;/code&gt;; we use it extensively here to save us from having to think of a throwaway variable name.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L73-L83&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb7-8&#34;&gt;&lt;a href=&#34;#cb7-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-9&#34;&gt;&lt;a href=&#34;#cb7-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb7-10&#34;&gt;&lt;a href=&#34;#cb7-10&#34;&gt;&lt;/a&gt;primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-11&#34;&gt;&lt;a href=&#34;#cb7-11&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-12&#34;&gt;&lt;a href=&#34;#cb7-12&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-13&#34;&gt;&lt;a href=&#34;#cb7-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing too fancy here — since &lt;code&gt;Field&lt;/code&gt; and &lt;code&gt;Choice&lt;/code&gt; just have a name and a sub-schema, we can have them call &lt;code&gt;schemaDoc&lt;/code&gt;. &lt;code&gt;primDoc&lt;/code&gt; requires making our leaf documentation, so we can just print what type they have.&lt;/p&gt;
&lt;p&gt;We tie it all together with &lt;code&gt;schemaDoc&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/doc.hs#L54-L71&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-16&#34;&gt;&lt;a href=&#34;#cb8-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-17&#34;&gt;&lt;a href=&#34;#cb8-17&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb8-18&#34;&gt;&lt;a href=&#34;#cb8-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb8-19&#34;&gt;&lt;a href=&#34;#cb8-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-20&#34;&gt;&lt;a href=&#34;#cb8-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use &lt;code&gt;PP.vsep&lt;/code&gt;, which takes a list of docs and concatenates them vertically, &lt;code&gt;PP.&amp;lt;+&amp;gt;&lt;/code&gt; which concatenates two docs horizontally, and &lt;code&gt;PP.indent&lt;/code&gt; which indents things before going down a level. We appropriately call &lt;code&gt;fieldDoc&lt;/code&gt;, &lt;code&gt;choiceDoc&lt;/code&gt;, and &lt;code&gt;primDoc&lt;/code&gt; when we actually need to print one of them.&lt;/p&gt;
&lt;p&gt;Hopefully that wasn’t too bad! There were a lot of moving parts because we have a recursive data type, but in the end hopefully each specific branch was self-contained enough to understand on their own. In the end the important thing to take away isn’t the mechanics of document generation, but rather how the data flows. Make sure you at least understand how the functions call each other, and how — this pattern is going to be very consistent across all the schema processors we write!&lt;/p&gt;
&lt;p&gt;We can test out our function on &lt;code&gt;customerSchema&lt;/code&gt;, taking advantage of the fact that &lt;code&gt;PP.Doc&lt;/code&gt;’s &lt;code&gt;Show&lt;/code&gt; instance will render the document:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ghci&amp;gt; schemaDoc &amp;quot;Customer&amp;quot; customerSchema
(Customer)
Choice of:
  {Person}
    *   Name: string
    *   Age: number
  {Business}
    *   Employees: number&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works!&lt;/p&gt;
&lt;h2 id=&#34;parsing-with-covariance&#34;&gt;Parsing with Covariance&lt;/h2&gt;
&lt;p&gt;Now, let’s talk about using our &lt;code&gt;Schema&lt;/code&gt; type to generate a &lt;em&gt;json parser&lt;/em&gt;. We want to be able to use our schema type and use it to parse information from a json value, of a given json format we are expecting.&lt;/p&gt;
&lt;p&gt;To do this, we’re going to rewrite &lt;code&gt;Schema&lt;/code&gt; to take a type parameter to represent the type we want to parse into. A &lt;code&gt;Schema a&lt;/code&gt; will be a schema that can be used to generate documentation &lt;em&gt;and&lt;/em&gt; describe a parser of &lt;code&gt;a&lt;/code&gt;s. In the end, we want &lt;code&gt;customerSchema :: Schema Customer&lt;/code&gt;, and a function like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to generate a json parser of &lt;code&gt;a&lt;/code&gt;s. We’ll be using the json parser type &lt;code&gt;Parse err a&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/aeson-better-errors&#34;&gt;aeson-better-errors&lt;/a&gt;&lt;/em&gt; (not because of the better errors, but just because it’s closer to an actual incremental/stateful parser than other alternatives out there), which can be run with &lt;code&gt;parse :: Parse err a -&amp;gt; ByteString -&amp;gt; Either (ParseError err) a&lt;/code&gt;. So our final interface will look like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L154-L155&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;parseSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ByteString&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseError&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt;) a&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;parseSchema sc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.parse (schemaParser sc)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To do this, we now have to include information on “how to parse an &lt;code&gt;a&lt;/code&gt;” in our schema. “How to parse a record” and “how to parse a sum” are going to be handled universally for all schemas…so the only thing that really will vary from type to type (aside from the structure) is how to parse those primitive leaf types when we encounter them in the json. And so, the main thing we need to modify is just &lt;code&gt;Primitive&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L43-L47&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-4&#34;&gt;&lt;a href=&#34;#cb12-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-5&#34;&gt;&lt;a href=&#34;#cb12-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-6&#34;&gt;&lt;a href=&#34;#cb12-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-7&#34;&gt;&lt;a href=&#34;#cb12-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Primitive a&lt;/code&gt; now encodes a way to &lt;em&gt;parse&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; if given the appropriate json primitive. It can be &lt;code&gt;PString&lt;/code&gt;, &lt;code&gt;PNumber&lt;/code&gt;, or &lt;code&gt;PBool&lt;/code&gt;. To create a “String Parser”, you need to use &lt;code&gt;PString&lt;/code&gt; with a function on “what to do with the string you get”. To create a “Bool parser”, you need &lt;code&gt;PBool&lt;/code&gt; with a function on what to do with the bool you get. Note that the &lt;code&gt;PNumber&lt;/code&gt; parser takes a &lt;code&gt;Scientific&lt;/code&gt;, which is the type &lt;em&gt;aeson&lt;/em&gt; (the underlying json library) uses to represent valid JSON numbers (it’s basically &lt;code&gt;Either Integer Double&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We can write some helper primitives:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L49-L56&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pString ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;pString &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-6&#34;&gt;&lt;a href=&#34;#cb13-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pInt ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-7&#34;&gt;&lt;a href=&#34;#cb13-7&#34;&gt;&lt;/a&gt;pInt &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; toBoundedInteger&lt;/span&gt;
&lt;span id=&#34;cb13-8&#34;&gt;&lt;a href=&#34;#cb13-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-9&#34;&gt;&lt;a href=&#34;#cb13-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pBool ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-10&#34;&gt;&lt;a href=&#34;#cb13-10&#34;&gt;&lt;/a&gt;pBool &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pString :: Primitive String&lt;/code&gt; is the most basic way to parse a primitive json string: just return the &lt;code&gt;String&lt;/code&gt; itself. &lt;code&gt;pInt&lt;/code&gt; needs to reject any non-integer numbers, so &lt;code&gt;toBoundedInteger :: Scientific -&amp;gt; Maybe Int&lt;/code&gt; works well.&lt;/p&gt;
&lt;p&gt;We can now start writing our parsers for each branch of &lt;code&gt;Schema&lt;/code&gt;. The &lt;code&gt;SchemaLeaf&lt;/code&gt; branch should be the simplest. We can use &lt;em&gt;aeson-better-error&lt;/em&gt;’s primitive value parsers:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Parse successfuly only if the current value is a String, running the&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- validation function&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;withString     ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-5&#34;&gt;&lt;a href=&#34;#cb14-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;withScientific ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb14-6&#34;&gt;&lt;a href=&#34;#cb14-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;withBool       ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L131-L138&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;primParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-5&#34;&gt;&lt;a href=&#34;#cb15-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withString &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-6&#34;&gt;&lt;a href=&#34;#cb15-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating string&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb15-7&#34;&gt;&lt;a href=&#34;#cb15-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withScientific &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-8&#34;&gt;&lt;a href=&#34;#cb15-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating number&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb15-9&#34;&gt;&lt;a href=&#34;#cb15-9&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.withBool &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-10&#34;&gt;&lt;a href=&#34;#cb15-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;error validating bool&amp;quot;&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nothing too fancy, mostly plumbing.&lt;/p&gt;
&lt;h3 id=&#34;deducing-ap&#34;&gt;Deducing Ap&lt;/h3&gt;
&lt;p&gt;However, this small change (and adding the type parameter) leaves in a predicament. What should &lt;code&gt;Schema&lt;/code&gt; look like?&lt;/p&gt;
&lt;p&gt;At first glance, we might think we could just write&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     [&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-7&#34;&gt;&lt;a href=&#34;#cb16-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L31-L37&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-8&#34;&gt;&lt;a href=&#34;#cb16-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-9&#34;&gt;&lt;a href=&#34;#cb16-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-10&#34;&gt;&lt;a href=&#34;#cb16-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-11&#34;&gt;&lt;a href=&#34;#cb16-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But there’s a problem here: &lt;code&gt;RecordType&lt;/code&gt; is a combination of &lt;code&gt;Field&lt;/code&gt;s, but…each &lt;code&gt;Field&lt;/code&gt; is of a different type! For example, in our &lt;code&gt;Customer&lt;/code&gt; example, the &lt;code&gt;Person&lt;/code&gt; branch has two fields: &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Age&lt;/code&gt;. Our name schema would look like &lt;code&gt;nameField :: Field String&lt;/code&gt;, and our age schema would look like &lt;code&gt;ageField :: Field Int&lt;/code&gt;…and so you can’t really put that into a list like &lt;code&gt;[Field a]&lt;/code&gt; since they each have different types. And further more, we want a final &lt;code&gt;Customer&lt;/code&gt; (in our &lt;code&gt;Schema Customer&lt;/code&gt;), a type which is different from both &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What we need is a way to express heterogeneous collection/sequence of &lt;code&gt;Field a&lt;/code&gt;, coupled with a way of “combining” all of them to create an aggregate value of a final type. A type that says “use a bunch of &lt;code&gt;Field&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;s of different types to generate a final &lt;code&gt;a&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;There are a couple of ways to arrive at this mystery type. One way is to recognize “combine a bunch of &lt;code&gt;f x&lt;/code&gt;s of different types to create an &lt;code&gt;f b&lt;/code&gt;” is essentially the M.O. of the &lt;em&gt;Applicative&lt;/em&gt; abstraction, and so essentially we want to give &lt;code&gt;Field&lt;/code&gt; some sort of &lt;code&gt;Applicative&lt;/code&gt; structure. And so we can reach for “the type that gives something an &lt;code&gt;Applicative&lt;/code&gt; structure”, the &lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html&#34;&gt;free applicative&lt;/a&gt;. (This is the strategy I talk about in my &lt;a href=&#34;https://blog.jle.im/entry/free-alternative-regexp.html&#34;&gt;Applicative Regular Expressions&lt;/a&gt; post: if you know exactly the interface you want, you can just use that interface’s free structure)&lt;/p&gt;
&lt;p&gt;Another way is to think about it as an enhancement along a functor combinator described in the &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html&#34;&gt;functor combinatorpedia&lt;/a&gt;. Here we know we want to enhance &lt;code&gt;Field&lt;/code&gt; in a specific way, so we can scan the list of functor combinators until there is one that we need. And scrolling down, we see:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html#ap-ap1&#34;&gt;&lt;strong&gt;Ap / Ap1 &lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html&#34;&gt;Control.Applicative.Free&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html&#34;&gt;Data.Functor.Apply.Free&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s that the interpreter &lt;em&gt;must&lt;/em&gt; consume &lt;em&gt;all&lt;/em&gt; of. (…)&lt;/p&gt;
&lt;p&gt;While &lt;code&gt;ListF&lt;/code&gt; may be considered “multiple options &lt;em&gt;offered&lt;/em&gt;”, &lt;code&gt;Ap&lt;/code&gt; can be considered “multiple actions all &lt;em&gt;required&lt;/em&gt;”. The interpreter must consume/interpret &lt;em&gt;all&lt;/em&gt; of the multiple &lt;code&gt;f&lt;/code&gt;s in order to interpret an &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that ordering is not enforced: while the consumer must handle each &lt;code&gt;f&lt;/code&gt; eventually, they are free to handle it in whatever order they desire. In fact, they could even all be handled in parallel. See &lt;code&gt;Free&lt;/code&gt; for a version where ordering is enforced.&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;Because this has an &lt;code&gt;Applicative&lt;/code&gt; instance, you can use &lt;code&gt;(&amp;lt;*&amp;gt;) :: Ap f (a -&amp;gt; b) -&amp;gt; Ap f a -&amp;gt; Ap f b&lt;/code&gt; to sequence multiple &lt;code&gt;Ap f&lt;/code&gt;s together, and &lt;code&gt;pure :: a -&amp;gt; Ap f a&lt;/code&gt; to produce a “no-op” &lt;code&gt;Ap&lt;/code&gt; without any &lt;code&gt;f&lt;/code&gt;s.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That sounds like it matches to me! In order to parse a &lt;code&gt;RecordType&lt;/code&gt;, we need to parse &lt;em&gt;every&lt;/em&gt; &lt;code&gt;Field&lt;/code&gt;. It doesn’t make any sense to skip one field or the other: they all need to be processed and parsed. This sounds like just the thing we need.&lt;/p&gt;
&lt;p&gt;The description here also gives a clue for what we might want to use for &lt;code&gt;SumType&lt;/code&gt; (&lt;code&gt;ListF&lt;/code&gt; sounds like a good companion for the behavior we want sum type parsers to have)&lt;/p&gt;
&lt;h3 id=&#34;building-ap&#34;&gt;Building Ap&lt;/h3&gt;
&lt;p&gt;With this, we can write our final &lt;code&gt;Schema&lt;/code&gt; type.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L25-L47&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-6&#34;&gt;&lt;a href=&#34;#cb17-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-7&#34;&gt;&lt;a href=&#34;#cb17-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-8&#34;&gt;&lt;a href=&#34;#cb17-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-9&#34;&gt;&lt;a href=&#34;#cb17-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-10&#34;&gt;&lt;a href=&#34;#cb17-10&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-11&#34;&gt;&lt;a href=&#34;#cb17-11&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb17-12&#34;&gt;&lt;a href=&#34;#cb17-12&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb17-13&#34;&gt;&lt;a href=&#34;#cb17-13&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-14&#34;&gt;&lt;a href=&#34;#cb17-14&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-15&#34;&gt;&lt;a href=&#34;#cb17-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-16&#34;&gt;&lt;a href=&#34;#cb17-16&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-17&#34;&gt;&lt;a href=&#34;#cb17-17&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb17-18&#34;&gt;&lt;a href=&#34;#cb17-18&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb17-19&#34;&gt;&lt;a href=&#34;#cb17-19&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-20&#34;&gt;&lt;a href=&#34;#cb17-20&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-21&#34;&gt;&lt;a href=&#34;#cb17-21&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-22&#34;&gt;&lt;a href=&#34;#cb17-22&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;     &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-23&#34;&gt;&lt;a href=&#34;#cb17-23&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-24&#34;&gt;&lt;a href=&#34;#cb17-24&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (&lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb17-25&#34;&gt;&lt;a href=&#34;#cb17-25&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I switched from &lt;code&gt;[Choice a]&lt;/code&gt; to &lt;code&gt;ListF Choice a&lt;/code&gt; as hinted earlier — the two are the same, but the latter has the &lt;code&gt;Functor&lt;/code&gt; instance we want (&lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; ListF Choice a -&amp;gt; ListF Choice b&lt;/code&gt;), and is an instance of useful functor combinator typeclasses. Furthermore, it illustrates the symmetry between sum types and record, since &lt;code&gt;Ap&lt;/code&gt; and &lt;code&gt;ListF&lt;/code&gt; are contrasting types: &lt;code&gt;Ap&lt;/code&gt; can be used to a represent the “product” between many required fields, and &lt;code&gt;ListF&lt;/code&gt; can be used to the option between many possible choices. It’s more clear how product types and sum types are “opposites” in a nice clean way.&lt;/p&gt;
&lt;p&gt;We can now make our &lt;code&gt;Customer&lt;/code&gt; schema:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L63-L77&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-5&#34;&gt;&lt;a href=&#34;#cb18-5&#34;&gt;&lt;/a&gt;      inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-6&#34;&gt;&lt;a href=&#34;#cb18-6&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-7&#34;&gt;&lt;a href=&#34;#cb18-7&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-8&#34;&gt;&lt;a href=&#34;#cb18-8&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-9&#34;&gt;&lt;a href=&#34;#cb18-9&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString }&lt;/span&gt;
&lt;span id=&#34;cb18-10&#34;&gt;&lt;a href=&#34;#cb18-10&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb18-11&#34;&gt;&lt;a href=&#34;#cb18-11&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb18-12&#34;&gt;&lt;a href=&#34;#cb18-12&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;op&#34;&gt;&amp;lt;!&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-13&#34;&gt;&lt;a href=&#34;#cb18-13&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-14&#34;&gt;&lt;a href=&#34;#cb18-14&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-15&#34;&gt;&lt;a href=&#34;#cb18-15&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-16&#34;&gt;&lt;a href=&#34;#cb18-16&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Employees&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt }&lt;/span&gt;
&lt;span id=&#34;cb18-17&#34;&gt;&lt;a href=&#34;#cb18-17&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main new thing is using &lt;code&gt;inject :: Choice a -&amp;gt; ListF Choice a&lt;/code&gt; and &lt;code&gt;inject :: Field a -&amp;gt; Ap Field a&lt;/code&gt; to lift our base types into their appropriate combinators. Then after that, we just use &lt;code&gt;Ap&lt;/code&gt;’s &lt;code&gt;Applicative&lt;/code&gt; instance and &lt;code&gt;ListF&lt;/code&gt;’s &lt;code&gt;Plus&lt;/code&gt; instance to combine them together. Overall it should look very similar to the schema we wrote for the documentation section.&lt;/p&gt;
&lt;h3 id=&#34;interpreting-ap&#34;&gt;Interpreting Ap&lt;/h3&gt;
&lt;p&gt;Now, the typical way to “run” an applied functor combinator is with interpreting functions, like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb19-2&#34;&gt;&lt;a href=&#34;#cb19-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; g        &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can interpret an &lt;code&gt;Ap f a&lt;/code&gt; into any &lt;code&gt;Applicative g&lt;/code&gt;, and you can interpret a &lt;code&gt;ListF f a&lt;/code&gt; into any &lt;a href=&#34;https://hackage.haskell.org/package/semigroupoids-5.3.4/docs/Data-Functor-Plus.html&#34;&gt;&lt;code&gt;Plus g&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Plus&lt;/code&gt; is basically &lt;code&gt;Alternative&lt;/code&gt; without an &lt;code&gt;Applicative&lt;/code&gt; requirement, supporting &lt;code&gt;(&amp;lt;!&amp;gt;) :: f a -&amp;gt; f a -&amp;gt; f a&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Basically, the strategy for using &lt;code&gt;interpret&lt;/code&gt; is that you write a function to interpret any individual &lt;code&gt;f&lt;/code&gt; you might find in the structure, and &lt;code&gt;interpret&lt;/code&gt; will accumulate them all together for you.&lt;/p&gt;
&lt;p&gt;In our case, if we decided to use &lt;code&gt;interpret&lt;/code&gt;, we could write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, if we have a way to parse each &lt;code&gt;Field&lt;/code&gt;, then we have a way to parse an &lt;code&gt;Ap Field a&lt;/code&gt;. If we have a way to parse each &lt;code&gt;Choice&lt;/code&gt;, then we have a way to parse a &lt;code&gt;ListF Choice a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s write those individual parsers for each smaller type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L128-L129&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;fieldParser (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.key (T.pack name) (schemaParser val)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use &lt;em&gt;aeson-better-errors&lt;/em&gt;’s &lt;code&gt;key :: Text -&amp;gt; Parser a -&amp;gt; Parser a&lt;/code&gt;, which takes a key and a parser, and runs that parser on whatever is under that key. For &lt;code&gt;fieldParser&lt;/code&gt;, we run the schema parser for our sub-schema under that key.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L121-L126&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;choiceParser (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;  tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;  unless (tag &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; name) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;    A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;Tag does not match&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;  A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; schemaParser val&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our sum type encoding has to be a bit more involved, because json doesn’t have any native sum type construct. The one we’re going to use for this post is the &lt;code&gt;{&#34;tag&#34;: &amp;lt;tag&amp;gt;, &#34;contents&#34;: &amp;lt;contents&amp;gt;}&#34;&lt;/code&gt; form. We’re going to parse whatever is in the key &lt;code&gt;&#34;tag&#34;&lt;/code&gt;, and if that tag matches our current choice’s constructor, we parse the schema parser for our sub-schema under that key. Otherwise, this choice isn’t what is currently in our json value.&lt;/p&gt;
&lt;p&gt;Finally, to bring it all together, we use the &lt;code&gt;interpret&lt;/code&gt; functions we talked about:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L115-L119&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;schemaParser &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-5&#34;&gt;&lt;a href=&#34;#cb23-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret choiceParser cs&lt;/span&gt;
&lt;span id=&#34;cb23-6&#34;&gt;&lt;a href=&#34;#cb23-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret fieldParser fs&lt;/span&gt;
&lt;span id=&#34;cb23-7&#34;&gt;&lt;a href=&#34;#cb23-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it!&lt;/p&gt;
&lt;p&gt;Ah well, not exactly so fast. Even though they could support it, &lt;em&gt;aeson-better-errors&lt;/em&gt; doesn’t provide &lt;code&gt;Plus&lt;/code&gt; a for &lt;code&gt;Parse&lt;/code&gt;. We can write them as orphans here just because this is a fun learning experience (but we usually do like to avoid defining instances for types or typeclasses that aren’t ours).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt; and &lt;code&gt;Plus&lt;/code&gt; represent fallback choices: &lt;code&gt;x &amp;lt;!&amp;gt; y&lt;/code&gt; will try &lt;code&gt;x&lt;/code&gt; first, then if &lt;code&gt;x&lt;/code&gt; fails, try &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L108-L111&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-3&#34;&gt;&lt;a href=&#34;#cb24-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseT&lt;/span&gt; e f) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-4&#34;&gt;&lt;a href=&#34;#cb24-4&#34;&gt;&lt;/a&gt;    (&lt;span class=&#34;op&#34;&gt;&amp;lt;!&amp;gt;&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;A.&amp;lt;|&amp;gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb24-5&#34;&gt;&lt;a href=&#34;#cb24-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;A.ParseT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; f) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-6&#34;&gt;&lt;a href=&#34;#cb24-6&#34;&gt;&lt;/a&gt;    zero  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; A.throwCustomError &lt;span class=&#34;st&#34;&gt;&amp;quot;No options were validated&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And…that should work!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;set &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;XOverloadedStrings&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Person\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Name\&amp;quot;: \&amp;quot;Same\&amp;quot;, \&amp;quot;Age\&amp;quot;: 40 } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-3&#34;&gt;&lt;a href=&#34;#cb25-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; {cpName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Same&amp;quot;&lt;/span&gt;, cpAge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;30&lt;/span&gt;})&lt;/span&gt;
&lt;span id=&#34;cb25-4&#34;&gt;&lt;a href=&#34;#cb25-4&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Business\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Employees\&amp;quot;: 3 } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-5&#34;&gt;&lt;a href=&#34;#cb25-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; {cbEmployees &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We were able to generate a fully functional parser from our schema, by only providing parsers for the smaller, more specific types we had (&lt;code&gt;Field&lt;/code&gt; and &lt;code&gt;Choice&lt;/code&gt;), and having them all fit together in a way directed by their &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Plus&lt;/code&gt; typeclass instances.&lt;/p&gt;
&lt;h3 id=&#34;direct-structural-inspection&#34;&gt;Direct Structural Inspection&lt;/h3&gt;
&lt;p&gt;However, sometimes the typeclass instances aren’t really the best way to handle things. It gives us a nice principled shortcut — for example, to interpret out of an &lt;code&gt;Ap&lt;/code&gt;, GHC needs a way to know “how to sequence &lt;code&gt;Parse&lt;/code&gt;s”, and so &lt;code&gt;interpret&lt;/code&gt; uses the &lt;code&gt;Applicative&lt;/code&gt; instance for that. But we know there are usually different ways to sequence or combine actions — famously in IO, we have the option to “sequence” IO actions in series or in parallel, with the default &lt;code&gt;Applicative&lt;/code&gt; instance being series sequencing. So, offloading our logic to a typeclass can be a convenient route, but it’s not necessarily the behavior we want.&lt;/p&gt;
&lt;p&gt;In our case, the &lt;code&gt;Plus&lt;/code&gt; instance actually combines failed fallback behavior in an undesirable way: our errors become not too useful, because &lt;code&gt;&amp;lt;!&amp;gt;&lt;/code&gt; always picks the right side’s errors, and we eventually run into &lt;code&gt;A.throwCustomError &#34;No options were validated&#34;&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Business\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Employees\&amp;quot;: \&amp;quot;Mustard\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb26-2&#34;&gt;&lt;a href=&#34;#cb26-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;CustomError&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;No options were validated&amp;quot;&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&#34;cb26-3&#34;&gt;&lt;a href=&#34;#cb26-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; parseSchema customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Grape\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Color\&amp;quot;: \&amp;quot;purple\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb26-4&#34;&gt;&lt;a href=&#34;#cb26-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;CustomError&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;No options were validated&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since the definition of &lt;code&gt;zero&lt;/code&gt; (which was our fault because we wrote it here as an orphan instance — oops!) always falls back to the same error, this is not very useful!&lt;/p&gt;
&lt;p&gt;As we see, &lt;code&gt;interpret&lt;/code&gt; for &lt;code&gt;ListF&lt;/code&gt;, while convenient, isn’t necessarily the best way to tear down a &lt;code&gt;ListF&lt;/code&gt;. Luckily, most functor combinators are just ADTs that we can pattern match and break down and access the structures manually. In the case of &lt;code&gt;ListF&lt;/code&gt;, the structure is pretty simple:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runListF ::&lt;/span&gt; [f a] }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our &lt;code&gt;ListF Choice a&lt;/code&gt; is just &lt;code&gt;[Choice a]&lt;/code&gt;. This is something we can work with! Let’s write a better &lt;code&gt;ListF Choice a&lt;/code&gt; processor by working with the list itself.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L140-L152&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-2&#34;&gt;&lt;a href=&#34;#cb28-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-3&#34;&gt;&lt;a href=&#34;#cb28-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaParser2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A.Parse&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ErrType&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb28-4&#34;&gt;&lt;a href=&#34;#cb28-4&#34;&gt;&lt;/a&gt;schemaParser2 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-5&#34;&gt;&lt;a href=&#34;#cb28-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; interpret fieldParser fs&lt;/span&gt;
&lt;span id=&#34;cb28-6&#34;&gt;&lt;a href=&#34;#cb28-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-7&#34;&gt;&lt;a href=&#34;#cb28-7&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;let&lt;/span&gt; schemaMap &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; M.fromList &lt;/span&gt;
&lt;span id=&#34;cb28-8&#34;&gt;&lt;a href=&#34;#cb28-8&#34;&gt;&lt;/a&gt;            [ (nm, vl) &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; nm vl &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; runListF cs ]&lt;/span&gt;
&lt;span id=&#34;cb28-9&#34;&gt;&lt;a href=&#34;#cb28-9&#34;&gt;&lt;/a&gt;      tag &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt; A.asString&lt;/span&gt;
&lt;span id=&#34;cb28-10&#34;&gt;&lt;a href=&#34;#cb28-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; M.lookup tag schemaMap &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-11&#34;&gt;&lt;a href=&#34;#cb28-11&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.throwCustomError &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-12&#34;&gt;&lt;a href=&#34;#cb28-12&#34;&gt;&lt;/a&gt;                &lt;span class=&#34;st&#34;&gt;&amp;quot;tag &amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; tag &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot; not recognized: Expected one of &amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-13&#34;&gt;&lt;a href=&#34;#cb28-13&#34;&gt;&lt;/a&gt;             &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; intercalate &lt;span class=&#34;st&#34;&gt;&amp;quot;, &amp;quot;&lt;/span&gt; (M.keys schemaMap)&lt;/span&gt;
&lt;span id=&#34;cb28-14&#34;&gt;&lt;a href=&#34;#cb28-14&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; sc &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; A.key &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; (schemaParser2 sc)&lt;/span&gt;
&lt;span id=&#34;cb28-15&#34;&gt;&lt;a href=&#34;#cb28-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primParser p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use the structure of &lt;code&gt;ListF&lt;/code&gt; to generate a &lt;code&gt;Map&lt;/code&gt; associating any tags with the schemas they are meant to encode. We then parse the tag, look up what schema it represents (if any) and then use that schema under the contents key.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;λ&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt; parseSchema2 customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Business\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Employees\&amp;quot;: \&amp;quot;Mustard\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-2&#34;&gt;&lt;a href=&#34;#cb29-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;ObjectKey&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt;,&lt;span class=&#34;dt&#34;&gt;ObjectKey&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Employees&amp;quot;&lt;/span&gt;] (&lt;span class=&#34;dt&#34;&gt;WrongType&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TyNumber&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Mustard&amp;quot;&lt;/span&gt;)))&lt;/span&gt;
&lt;span id=&#34;cb29-3&#34;&gt;&lt;a href=&#34;#cb29-3&#34;&gt;&lt;/a&gt;λ&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt; parseSchema2 customerSchema  &lt;span class=&#34;st&#34;&gt;&amp;quot;{ \&amp;quot;tag\&amp;quot;: \&amp;quot;Grape\&amp;quot;, \&amp;quot;contents\&amp;quot;: { \&amp;quot;Color\&amp;quot;: \&amp;quot;purple\&amp;quot; } }&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-4&#34;&gt;&lt;a href=&#34;#cb29-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;BadSchema&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;CustomError&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;tag Grape not recognized: Expected one of Business, Person&amp;quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Much better messages!&lt;/p&gt;
&lt;h3 id=&#34;backporting-documentation&#34;&gt;Backporting documentation&lt;/h3&gt;
&lt;p&gt;Remember that the whole point of this exercise was to &lt;em&gt;add&lt;/em&gt; functionality to our schema. That means we also have to upgrade our documentation function as well.&lt;/p&gt;
&lt;p&gt;Hopefully it is clear from the structure of our data type that we haven’t &lt;em&gt;lost&lt;/em&gt; any information. Updating our documentation generator should be just a matter of changing how to we get the items from our &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Following what we just learned, one way to do this would be to use &lt;code&gt;interpret&lt;/code&gt; or manually pattern match and take advantage of the structure. However, if we just want to get a list of monomorphic items from a functor combinator, there’s an abstraction in &lt;em&gt;functor-combinators&lt;/em&gt; that gives you a “higher-order” version of &lt;code&gt;toList&lt;/code&gt; called &lt;code&gt;htoList&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb30&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb30-1&#34;&gt;&lt;a href=&#34;#cb30-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;htoList ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;
&lt;span id=&#34;cb30-2&#34;&gt;&lt;a href=&#34;#cb30-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;htoList ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Give it a function to “get” a &lt;code&gt;b&lt;/code&gt; out of every &lt;code&gt;f&lt;/code&gt;, it collects the &lt;code&gt;b&lt;/code&gt; from every &lt;code&gt;f&lt;/code&gt; inside the structure and puts it in a list for us. Note that this type is very similar to the &lt;code&gt;map&lt;/code&gt; we used earlier:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb31&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb31-1&#34;&gt;&lt;a href=&#34;#cb31-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- what we used before&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-2&#34;&gt;&lt;a href=&#34;#cb31-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;     ::&lt;/span&gt; (          &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;   &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;]    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;
&lt;span id=&#34;cb31-3&#34;&gt;&lt;a href=&#34;#cb31-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- what we can use now&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-4&#34;&gt;&lt;a href=&#34;#cb31-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;htoList ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So it looks like &lt;code&gt;htoList&lt;/code&gt; should work as a drop-in replacement for &lt;code&gt;map&lt;/code&gt; …&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb32&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb32-1&#34;&gt;&lt;a href=&#34;#cb32-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/parse.hs#L79-L106&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-2&#34;&gt;&lt;a href=&#34;#cb32-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-3&#34;&gt;&lt;a href=&#34;#cb32-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb32-4&#34;&gt;&lt;a href=&#34;#cb32-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-5&#34;&gt;&lt;a href=&#34;#cb32-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-6&#34;&gt;&lt;a href=&#34;#cb32-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-7&#34;&gt;&lt;a href=&#34;#cb32-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-8&#34;&gt;&lt;a href=&#34;#cb32-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb32-9&#34;&gt;&lt;a href=&#34;#cb32-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb32-10&#34;&gt;&lt;a href=&#34;#cb32-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-11&#34;&gt;&lt;a href=&#34;#cb32-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb32-12&#34;&gt;&lt;a href=&#34;#cb32-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb32-13&#34;&gt;&lt;a href=&#34;#cb32-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb32-14&#34;&gt;&lt;a href=&#34;#cb32-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb32-15&#34;&gt;&lt;a href=&#34;#cb32-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-16&#34;&gt;&lt;a href=&#34;#cb32-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-17&#34;&gt;&lt;a href=&#34;#cb32-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb32-18&#34;&gt;&lt;a href=&#34;#cb32-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb32-19&#34;&gt;&lt;a href=&#34;#cb32-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb32-20&#34;&gt;&lt;a href=&#34;#cb32-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb32-21&#34;&gt;&lt;a href=&#34;#cb32-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-22&#34;&gt;&lt;a href=&#34;#cb32-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-23&#34;&gt;&lt;a href=&#34;#cb32-23&#34;&gt;&lt;/a&gt;    fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb32-24&#34;&gt;&lt;a href=&#34;#cb32-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-25&#34;&gt;&lt;a href=&#34;#cb32-25&#34;&gt;&lt;/a&gt;    choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb32-26&#34;&gt;&lt;a href=&#34;#cb32-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb32-27&#34;&gt;&lt;a href=&#34;#cb32-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-28&#34;&gt;&lt;a href=&#34;#cb32-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-29&#34;&gt;&lt;a href=&#34;#cb32-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-30&#34;&gt;&lt;a href=&#34;#cb32-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat, we just had to replace &lt;code&gt;map (\fld -&amp;gt; ..) fs&lt;/code&gt; with &lt;code&gt;htoList (\fld -&amp;gt; ...) fs&lt;/code&gt;, and &lt;code&gt;map choiceDoc cs&lt;/code&gt; with &lt;code&gt;htoList choiceDoc cs&lt;/code&gt;. We were able to re-use the exact same logic — we lose no power and upgrading was a straightforward mechanical transformation.&lt;/p&gt;
&lt;h2 id=&#34;contravariant-consumption&#34;&gt;Contravariant Consumption&lt;/h2&gt;
&lt;p&gt;Now, let’s consider instead the situation where we would want to &lt;em&gt;serialize&lt;/em&gt; an &lt;code&gt;a&lt;/code&gt; with a schema. We’ll make a type &lt;code&gt;Schema a&lt;/code&gt; that represents something that can encode an &lt;code&gt;a&lt;/code&gt; as a json value. The overall interface of using that type would be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb33&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb33-1&#34;&gt;&lt;a href=&#34;#cb33-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;schemaToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(&lt;code&gt;Aeson.Value&lt;/code&gt; being the json representation from the &lt;em&gt;aeson&lt;/em&gt; library)&lt;/p&gt;
&lt;p&gt;To keep things simple, let’s forget all the parsing stuff for now; we’ll add it back in later. Let’s just create a type that can &lt;em&gt;only&lt;/em&gt; serialize by enhancing our documentation schema.&lt;/p&gt;
&lt;p&gt;Again, for the same reasons as before, we can get away with the only fundamental change being at the leaves/primitives. Our structure itself is defined by the ADT, and all of the variations outside of the structure itself comes from how each leaf is serialized.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb34&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb34-1&#34;&gt;&lt;a href=&#34;#cb34-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L36-L39&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-2&#34;&gt;&lt;a href=&#34;#cb34-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-3&#34;&gt;&lt;a href=&#34;#cb34-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-4&#34;&gt;&lt;a href=&#34;#cb34-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb34-5&#34;&gt;&lt;a href=&#34;#cb34-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb34-6&#34;&gt;&lt;a href=&#34;#cb34-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Primitive a&lt;/code&gt; will be a way to &lt;em&gt;serialize&lt;/em&gt; a json primitive — it can be &lt;code&gt;PString&lt;/code&gt;, &lt;code&gt;PNumber&lt;/code&gt;, or &lt;code&gt;PBool&lt;/code&gt;. To create a “String Serializer”, you need to use &lt;code&gt;PString&lt;/code&gt; with a function on “how to turn it into a &lt;code&gt;String&lt;/code&gt;”. To create a “Bool parser”, you need &lt;code&gt;PBool&lt;/code&gt; with a function on what how to turn the value into a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Again, it can be useful to add some helper primitives:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb35&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb35-1&#34;&gt;&lt;a href=&#34;#cb35-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L58-L65&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-2&#34;&gt;&lt;a href=&#34;#cb35-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-3&#34;&gt;&lt;a href=&#34;#cb35-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pString ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-4&#34;&gt;&lt;a href=&#34;#cb35-4&#34;&gt;&lt;/a&gt;pString &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-5&#34;&gt;&lt;a href=&#34;#cb35-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-6&#34;&gt;&lt;a href=&#34;#cb35-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pInt ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-7&#34;&gt;&lt;a href=&#34;#cb35-7&#34;&gt;&lt;/a&gt;pInt &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fromIntegral&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-8&#34;&gt;&lt;a href=&#34;#cb35-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-9&#34;&gt;&lt;a href=&#34;#cb35-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pBool ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-10&#34;&gt;&lt;a href=&#34;#cb35-10&#34;&gt;&lt;/a&gt;pBool &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pString :: Primitive String&lt;/code&gt; is the most basic way to serialize a primitive json string: just return the &lt;code&gt;String&lt;/code&gt; itself. &lt;code&gt;pInt&lt;/code&gt; needs to serialize the &lt;code&gt;Int&lt;/code&gt; into a &lt;code&gt;Scientific&lt;/code&gt; (the numeric type of the aeson library).&lt;/p&gt;
&lt;p&gt;We can start off by writing the serializer for &lt;code&gt;Primitive&lt;/code&gt; just go get a feel for how our serializer will work:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb36&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb36-1&#34;&gt;&lt;a href=&#34;#cb36-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L138-L142&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-2&#34;&gt;&lt;a href=&#34;#cb36-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-3&#34;&gt;&lt;a href=&#34;#cb36-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;primToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-4&#34;&gt;&lt;a href=&#34;#cb36-4&#34;&gt;&lt;/a&gt;primToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-5&#34;&gt;&lt;a href=&#34;#cb36-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.String&lt;/span&gt; (T.pack (f x))&lt;/span&gt;
&lt;span id=&#34;cb36-6&#34;&gt;&lt;a href=&#34;#cb36-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Number&lt;/span&gt; (f x)&lt;/span&gt;
&lt;span id=&#34;cb36-7&#34;&gt;&lt;a href=&#34;#cb36-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   f &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Bool&lt;/span&gt;   (f x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Again, nothing too fancy — mostly plumbing along the &lt;em&gt;aeson&lt;/em&gt; library’s primitive constructors.&lt;/p&gt;
&lt;h3 id=&#34;covariance-vs-contravariance&#34;&gt;Covariance vs Contravariance&lt;/h3&gt;
&lt;p&gt;Before we go further, let’s take a moment to pause and discuss the difference between covariant and contravariant functors, and the usefulness of those concepts. “Covariant” functors (or capital-F &lt;code&gt;Functor&lt;/code&gt;s in Haskell) are functors &lt;code&gt;f&lt;/code&gt; where you can consider &lt;code&gt;f a&lt;/code&gt; as a “producer” of &lt;code&gt;a&lt;/code&gt; — for example, &lt;code&gt;Schema a&lt;/code&gt; from our parsing section is a thing you can use to parse/produce an &lt;code&gt;a&lt;/code&gt; out of a bytestring. These are things where it makes sense to &lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; f a -&amp;gt; f b&lt;/code&gt;: if you have a producer of &lt;code&gt;a&lt;/code&gt;s, you can always “post-filter” the result with an &lt;code&gt;a -&amp;gt; b&lt;/code&gt; to get a producer of &lt;code&gt;b&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;“Contravariant” functors (&lt;code&gt;Contravariant&lt;/code&gt; in Haskell) are functors &lt;code&gt;f&lt;/code&gt; where you can consider &lt;code&gt;f a&lt;/code&gt; as a “consumer” of &lt;code&gt;a&lt;/code&gt;. For example, &lt;code&gt;Primtive a&lt;/code&gt; (and the &lt;code&gt;Schema a&lt;/code&gt; we want to make) from our serializing section is something that consums &lt;code&gt;a&lt;/code&gt;s and produces json values. These are things where it makes sense to &lt;code&gt;contramap&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb37&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb37-1&#34;&gt;&lt;a href=&#34;#cb37-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb37-2&#34;&gt;&lt;a href=&#34;#cb37-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    contramap ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which says: if you have a consumer of &lt;code&gt;b&lt;/code&gt;s, you can always “pre-filter” the input with an &lt;code&gt;a -&amp;gt; b&lt;/code&gt; to get a consumer of &lt;code&gt;a&lt;/code&gt;s.&lt;/p&gt;
&lt;h3 id=&#34;deducing-dec&#34;&gt;Deducing Dec&lt;/h3&gt;
&lt;p&gt;Now, back on to building our &lt;code&gt;Schema&lt;/code&gt; type. Again, we might want to write something like&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb38&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb38-1&#34;&gt;&lt;a href=&#34;#cb38-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-2&#34;&gt;&lt;a href=&#34;#cb38-2&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  [&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb38-3&#34;&gt;&lt;a href=&#34;#cb38-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     [&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a]&lt;/span&gt;
&lt;span id=&#34;cb38-4&#34;&gt;&lt;a href=&#34;#cb38-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb38-5&#34;&gt;&lt;a href=&#34;#cb38-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-6&#34;&gt;&lt;a href=&#34;#cb38-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L26-L31&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-7&#34;&gt;&lt;a href=&#34;#cb38-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-8&#34;&gt;&lt;a href=&#34;#cb38-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-9&#34;&gt;&lt;a href=&#34;#cb38-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-10&#34;&gt;&lt;a href=&#34;#cb38-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, we have a problem here (incidentally, it’s the opposite of the problem we had in the previous case). &lt;code&gt;Choice a&lt;/code&gt; doesn’t quite make sense as the sum type consumer for &lt;code&gt;Schema a&lt;/code&gt;, because each &lt;code&gt;Choice&lt;/code&gt; is only meant to handle the types in a &lt;em&gt;specific&lt;/em&gt; branch. For example, in our &lt;code&gt;Customer&lt;/code&gt; example, for the &lt;code&gt;CPerson&lt;/code&gt; branch we need a &lt;code&gt;Choice (String, Int)&lt;/code&gt; to consume its contents, and in the &lt;code&gt;CBusiness&lt;/code&gt; branch we need a &lt;code&gt;Choice Int&lt;/code&gt; to consume its contents.&lt;/p&gt;
&lt;p&gt;What we need is a way to express a hetereogenous collection/sequence of &lt;code&gt;Choice a&lt;/code&gt;, coupled with a way of “choosing” exactly one of them to handle one form that our input &lt;code&gt;a&lt;/code&gt; can take. A type that says “use exactly one of a bunch of &lt;code&gt;Choice&lt;/code&gt;s of different &lt;code&gt;x&lt;/code&gt;s, and choose one to dispatch depending on what &lt;code&gt;a&lt;/code&gt; we get”. So how do we find the tool we need?&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If&lt;/em&gt; you are already familiar with contravariant abstractions (but who is?) you might recognize this as the essence of the &lt;a href=&#34;https://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant-Divisible.html#g:6&#34;&gt;Decidable&lt;/a&gt; typeclass, from the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/contravariant&#34;&gt;contravariant&lt;/a&gt;&lt;/em&gt; library…or more accurately, “Decidable without a Divisible constraint”, which is &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Conclude.html&#34;&gt;Conclude&lt;/a&gt;. A &lt;code&gt;Conclude f&lt;/code&gt; allows you to combine two &lt;code&gt;f&lt;/code&gt; values, and one will be picked to use based on inspection of the input value. Upon recognizing this, we look for find a way to give &lt;code&gt;Choice&lt;/code&gt; some &lt;code&gt;Conclude&lt;/code&gt; interface and search up “the type that gives us a free &lt;code&gt;Conclude&lt;/code&gt; structure”. Following that search, we arrive at &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Divisible-Free.html&#34;&gt;&lt;code&gt;Dec&lt;/code&gt;&lt;/a&gt;, and so we use &lt;code&gt;Dec Choice a&lt;/code&gt; for our sum type consumer.&lt;/p&gt;
&lt;p&gt;But let’s say you’re like the vast majority of Haskell users and have never had any reason to look at the contravariant abstraction hierarchy. How would you think of this?&lt;/p&gt;
&lt;p&gt;Like before, we could also look through the &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html&#34;&gt;functor combinatorpedia&lt;/a&gt; (in specific, the contravariant section) and find:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html#dec-dec1&#34;&gt;&lt;strong&gt;Dec / Dec1&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s, one of which will be chosen to consume the overall input.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;f x&lt;/code&gt; is a consumer of &lt;code&gt;x&lt;/code&gt;s, then &lt;code&gt;Dec f a&lt;/code&gt; is a consumer of &lt;code&gt;a&lt;/code&gt;s that does its job by choosing a single one of those &lt;code&gt;f&lt;/code&gt;s to handle that consumption, based on what &lt;code&gt;a&lt;/code&gt; is received.&lt;/p&gt;
&lt;p&gt;Contrast this with &lt;code&gt;Div&lt;/code&gt;, where the multiple &lt;code&gt;f&lt;/code&gt; actions are &lt;em&gt;all&lt;/em&gt; used to consume the input. &lt;code&gt;Dec&lt;/code&gt; only uses &lt;em&gt;one single&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; action to consume the input, chosen at consumption time.&lt;/p&gt;
&lt;p&gt;For example, let’s say you had a type &lt;code&gt;Socket a&lt;/code&gt; which represents some IO channel or socket that is expecting to receive &lt;code&gt;a&lt;/code&gt;s. A &lt;code&gt;Dec Socket b&lt;/code&gt; would be a collection of sockets that expects a single &lt;code&gt;b&lt;/code&gt; overall, and will pick exactly one of those &lt;code&gt;Socket&lt;/code&gt;s to handle that &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sounds like exactly what we need! It also gives us a nice hint of what we might want to use for &lt;code&gt;RecordType&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;building-dec&#34;&gt;Building Dec&lt;/h3&gt;
&lt;p&gt;With this, we can write our final &lt;code&gt;Schema&lt;/code&gt; type.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb39&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb39-1&#34;&gt;&lt;a href=&#34;#cb39-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L21-L39&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-2&#34;&gt;&lt;a href=&#34;#cb39-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-3&#34;&gt;&lt;a href=&#34;#cb39-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-4&#34;&gt;&lt;a href=&#34;#cb39-4&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a)&lt;/span&gt;
&lt;span id=&#34;cb39-5&#34;&gt;&lt;a href=&#34;#cb39-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;     (&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb39-6&#34;&gt;&lt;a href=&#34;#cb39-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb39-7&#34;&gt;&lt;a href=&#34;#cb39-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-8&#34;&gt;&lt;a href=&#34;#cb39-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-9&#34;&gt;&lt;a href=&#34;#cb39-9&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; fieldName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-10&#34;&gt;&lt;a href=&#34;#cb39-10&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; fieldValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb39-11&#34;&gt;&lt;a href=&#34;#cb39-11&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb39-12&#34;&gt;&lt;a href=&#34;#cb39-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-13&#34;&gt;&lt;a href=&#34;#cb39-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-14&#34;&gt;&lt;a href=&#34;#cb39-14&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; choiceName  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-15&#34;&gt;&lt;a href=&#34;#cb39-15&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; choiceValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb39-16&#34;&gt;&lt;a href=&#34;#cb39-16&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb39-17&#34;&gt;&lt;a href=&#34;#cb39-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-18&#34;&gt;&lt;a href=&#34;#cb39-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-19&#34;&gt;&lt;a href=&#34;#cb39-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb39-20&#34;&gt;&lt;a href=&#34;#cb39-20&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Scientific&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb39-21&#34;&gt;&lt;a href=&#34;#cb39-21&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that I switched from &lt;code&gt;[Field a]&lt;/code&gt; to &lt;code&gt;Div Field a&lt;/code&gt; — the two are the same (&lt;code&gt;Div Field a&lt;/code&gt; is essentially a newtype wrapper over &lt;code&gt;[Field a]&lt;/code&gt;), but the latter has useful functor combinator typeclass instance methods like &lt;code&gt;interpret&lt;/code&gt; (like &lt;code&gt;ListF&lt;/code&gt; before)&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. And, again, I feel like it illustrates the symmetry between sum types and record types; &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Dec&lt;/code&gt; are opposite types, as &lt;code&gt;Dec&lt;/code&gt; represents a contravariant choice between different choices, and &lt;code&gt;Div&lt;/code&gt; represents a contravariant merger between different consumers. It makes more clear the duality between product types and sum types.&lt;/p&gt;
&lt;p&gt;We can assemble our &lt;code&gt;Customer&lt;/code&gt; schema, in a way that looks a lot like our parser schema:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb40&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb40-1&#34;&gt;&lt;a href=&#34;#cb40-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L72-L87&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-2&#34;&gt;&lt;a href=&#34;#cb40-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-3&#34;&gt;&lt;a href=&#34;#cb40-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;customerSchema ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-4&#34;&gt;&lt;a href=&#34;#cb40-4&#34;&gt;&lt;/a&gt;customerSchema &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-5&#34;&gt;&lt;a href=&#34;#cb40-5&#34;&gt;&lt;/a&gt;    decide (\&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CPerson&lt;/span&gt; x y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt; (x, y); &lt;span class=&#34;dt&#34;&gt;CBusiness&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb40-6&#34;&gt;&lt;a href=&#34;#cb40-6&#34;&gt;&lt;/a&gt;      (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-7&#34;&gt;&lt;a href=&#34;#cb40-7&#34;&gt;&lt;/a&gt;        { choiceName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Person&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-8&#34;&gt;&lt;a href=&#34;#cb40-8&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; divided&lt;/span&gt;
&lt;span id=&#34;cb40-9&#34;&gt;&lt;a href=&#34;#cb40-9&#34;&gt;&lt;/a&gt;            (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Name&amp;quot;&lt;/span&gt;, fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pString })&lt;/span&gt;
&lt;span id=&#34;cb40-10&#34;&gt;&lt;a href=&#34;#cb40-10&#34;&gt;&lt;/a&gt;            (inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    })&lt;/span&gt;
&lt;span id=&#34;cb40-11&#34;&gt;&lt;a href=&#34;#cb40-11&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb40-12&#34;&gt;&lt;a href=&#34;#cb40-12&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;
&lt;span id=&#34;cb40-13&#34;&gt;&lt;a href=&#34;#cb40-13&#34;&gt;&lt;/a&gt;      (inject &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-14&#34;&gt;&lt;a href=&#34;#cb40-14&#34;&gt;&lt;/a&gt;        { choiceName  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Business&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-15&#34;&gt;&lt;a href=&#34;#cb40-15&#34;&gt;&lt;/a&gt;        , choiceValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb40-16&#34;&gt;&lt;a href=&#34;#cb40-16&#34;&gt;&lt;/a&gt;            inject &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; { fieldName &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Age&amp;quot;&lt;/span&gt; , fieldValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; pInt    }&lt;/span&gt;
&lt;span id=&#34;cb40-17&#34;&gt;&lt;a href=&#34;#cb40-17&#34;&gt;&lt;/a&gt;        }&lt;/span&gt;
&lt;span id=&#34;cb40-18&#34;&gt;&lt;a href=&#34;#cb40-18&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we use a few contravariant combinators to combine and merge contravariant functors values (like &lt;code&gt;Div Field a&lt;/code&gt; and &lt;code&gt;Dec Choice a&lt;/code&gt;):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;decide&lt;/code&gt; works like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb41&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb41-1&#34;&gt;&lt;a href=&#34;#cb41-1&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb41-2&#34;&gt;&lt;a href=&#34;#cb41-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb41-3&#34;&gt;&lt;a href=&#34;#cb41-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c)    &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-4&#34;&gt;&lt;a href=&#34;#cb41-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b                  &lt;span class=&#34;co&#34;&gt;-- ^ handle first branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-5&#34;&gt;&lt;a href=&#34;#cb41-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f c                  &lt;span class=&#34;co&#34;&gt;-- ^ handle second branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-6&#34;&gt;&lt;a href=&#34;#cb41-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a                  &lt;span class=&#34;co&#34;&gt;-- ^ overall handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-7&#34;&gt;&lt;a href=&#34;#cb41-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-8&#34;&gt;&lt;a href=&#34;#cb41-8&#34;&gt;&lt;/a&gt;decide&lt;/span&gt;
&lt;span id=&#34;cb41-9&#34;&gt;&lt;a href=&#34;#cb41-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ break into branches&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-10&#34;&gt;&lt;a href=&#34;#cb41-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)                 &lt;span class=&#34;co&#34;&gt;-- ^ handle CPerson branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-11&#34;&gt;&lt;a href=&#34;#cb41-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;                           &lt;span class=&#34;co&#34;&gt;-- ^ handle CBusiness branch&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-12&#34;&gt;&lt;a href=&#34;#cb41-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Customer&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And &lt;code&gt;divided&lt;/code&gt; works like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb42&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb42-1&#34;&gt;&lt;a href=&#34;#cb42-1&#34;&gt;&lt;/a&gt;divided&lt;/span&gt;
&lt;span id=&#34;cb42-2&#34;&gt;&lt;a href=&#34;#cb42-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb42-3&#34;&gt;&lt;a href=&#34;#cb42-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f a          &lt;span class=&#34;co&#34;&gt;-- ^ first handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-4&#34;&gt;&lt;a href=&#34;#cb42-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b          &lt;span class=&#34;co&#34;&gt;-- ^ second handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-5&#34;&gt;&lt;a href=&#34;#cb42-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f (a, b)     &lt;span class=&#34;co&#34;&gt;-- ^ merged handler&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-6&#34;&gt;&lt;a href=&#34;#cb42-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-7&#34;&gt;&lt;a href=&#34;#cb42-7&#34;&gt;&lt;/a&gt;divided&lt;/span&gt;
&lt;span id=&#34;cb42-8&#34;&gt;&lt;a href=&#34;#cb42-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpName field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-9&#34;&gt;&lt;a href=&#34;#cb42-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;             &lt;span class=&#34;co&#34;&gt;-- ^ handle the cpAge field&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-10&#34;&gt;&lt;a href=&#34;#cb42-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;)   &lt;span class=&#34;co&#34;&gt;-- ^ handle both together&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;interpreting-dec&#34;&gt;Interpreting Dec&lt;/h3&gt;
&lt;p&gt;To write our schema serializers, we can use &lt;code&gt;interpret&lt;/code&gt; again:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb43&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb43-1&#34;&gt;&lt;a href=&#34;#cb43-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb43-2&#34;&gt;&lt;a href=&#34;#cb43-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;interpret ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; g  &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But, what should we choose as our choice of &lt;code&gt;g&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb44&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb44-1&#34;&gt;&lt;a href=&#34;#cb44-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Well, how do we want to “use” a &lt;code&gt;Choice a&lt;/code&gt;? Remember that &lt;code&gt;Schema a&lt;/code&gt; encodes a way to serialize an &lt;code&gt;a&lt;/code&gt; to an json value. A &lt;code&gt;Choice a&lt;/code&gt; would encode a way to serialize an &lt;code&gt;a&lt;/code&gt; into a json value. We want to turn a &lt;code&gt;Choice a&lt;/code&gt; into an &lt;code&gt;a -&amp;gt; Aeson.Value&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb45&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb45-1&#34;&gt;&lt;a href=&#34;#cb45-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb45-2&#34;&gt;&lt;a href=&#34;#cb45-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb45-3&#34;&gt;&lt;a href=&#34;#cb45-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- is supposed to match up with&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb45-4&#34;&gt;&lt;a href=&#34;#cb45-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, we need to pick some &lt;code&gt;g&lt;/code&gt; where &lt;code&gt;g a&lt;/code&gt; is &lt;code&gt;a -&amp;gt; Aeson.Value&lt;/code&gt;. This is exactly &lt;code&gt;Op&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Contravariant.html&#34;&gt;Data.Functor.Contravariant&lt;/a&gt;&lt;/em&gt;, in &lt;em&gt;base&lt;/em&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb46&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb46-1&#34;&gt;&lt;a href=&#34;#cb46-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getOp ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, if we write&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb47&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb47-1&#34;&gt;&lt;a href=&#34;#cb47-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb47-2&#34;&gt;&lt;a href=&#34;#cb47-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb47-3&#34;&gt;&lt;a href=&#34;#cb47-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- a newtype wrapper away from&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb47-4&#34;&gt;&lt;a href=&#34;#cb47-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;then we have&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb48&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb48-1&#34;&gt;&lt;a href=&#34;#cb48-1&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb48-2&#34;&gt;&lt;a href=&#34;#cb48-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb48-3&#34;&gt;&lt;a href=&#34;#cb48-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- a newtype wrapper away from&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb48-4&#34;&gt;&lt;a href=&#34;#cb48-4&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s write it!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb49&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb49-1&#34;&gt;&lt;a href=&#34;#cb49-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L128-L132&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb49-2&#34;&gt;&lt;a href=&#34;#cb49-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb49-3&#34;&gt;&lt;a href=&#34;#cb49-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb49-4&#34;&gt;&lt;a href=&#34;#cb49-4&#34;&gt;&lt;/a&gt;choiceToValue (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object&lt;/span&gt;
&lt;span id=&#34;cb49-5&#34;&gt;&lt;a href=&#34;#cb49-5&#34;&gt;&lt;/a&gt;    [ &lt;span class=&#34;st&#34;&gt;&amp;quot;tag&amp;quot;&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; T.pack name&lt;/span&gt;
&lt;span id=&#34;cb49-6&#34;&gt;&lt;a href=&#34;#cb49-6&#34;&gt;&lt;/a&gt;    , &lt;span class=&#34;st&#34;&gt;&amp;quot;contents&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x&lt;/span&gt;
&lt;span id=&#34;cb49-7&#34;&gt;&lt;a href=&#34;#cb49-7&#34;&gt;&lt;/a&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now onto &lt;code&gt;RecordType&lt;/code&gt;’s &lt;code&gt;Div Field&lt;/code&gt;. Here, we want to build an object using &lt;code&gt;Aeson.object :: [Aeson.Pair] -&amp;gt; Aeson.Value&lt;/code&gt; (one way that the &lt;em&gt;aeson&lt;/em&gt; library allows us to build objects). Therefore, our type for &lt;code&gt;fieldToValue&lt;/code&gt; should be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb50&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb50-1&#34;&gt;&lt;a href=&#34;#cb50-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This looks familiar; it’s the same thing as before, but with &lt;code&gt;Op [Aeson.Pair]&lt;/code&gt; instead of &lt;code&gt;Op Aeson.Value&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb51&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb51-1&#34;&gt;&lt;a href=&#34;#cb51-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb51-2&#34;&gt;&lt;a href=&#34;#cb51-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-3&#34;&gt;&lt;a href=&#34;#cb51-3&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb51-4&#34;&gt;&lt;a href=&#34;#cb51-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-5&#34;&gt;&lt;a href=&#34;#cb51-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- a newtype wrapper away from&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-6&#34;&gt;&lt;a href=&#34;#cb51-6&#34;&gt;&lt;/a&gt;interpret&lt;span class=&#34;ot&#34;&gt; fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can go ahead and write it out, actually:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb52&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb52-1&#34;&gt;&lt;a href=&#34;#cb52-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L134-L136&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-2&#34;&gt;&lt;a href=&#34;#cb52-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-3&#34;&gt;&lt;a href=&#34;#cb52-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;] a&lt;/span&gt;
&lt;span id=&#34;cb52-4&#34;&gt;&lt;a href=&#34;#cb52-4&#34;&gt;&lt;/a&gt;fieldToValue (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Op&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-5&#34;&gt;&lt;a href=&#34;#cb52-5&#34;&gt;&lt;/a&gt;    [T.pack name &lt;span class=&#34;op&#34;&gt;Aeson..=&lt;/span&gt; schemaToValue val x]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Note that this behavior relies on the fact that the &lt;code&gt;interpret&lt;/code&gt; instance for &lt;code&gt;Div&lt;/code&gt; — using the &lt;code&gt;Divise&lt;/code&gt; instance for &lt;code&gt;Op r&lt;/code&gt; — will combine the &lt;code&gt;[Aeson.Pair]&lt;/code&gt; list monoidally, concatenating the results of calling &lt;code&gt;fieldToValue&lt;/code&gt; on every &lt;code&gt;Field&lt;/code&gt; in the &lt;code&gt;Div Field a&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;We should now have enough to write our entire serializer:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb53&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb53-1&#34;&gt;&lt;a href=&#34;#cb53-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L119-L126&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-2&#34;&gt;&lt;a href=&#34;#cb53-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-3&#34;&gt;&lt;a href=&#34;#cb53-3&#34;&gt;&lt;/a&gt;schemaToValue&lt;/span&gt;
&lt;span id=&#34;cb53-4&#34;&gt;&lt;a href=&#34;#cb53-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb53-5&#34;&gt;&lt;a href=&#34;#cb53-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb53-6&#34;&gt;&lt;a href=&#34;#cb53-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-7&#34;&gt;&lt;a href=&#34;#cb53-7&#34;&gt;&lt;/a&gt;schemaToValue &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb53-8&#34;&gt;&lt;a href=&#34;#cb53-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt;    cs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; getOp (interpret choiceToValue cs)&lt;/span&gt;
&lt;span id=&#34;cb53-9&#34;&gt;&lt;a href=&#34;#cb53-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; Aeson.object &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; getOp (interpret fieldToValue fs)&lt;/span&gt;
&lt;span id=&#34;cb53-10&#34;&gt;&lt;a href=&#34;#cb53-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; primToValue p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running our &lt;code&gt;schemaToValue&lt;/code&gt; on a sample &lt;code&gt;Person&lt;/code&gt; gives the json value we expect:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ghci&amp;gt; Aeson.encode (schemaToValue customerSchema (CPerson &amp;quot;Sam&amp;quot; 40))
{&amp;quot;tag&amp;quot;:&amp;quot;Person&amp;quot;,&amp;quot;contents&amp;quot;:{&amp;quot;Age&amp;quot;:40,&amp;quot;Name&amp;quot;:&amp;quot;Sam&amp;quot;}}&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;some-convenience&#34;&gt;Some Convenience&lt;/h4&gt;
&lt;p&gt;Note that this contravariant interpretation pattern (wrapping in &lt;code&gt;Op&lt;/code&gt; and then unwrapping it again to run it) is so common that &lt;em&gt;functor-combinators&lt;/em&gt; has a helper function to make things a bit neater:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb55&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb55-1&#34;&gt;&lt;a href=&#34;#cb55-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;iapply  ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb55-2&#34;&gt;&lt;a href=&#34;#cb55-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;ifanout ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [b]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With these we could write&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb56&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb56-1&#34;&gt;&lt;a href=&#34;#cb56-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb56-2&#34;&gt;&lt;a href=&#34;#cb56-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fieldToValue  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; a  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And then:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb57&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb57-1&#34;&gt;&lt;a href=&#34;#cb57-1&#34;&gt;&lt;/a&gt;iapply&lt;span class=&#34;ot&#34;&gt; choiceToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Aeson.Value&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb57-2&#34;&gt;&lt;a href=&#34;#cb57-2&#34;&gt;&lt;/a&gt;ifanout&lt;span class=&#34;ot&#34;&gt; fieldToValue ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Aeson.Pair&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;backporting-documentation-1&#34;&gt;Backporting documentation&lt;/h3&gt;
&lt;p&gt;Because our new structure is pretty much the same as before (data types wrapped by functor combinators), and &lt;code&gt;Div&lt;/code&gt;/&lt;code&gt;Dec&lt;/code&gt; support &lt;code&gt;htoList&lt;/code&gt; just like &lt;code&gt;Ap&lt;/code&gt;/&lt;code&gt;ListF&lt;/code&gt; did before, the implementation of &lt;code&gt;schemaDoc&lt;/code&gt; is pretty much word-for-word identical as it was for our parser schema:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb58&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb58-1&#34;&gt;&lt;a href=&#34;#cb58-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/functor-structures/serialize.hs#L89-L116&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-2&#34;&gt;&lt;a href=&#34;#cb58-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-3&#34;&gt;&lt;a href=&#34;#cb58-3&#34;&gt;&lt;/a&gt;schemaDoc&lt;/span&gt;
&lt;span id=&#34;cb58-4&#34;&gt;&lt;a href=&#34;#cb58-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;       &lt;span class=&#34;co&#34;&gt;-- ^ name&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-5&#34;&gt;&lt;a href=&#34;#cb58-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Schema&lt;/span&gt; x     &lt;span class=&#34;co&#34;&gt;-- ^ schema&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-6&#34;&gt;&lt;a href=&#34;#cb58-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-7&#34;&gt;&lt;a href=&#34;#cb58-7&#34;&gt;&lt;/a&gt;schemaDoc title &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-8&#34;&gt;&lt;a href=&#34;#cb58-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;RecordType&lt;/span&gt; fs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb58-9&#34;&gt;&lt;a href=&#34;#cb58-9&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;{&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;}&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb58-10&#34;&gt;&lt;a href=&#34;#cb58-10&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-11&#34;&gt;&lt;a href=&#34;#cb58-11&#34;&gt;&lt;/a&gt;          htoList (\fld &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (fieldDoc fld)) fs&lt;/span&gt;
&lt;span id=&#34;cb58-12&#34;&gt;&lt;a href=&#34;#cb58-12&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb58-13&#34;&gt;&lt;a href=&#34;#cb58-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SumType&lt;/span&gt; cs    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.vsep [&lt;/span&gt;
&lt;span id=&#34;cb58-14&#34;&gt;&lt;a href=&#34;#cb58-14&#34;&gt;&lt;/a&gt;        PP.pretty (&lt;span class=&#34;st&#34;&gt;&amp;quot;(&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;)&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb58-15&#34;&gt;&lt;a href=&#34;#cb58-15&#34;&gt;&lt;/a&gt;      , &lt;span class=&#34;st&#34;&gt;&amp;quot;Choice of:&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-16&#34;&gt;&lt;a href=&#34;#cb58-16&#34;&gt;&lt;/a&gt;      , PP.indent &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; PP.vsep &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-17&#34;&gt;&lt;a href=&#34;#cb58-17&#34;&gt;&lt;/a&gt;          htoList choiceDoc cs&lt;/span&gt;
&lt;span id=&#34;cb58-18&#34;&gt;&lt;a href=&#34;#cb58-18&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb58-19&#34;&gt;&lt;a href=&#34;#cb58-19&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;SchemaLeaf&lt;/span&gt; p  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; PP.pretty (title &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;:&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb58-20&#34;&gt;&lt;a href=&#34;#cb58-20&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;PP.&amp;lt;+&amp;gt;&lt;/span&gt; primDoc p&lt;/span&gt;
&lt;span id=&#34;cb58-21&#34;&gt;&lt;a href=&#34;#cb58-21&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-22&#34;&gt;&lt;a href=&#34;#cb58-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    fieldDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-23&#34;&gt;&lt;a href=&#34;#cb58-23&#34;&gt;&lt;/a&gt;    fieldDoc (&lt;span class=&#34;dt&#34;&gt;Field&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb58-24&#34;&gt;&lt;a href=&#34;#cb58-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    choiceDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-25&#34;&gt;&lt;a href=&#34;#cb58-25&#34;&gt;&lt;/a&gt;    choiceDoc (&lt;span class=&#34;dt&#34;&gt;Choice&lt;/span&gt; name val) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; schemaDoc name val&lt;/span&gt;
&lt;span id=&#34;cb58-26&#34;&gt;&lt;a href=&#34;#cb58-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    primDoc ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Primitive&lt;/span&gt; x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PP.Doc&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb58-27&#34;&gt;&lt;a href=&#34;#cb58-27&#34;&gt;&lt;/a&gt;    primDoc &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-28&#34;&gt;&lt;a href=&#34;#cb58-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PString&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;string&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-29&#34;&gt;&lt;a href=&#34;#cb58-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PNumber&lt;/span&gt; _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;number&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-30&#34;&gt;&lt;a href=&#34;#cb58-30&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;PBool&lt;/span&gt;   _ &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;bool&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Neat!&lt;/p&gt;
&lt;h2 id=&#34;looking-forward&#34;&gt;Looking Forward&lt;/h2&gt;
&lt;p&gt;We first started with a simple structure to represent our schema. We then added &lt;em&gt;covariant&lt;/em&gt; capabilities to get us parser generation. Then we added &lt;em&gt;contravariant&lt;/em&gt; capabilities to get us serializers.&lt;/p&gt;
&lt;p&gt;The next step might be to add &lt;em&gt;both&lt;/em&gt; enhancements to the same structure! The benefits for this seem pretty significant: we can write our structure once (less code, less bugs), and we also write our serializer, parser, and documenting functions in a way that are automatically kept in-sync, and can never be incompatible with each other. Solving the documentation rot and mismatched parser/serializer problem in one stroke!&lt;/p&gt;
&lt;p&gt;For this, we’ll wait until the next post, where we explore not one, but two ways to combine our two capabilities into something known as an &lt;em&gt;invariant&lt;/em&gt; functor!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-2.html&#34;&gt;Proceed to the next post here!&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;And, if we want it, it has the more useful &lt;code&gt;Contravariant&lt;/code&gt; instance: &lt;code&gt;contramap :: (a -&amp;gt; b) -&amp;gt; Div Field b -&amp;gt; Div Field a&lt;/code&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/enhancing-functor-structures-step-by-step-1.html</guid><pubDate>Tue, 18 Aug 2020 16:45:04 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-08-18</date></item><item><title>Introducing the mutable library</title><link>https://blog.jle.im/entry/introducing-the-mutable-library.html</link><description>&lt;p&gt;&lt;strong&gt;mutable&lt;/strong&gt;: &lt;a href=&#34;https://mutable.jle.im/&#34;&gt;documentation&lt;/a&gt; / &lt;a href=&#34;http://hackage.haskell.org/package/mutable&#34;&gt;reference&lt;/a&gt; / &lt;a href=&#34;https://github.com/mstksg/mutable&#34;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Note:&lt;/em&gt; This post has been heavily revised to reflect &lt;em&gt;mutable-0.2.0.0&lt;/em&gt;, as of July 2020. For reference, &lt;a href=&#34;https://github.com/mstksg/inCode/blob/7c25dd3798955e8287d31774da6fe34015256b5a/entry/introducing-the-mutable-library.md&#34;&gt;the original post&lt;/a&gt; is available on github.)&lt;/p&gt;
&lt;p&gt;I’m excited to announce the release of the &lt;em&gt;&lt;a href=&#34;https://mutable.jle.im/&#34;&gt;mutable&lt;/a&gt;&lt;/em&gt; library!&lt;/p&gt;
&lt;p&gt;The library offers what I call &lt;em&gt;beautiful mutable values&lt;/em&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; — automatic, composable piecewise-mutable references for your data types. Sort of like an automatically generated &lt;code&gt;MVector&lt;/code&gt;, but for all your &lt;code&gt;ADT&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;My high-level goal was a composable and overhead-free solution for dealing with mutable values in Haskell in a type-safe and clean way. After all, why do imperative languages have to have all the fun? In Haskell, we can have the best of both worlds: efficient and clean mutable algorithms &lt;em&gt;and&lt;/em&gt; type safety.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://mutable.jle.im/&#34;&gt;official documentation and homepage is here&lt;/a&gt;, so it’s a good read if you want to be introduced to how to use the library and where it is most effective. But I’m going to use this blog post to talk about &lt;em&gt;why&lt;/em&gt; I wrote the library, some of the neat things you can do with it, and the techniques that went into writing it.&lt;/p&gt;
&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;The original motivation for this comes from my development of &lt;em&gt;&lt;a href=&#34;https://backprop.jle.im/&#34;&gt;backprop&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&#34;https://github.com/mstksg/backprop-learn&#34;&gt;backprop-learn&lt;/a&gt;&lt;/em&gt;, as I was trying to adapt my &lt;a href=&#34;https://blog.jle.im/entries/series/+functional-models.html&#34;&gt;Functional Models&lt;/a&gt; framework to efficient Haskell code.&lt;/p&gt;
&lt;p&gt;To properly train Artificial Neural Networks with Haskell, you need to do a lot of independent piecewise mutations to matrices and vectors. This becomes inefficient, quickly, because you have to do a lot of copying in the process for pure vectors and neural network weights. This problem also comes up for efficient simulations that require mutating many different components independently under a tight loop.&lt;/p&gt;
&lt;h3 id=&#34;piecewise-mutable&#34;&gt;Piecewise-Mutable&lt;/h3&gt;
&lt;p&gt;First of all, what do I mean by “piecewise-mutable”? Well, a simple example is the mutable vector type, where piecewise-mutable edits are able to save a lot of time and memory allocation.&lt;/p&gt;
&lt;p&gt;If we want to edit the first item in a vector multiple times, this is extremely inefficient with a pure vector:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;addFirst ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;addFirst xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;iterate&lt;/span&gt; incr xs &lt;span class=&#34;op&#34;&gt;!!&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;    incr v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; v &lt;span class=&#34;op&#34;&gt;V.//&lt;/span&gt; [(&lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;, (v &lt;span class=&#34;op&#34;&gt;V.!&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That’s because &lt;code&gt;addFirst&lt;/code&gt; will copy over the entire vector for every step — every single item, even if not modified, will be copied one million times. It is &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?O%28n%2Al%29&#34; alt=&#34;O(n*l)&#34; title=&#34;O(n*l)&#34; /&gt; in memory updates — it is very bad for long vectors or large matrices.&lt;/p&gt;
&lt;p&gt;However, this is extremely efficient with a mutable vector:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;addFirst ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;addFirst xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;    v &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; V.thaw xs&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;        MV.modify v &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;    V.freeze v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(this action is run in &lt;code&gt;ST&lt;/code&gt;, the monad for mutable actions that is provided by GHC)&lt;/p&gt;
&lt;p&gt;This is because all of the other items in the vector are kept the same and not copied-over over the course of one million updates. It is &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?O%28n%2Bl%29&#34; alt=&#34;O(n+l)&#34; title=&#34;O(n+l)&#34; /&gt; in memory updates. It is very good even for long vectors or large matrices.&lt;/p&gt;
&lt;p&gt;This situation is somewhat contrived, but it isolates a problem that many programs face. A more common situation might be that you have two functions that each modify different items in a vector in sequence, and you want to run them many times interleaved, or one after the other.&lt;/p&gt;
&lt;h3 id=&#34;composite-datatype&#34;&gt;Composite Datatype&lt;/h3&gt;
&lt;p&gt;That was an example of using piecewise mutability for vectors, but it’s not exactly scalable. That’s because it always requires having a separate type for the &lt;em&gt;pure&lt;/em&gt; type and the &lt;em&gt;value&lt;/em&gt; type. We’re lucky enough to have one for &lt;code&gt;Vector&lt;/code&gt;…but what about for our own custom types? That’s a lot of headache.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TV&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; tv1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;                 ,&lt;span class=&#34;ot&#34;&gt; tv2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;                 }&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To use this in a “piecewise-mutable” way, we would need a separate “mutable” version:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVecRef&lt;/span&gt; s &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TVR&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; tvr1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MVector&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;                       ,&lt;span class=&#34;ot&#34;&gt; tvr2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MVector&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;                       }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then we can do things like “mutate only the first item in the first vector” a million times, and be efficient with it.&lt;/p&gt;
&lt;p&gt;We’d have to write functions to “thaw” and “freeze”&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;thawTwoVec ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;TwoVecRef&lt;/span&gt; s)&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;thawTwoVec (&lt;span class=&#34;dt&#34;&gt;TV&lt;/span&gt; x y) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TVR&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; V.thaw x &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; V.thaw y&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;freezeTwoVec ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVecRef&lt;/span&gt; s &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;freezeTwoVec (&lt;span class=&#34;dt&#34;&gt;TVR&lt;/span&gt; u v) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TV&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; V.freeze u &lt;span class=&#34;op&#34;&gt;&amp;lt;*&amp;gt;&lt;/span&gt; V.freze v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It just doesn’t scale in a composable way. You’d have to create a second version of every data type.&lt;/p&gt;
&lt;h3 id=&#34;solution&#34;&gt;Solution&lt;/h3&gt;
&lt;p&gt;The library provides the &lt;code&gt;Mutable&lt;/code&gt; typeclass and the &lt;code&gt;GRef&lt;/code&gt; type, where &lt;code&gt;GRef s X&lt;/code&gt; is the automatically derived piecewise-mutable version of &lt;code&gt;X&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;GRef&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The type &lt;code&gt;GRef s TwoVec&lt;/code&gt; is &lt;em&gt;exactly&lt;/em&gt; the &lt;code&gt;TwoVecRef&lt;/code&gt; that we defined earlier: it is a tuple of two &lt;code&gt;MVector&lt;/code&gt;s. It can do this because &lt;code&gt;Vector&lt;/code&gt; itself has a &lt;code&gt;Mutable&lt;/code&gt; instance, where its mutable version is &lt;code&gt;MVector&lt;/code&gt;. &lt;code&gt;GRef s TwoVec&lt;/code&gt; is essentially the “MVector” of &lt;code&gt;TwoVec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This now gives us &lt;code&gt;thawRef :: TwoVec -&amp;gt; ST s (GRef s TwoVec)&lt;/code&gt; and &lt;code&gt;freezeRef :: GRef s TwoVec -&amp;gt; ST s TwoVec&lt;/code&gt;, for free, so we can write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;addFirst ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;addFirst xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;    v &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; thawRef xs&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;      withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv1 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;        MV.modify u &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;    freezeRef v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will in-place edit only the first item in the &lt;code&gt;tv1&lt;/code&gt; field one million times, without ever needing to copy over the contents &lt;code&gt;tv2&lt;/code&gt;. Basically, it gives you a version of &lt;code&gt;TwoVec&lt;/code&gt; that you can modify in-place piecewise. You can compose two functions that each work piecewise on &lt;code&gt;TwoVec&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;mut1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s ()&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;mut1 v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv1 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv2 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;mut2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s ()&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;mut2 v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv1 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;    withField &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;tv2 v &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \u &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-16&#34;&gt;&lt;a href=&#34;#cb8-16&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;6&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-17&#34;&gt;&lt;a href=&#34;#cb8-17&#34;&gt;&lt;/a&gt;      MV.modify u &lt;span class=&#34;dv&#34;&gt;7&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-18&#34;&gt;&lt;a href=&#34;#cb8-18&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-19&#34;&gt;&lt;a href=&#34;#cb8-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;doAMillion ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TwoVec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-20&#34;&gt;&lt;a href=&#34;#cb8-20&#34;&gt;&lt;/a&gt;doAMillion xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-21&#34;&gt;&lt;a href=&#34;#cb8-21&#34;&gt;&lt;/a&gt;    v &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; thawRef xs&lt;/span&gt;
&lt;span id=&#34;cb8-22&#34;&gt;&lt;a href=&#34;#cb8-22&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-23&#34;&gt;&lt;a href=&#34;#cb8-23&#34;&gt;&lt;/a&gt;      mut1 v&lt;/span&gt;
&lt;span id=&#34;cb8-24&#34;&gt;&lt;a href=&#34;#cb8-24&#34;&gt;&lt;/a&gt;      mut2 v&lt;/span&gt;
&lt;span id=&#34;cb8-25&#34;&gt;&lt;a href=&#34;#cb8-25&#34;&gt;&lt;/a&gt;    freezeRef v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The end result? You can now modify only a single component of your large composite data type (and even single items in vectors in them) without making nested copies every time.&lt;/p&gt;
&lt;h2 id=&#34;neat-consequences&#34;&gt;Neat Consequences&lt;/h2&gt;
&lt;h3 id=&#34;mutable-sum-types&#34;&gt;Mutable Sum Types&lt;/h3&gt;
&lt;p&gt;While developing the library, I accidentally also stumbled into a way of automatically deriving useful mutable sum types and data structures in Haskell. This was more or less a complete accident — I was writing the code to automatically generate &lt;code&gt;GRef&lt;/code&gt;, and needed to account for sum types somehow. The result was actually useful!&lt;/p&gt;
&lt;p&gt;For example, it is a publicly kept secret that Haskell’s list type — “linked lists”, are actually very different from the &lt;a href=&#34;https://en.wikipedia.org/wiki/Linked_list&#34;&gt;mutable linked lists&lt;/a&gt; encountered as a standard data structure in languages like Java and C++. As it turns out, using &lt;code&gt;GRef m [a]&lt;/code&gt; gives us exactly the mutable linked list type … for free!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nil&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Cons&lt;/span&gt; a (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;infixr&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;`Cons`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; m (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;GRef&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here we are re-implementing the &lt;code&gt;List&lt;/code&gt; data structure from scratch just to show that there is nothing arbitrary going on with the default list — it works for any appropriately defined ADT. We could even do binary trees!&lt;/p&gt;
&lt;p&gt;Right away we can write functions to flesh out the API for a mutable linked list. For example, a function to check if a linked list is empty:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Check if a mutable linked list is currently empty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;isEmpty&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb10-5&#34;&gt;&lt;a href=&#34;#cb10-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-6&#34;&gt;&lt;a href=&#34;#cb10-6&#34;&gt;&lt;/a&gt;isEmpty &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; hasBranch (constrMB &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;_Nil)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here is a function to “pop” a mutable linked list, giving us the first value and shifting the rest of the list up.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;popStack&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb11-5&#34;&gt;&lt;a href=&#34;#cb11-5&#34;&gt;&lt;/a&gt;popStack xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-6&#34;&gt;&lt;a href=&#34;#cb11-6&#34;&gt;&lt;/a&gt;    c &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; projectBranch (constrMB &lt;span class=&#34;op&#34;&gt;#&lt;/span&gt;_Cons) xs&lt;/span&gt;
&lt;span id=&#34;cb11-7&#34;&gt;&lt;a href=&#34;#cb11-7&#34;&gt;&lt;/a&gt;    forM c &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \(y, ys) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-8&#34;&gt;&lt;a href=&#34;#cb11-8&#34;&gt;&lt;/a&gt;      o &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; freezeRef y&lt;/span&gt;
&lt;span id=&#34;cb11-9&#34;&gt;&lt;a href=&#34;#cb11-9&#34;&gt;&lt;/a&gt;      moveRef xs ys&lt;/span&gt;
&lt;span id=&#34;cb11-10&#34;&gt;&lt;a href=&#34;#cb11-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; o&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a function to concatenate a second linked list to the end of a first one:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;concatLists&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s a&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-4&#34;&gt;&lt;a href=&#34;#cb12-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s (&lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb12-5&#34;&gt;&lt;a href=&#34;#cb12-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; s ()&lt;/span&gt;
&lt;span id=&#34;cb12-6&#34;&gt;&lt;a href=&#34;#cb12-6&#34;&gt;&lt;/a&gt;concatLists l1 l2 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-7&#34;&gt;&lt;a href=&#34;#cb12-7&#34;&gt;&lt;/a&gt;    c &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; projectBranch consBranch l1&lt;/span&gt;
&lt;span id=&#34;cb12-8&#34;&gt;&lt;a href=&#34;#cb12-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; c &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-9&#34;&gt;&lt;a href=&#34;#cb12-9&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;      &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; moveRef l1 l2&lt;/span&gt;
&lt;span id=&#34;cb12-10&#34;&gt;&lt;a href=&#34;#cb12-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; (_, xs) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; concatLists xs l2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;higher-kinded-data&#34;&gt;Higher-Kinded Data&lt;/h3&gt;
&lt;p&gt;I’m rather enamoured by the “&lt;a href=&#34;https://reasonablypolymorphic.com/blog/higher-kinded-data/&#34;&gt;higher-kinded data&lt;/a&gt;” pattern made popular by Sandy Maguire. It essentially eliminates the need for explicit getters and setters by making the data type &lt;em&gt;itself&lt;/em&gt; the thing that offers what you want, and you can get at it by just pattern matching.&lt;/p&gt;
&lt;p&gt;Because of this, if your data type is written in the “higher-kinded data” pattern, then &lt;code&gt;MyType f&lt;/code&gt; doubles as both the pure type &lt;em&gt;and&lt;/em&gt; the mutable type, just by choice of &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;MyTypeF Identity&lt;/code&gt; would be the pure version, and &lt;code&gt;MyTypeF (RefFor m)&lt;/code&gt; would be the mutable version.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; mtfInt    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HKD&lt;/span&gt; f &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; mtfDouble ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HKD&lt;/span&gt; f &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; mtfVec    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HKD&lt;/span&gt; f (&lt;span class=&#34;dt&#34;&gt;V.Vector&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb13-6&#34;&gt;&lt;a href=&#34;#cb13-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-7&#34;&gt;&lt;a href=&#34;#cb13-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-8&#34;&gt;&lt;a href=&#34;#cb13-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-9&#34;&gt;&lt;a href=&#34;#cb13-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-10&#34;&gt;&lt;a href=&#34;#cb13-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mutable&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-11&#34;&gt;&lt;a href=&#34;#cb13-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ref&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RefFor&lt;/span&gt; s)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can directly use it like a normal data type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;fl&#34;&gt;4.5&lt;/span&gt; (V.fromList [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;100&lt;/span&gt;])&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyType&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But now, &lt;code&gt;MyTypeF (RefFor s)&lt;/code&gt; literally has mutable references as its fields. You can pattern match to get &lt;code&gt;rI :: MutVar s Int&lt;/code&gt;, &lt;code&gt;rD :: MutVar s Double&lt;/code&gt;, and &lt;code&gt;rV :: MVector s Double&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; rI rD&lt;span class=&#34;ot&#34;&gt; rV ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RefFor&lt;/span&gt; s)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the accessors work as well:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;mtfVec&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MyTypeF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RefFor&lt;/span&gt; s)&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MVector&lt;/span&gt; s &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can use it like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;runST &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;    r&lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; rI rD rV) &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; thawRef &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MTF&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;fl&#34;&gt;19.3&lt;/span&gt; (V.fromList [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;])&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;    replicateM_ &lt;span class=&#34;dv&#34;&gt;1000&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-6&#34;&gt;&lt;a href=&#34;#cb17-6&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;co&#34;&gt;-- rI is just the &amp;#39;Int&amp;#39; ref&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-7&#34;&gt;&lt;a href=&#34;#cb17-7&#34;&gt;&lt;/a&gt;        modifyMutVar rI (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb17-8&#34;&gt;&lt;a href=&#34;#cb17-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-9&#34;&gt;&lt;a href=&#34;#cb17-9&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;co&#34;&gt;-- rV is the &amp;#39;MVector&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-10&#34;&gt;&lt;a href=&#34;#cb17-10&#34;&gt;&lt;/a&gt;        MV.modify rV (&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;) &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-11&#34;&gt;&lt;a href=&#34;#cb17-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-12&#34;&gt;&lt;a href=&#34;#cb17-12&#34;&gt;&lt;/a&gt;    freezeRef r&lt;/span&gt;
&lt;span id=&#34;cb17-13&#34;&gt;&lt;a href=&#34;#cb17-13&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-14&#34;&gt;&lt;a href=&#34;#cb17-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- =&amp;gt; MTF 1000 19.3 [1001.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The “mutable version” of a type literally &lt;em&gt;is&lt;/em&gt; the ADT, if you use the higher-kinded data pattern!&lt;/p&gt;
&lt;h3 id=&#34;a-polymorphic-picture&#34;&gt;A Polymorphic Picture&lt;/h3&gt;
&lt;p&gt;One important thing to note when looking at the actual library — the examples in this post show the provided actions in &lt;code&gt;ST&lt;/code&gt;, the mutable actions monad provided by GHC. However, the library provides these actions polymorphic for all &lt;code&gt;PrimMonad m&lt;/code&gt;, an abstraction provided by the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/primitive&#34;&gt;primitive&lt;/a&gt;&lt;/em&gt; library to generalize for all “mutable monads” (like &lt;code&gt;IO&lt;/code&gt; and monad transformers applied to &lt;code&gt;IO&lt;/code&gt; and &lt;code&gt;ST&lt;/code&gt;), as long as &lt;code&gt;PrimState m ~ s&lt;/code&gt;, so you can run them in whatever useful mutable monads you’d like.&lt;/p&gt;
&lt;h2 id=&#34;reflections-on-generic&#34;&gt;Reflections on Generic&lt;/h2&gt;
&lt;p&gt;This library is pretty much powered 95% by GHC Generics, as the name &lt;code&gt;GRef&lt;/code&gt; implies. GHC Generics is probably one of the single most powerful tools we have in Hasekll-the-language for writing typesafe abstractions and eliminating all the boilerplate.&lt;/p&gt;
&lt;p&gt;The structure of the &lt;code&gt;GRef&lt;/code&gt; data type is completely determined by using the &lt;em&gt;GHC.Generics&lt;/em&gt; &lt;code&gt;Rep&lt;/code&gt; of an algebraic data type with a &lt;code&gt;Generic&lt;/code&gt; instance. It breaks apart the products and sums and turns them into the mutable references you &lt;em&gt;would&lt;/em&gt; normally write by hand.&lt;/p&gt;
&lt;p&gt;Writing &lt;code&gt;GRef&lt;/code&gt; itself was actually very pleasant: it just involves matching up generic pieces with the references they represent. “What is the reference for a constant value? What is the reference for a product type? What is the reference for a sum type?” And, in the process of answering those questions, I ended up discovering something new (as shown in the section above about mutable linked lists).&lt;/p&gt;
&lt;p&gt;Generics also powers the &lt;em&gt;higher-kinded data&lt;/em&gt; based systems, which can add a lot of syntactic niceness to everything if you decide to use it.&lt;/p&gt;
&lt;p&gt;Still, I understand not everyone wants to restructure their data types in terms of higher-kinded data … there are a lot of practical issues to doing so, and it doesn’t really work well with nested data types. For that, I turned to &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/generic-lens&#34;&gt;generic-lens&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;generic-lens&lt;/em&gt; is what powers the OverloadedLabels-based field accessor methods that let you work with &lt;code&gt;GRef&lt;/code&gt;s in a seamless way, by being able to do &lt;code&gt;withField #blah&lt;/code&gt;, etc., instead of having to directly match on the &lt;code&gt;GRef&lt;/code&gt; value’s internal contents (which can be messy, admittedly). It also allows you to do &lt;code&gt;withPos @2&lt;/code&gt; to get the second item in your &lt;code&gt;GRef&lt;/code&gt;, and &lt;code&gt;withTuple&lt;/code&gt; to allow you to get the mutable fields in your data type as a tuple.&lt;/p&gt;
&lt;p&gt;I was originally going to implement the field accessors myself, looking to &lt;em&gt;generic-lens&lt;/em&gt; for inspiration. However, when I looked at the library’s internals, I realized there was a lot more going on than I had originally thought. But, looking at what was exported, I realized that the library was well-designed enough that I could actually directly use its generic implementations for &lt;em&gt;mutable&lt;/em&gt;! As a result, the field/position/tuple accessor code actually required no mucking around with generics at all — I could leverage &lt;em&gt;generic-lens&lt;/em&gt;, which was powerful enough to allow me to eliminate all of my generics code.&lt;/p&gt;
&lt;p&gt;I strongly recommend anyone looking to do things involving generic access to fields to look at &lt;em&gt;generic-lens&lt;/em&gt; to see if it can eliminate all your generics code as well!&lt;/p&gt;
&lt;p&gt;Unfortunately, I wasn’t able to re-use the code for the “constructor” access (as seen with &lt;code&gt;constrMB #_Cons&lt;/code&gt; earlier) — but I could use it as inspiration to write my own. The library offers a very clean and well-written pattern to doing things like this that I probably would have spent a long time trying to figure out, if I had to do it from scratch.&lt;/p&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;I learned a lot from GHC Generics writing this library — in a sense, the library is pretty much completely an application of GHC Generics, without much new concepts beyond that.&lt;/p&gt;
&lt;p&gt;My next step is to equip &lt;em&gt;backprop&lt;/em&gt; to use &lt;code&gt;Mutable&lt;/code&gt; instead of its &lt;code&gt;Backprop&lt;/code&gt; typeclass, so it can do in-place mutation of composite data types for much faster backpropagation.&lt;/p&gt;
&lt;p&gt;However, my newly gained experience with generics from writing this library can actually do a lot to improve the ergonomics of &lt;em&gt;backprop&lt;/em&gt; as well — in particular, with &lt;code&gt;BVar&lt;/code&gt;, which has always been very annoying to work with, even with the lens-based API offered. Working with a &lt;code&gt;BVar&lt;/code&gt; as if it were a normal value has always been annoying, especially with product types. There are a lot of ways GHC generics can help this, that I am now only learning about. Check back soon — hopefully I’ll have something to show by then.&lt;/p&gt;
&lt;p&gt;Until then, happy mutating! And please let me know if you find any interesting applications of the library :D&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Okay so I don’t actually think the library is beautiful, I just like the way that “beautiful mutable values” sounds when you say it out loud.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/introducing-the-mutable-library.html</guid><pubDate>Fri, 24 Jan 2020 02:16:52 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2020-01-24</date></item><item><title>Adjunctions in the wild: foldl</title><link>https://blog.jle.im/entry/foldl-adjunction.html</link><description>&lt;p&gt;I recently made a few connections that linked some different concepts in Haskell that I hadn’t realized before. They deal with one of my favorite “practical” libraries in Haskell, and also one of the more “profound” category theory-inspired abstractions in Haskell. In the process, it made the library a bit more useful to me, and also made the concept a bit more concrete and understandable to me.&lt;/p&gt;
&lt;p&gt;This post mainly goes through my thought process in finding this out — it’s very much a “how I think through this” sort of thing — in the end, the goal is to show how much this example made me further appreciate the conceptual idea of adjunctions and how they can pop up in interesting places in practical libraries. Unlike most of my other posts, it’s not about necessarily about how practically useful an abstraction is, but rather what insight it gives us to understanding its instances.&lt;/p&gt;
&lt;p&gt;The audience of this post is Haskellers with an understanding/appreciation of abstractions like &lt;code&gt;Applicative&lt;/code&gt;, but be aware that the final section is separately considered as a fun aside for those familiar with some of Haskell’s more esoteric types. The code samples used here (along with exercise solutions) are &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs&#34;&gt;available on github&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;foldl&#34;&gt;foldl&lt;/h2&gt;
&lt;p&gt;The first concept is the great &lt;em&gt;&lt;a href=&#34;http://hackage.haskell.org/package/foldl&#34;&gt;foldl&lt;/a&gt;&lt;/em&gt; library, which provides a nice “stream processor” type called &lt;code&gt;Fold&lt;/code&gt;, where &lt;code&gt;Fold r a&lt;/code&gt; is a stream processor that takes a stream of &lt;code&gt;r&lt;/code&gt;s and produces an &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Control.Foldl&lt;/span&gt;   (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt;(..))&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;qualified&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Control.Foldl&lt;/span&gt;   &lt;span class=&#34;kw&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;F&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;F.sum&lt;span class=&#34;ot&#34;&gt;  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Num&lt;/span&gt; a        &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a a&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;F.mean&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fractional&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a a&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;F.elem&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Eq&lt;/span&gt; a         &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-7&#34;&gt;&lt;a href=&#34;#cb1-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-8&#34;&gt;&lt;a href=&#34;#cb1-8&#34;&gt;&lt;/a&gt;F.fold F.sum  [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-9&#34;&gt;&lt;a href=&#34;#cb1-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; 10&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-10&#34;&gt;&lt;a href=&#34;#cb1-10&#34;&gt;&lt;/a&gt;F.fold F.mean [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-11&#34;&gt;&lt;a href=&#34;#cb1-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; 2.5&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-12&#34;&gt;&lt;a href=&#34;#cb1-12&#34;&gt;&lt;/a&gt;F.fold (F.elem &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;) [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-13&#34;&gt;&lt;a href=&#34;#cb1-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; True&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-14&#34;&gt;&lt;a href=&#34;#cb1-14&#34;&gt;&lt;/a&gt;F.fold (F.elem &lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt;) [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb1-15&#34;&gt;&lt;a href=&#34;#cb1-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; False&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most useful thing about the library is that it treats the folds as first-class objects, so you can create more complex folds by combining simpler folds (for example, with &lt;code&gt;-XApplicativeDo&lt;/code&gt;)&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L22-L29&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;variance ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fractional&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a a&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;variance &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;    x  &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; F.mean&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;    x2 &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; lmap (&lt;span class=&#34;op&#34;&gt;^&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;) F.mean     &lt;span class=&#34;co&#34;&gt;-- the mean of squared items&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-7&#34;&gt;&lt;a href=&#34;#cb2-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; (x2 &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;*&lt;/span&gt;x)&lt;/span&gt;
&lt;span id=&#34;cb2-8&#34;&gt;&lt;a href=&#34;#cb2-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-9&#34;&gt;&lt;a href=&#34;#cb2-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;varianceTooBig ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fractional&lt;/span&gt; a, &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; a &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-10&#34;&gt;&lt;a href=&#34;#cb2-10&#34;&gt;&lt;/a&gt;varianceTooBig &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; variance&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Most importantly, &lt;code&gt;Fold r&lt;/code&gt; is an instance of both &lt;code&gt;Functor&lt;/code&gt; and &lt;code&gt;Applicative&lt;/code&gt;, so you can map over and combine the results of different folds.&lt;/p&gt;
&lt;p&gt;To me, &lt;em&gt;foldl&lt;/em&gt; is one of the shining examples of how well Haskell works for data and stream processing, and a library I often show to people when they ask what the big deal is about Haskell abstractions like &lt;code&gt;Applicative&lt;/code&gt;, purity, and lists — this technique is often described as “&lt;a href=&#34;https://www.google.com/search?q=beautiful+folds&#34;&gt;beautiful folds&lt;/a&gt;”.&lt;/p&gt;
&lt;h2 id=&#34;adjunctions&#34;&gt;Adjunctions&lt;/h2&gt;
&lt;p&gt;The second concept is the idea of &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Adjoint_functors&#34;&gt;adjoint functors&lt;/a&gt;&lt;/em&gt; (see also &lt;a href=&#34;https://bartoszmilewski.com/2016/04/18/adjunctions/&#34;&gt;Bartosz Milewski’s introduction&lt;/a&gt; and &lt;a href=&#34;https://ncatlab.org/nlab/show/adjoint+functor&#34;&gt;nlab&lt;/a&gt;’s description, as well as &lt;a href=&#34;https://www.math3ma.com/blog/what-is-an-adjunction-part-1&#34;&gt;Tai-Danae Bradley’s motivation&lt;/a&gt;), represented in Haskell by the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html&#34;&gt;adjunctions library and typeclass&lt;/a&gt;&lt;/em&gt; (&lt;a href=&#34;https://chrispenner.ca/posts/adjunction-battleship&#34;&gt;Chris Penner&lt;/a&gt; has a nice article with an example of using the typeclass’s utility functions to simplify programs).&lt;/p&gt;
&lt;p&gt;For some functors, we can think of a “conceptual inverse”. We can ask “I have a nice functor &lt;code&gt;F&lt;/code&gt;. Conceptually, what functor represents the opposite idea/spirit of &lt;code&gt;F&lt;/code&gt;?” The concept of an adjunction is one way to formalize what this means.&lt;/p&gt;
&lt;p&gt;In Haskell&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;, with the &lt;code&gt;Adjunctions&lt;/code&gt; typeclass (specifically, &lt;code&gt;Functor&lt;/code&gt; functors), this manifests as this: if &lt;code&gt;F -| U&lt;/code&gt; (&lt;code&gt;F&lt;/code&gt; is left adjoint to &lt;code&gt;U&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; is right adjoint to &lt;code&gt;F&lt;/code&gt;), then all the ways of going “out of” &lt;code&gt;F a&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; are the same as all the ways of going “into” &lt;code&gt;U b&lt;/code&gt; from &lt;code&gt;a&lt;/code&gt;. Ways of going out can be encoded as ways of going in, and vice versa. They represent opposite ideas.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | The class saying you can always convert between:&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- * `f a -&amp;gt; b` (the ways to go out of `f`)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- * `a -&amp;gt; u b` (the ways to go into `g`)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;    leftAdjunct&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;out of&amp;quot; `f`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;into&amp;quot; `u`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;    rightAdjunct&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;into&amp;quot; u&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)       &lt;span class=&#34;co&#34;&gt;-- ^ the ways of going &amp;quot;out of&amp;quot; f&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;p&gt;For example, one of the more famous adjunctions in Haskell is the adjunction between &lt;code&gt;(,) r&lt;/code&gt; and &lt;code&gt;(-&amp;gt;) r&lt;/code&gt;. “Tupling” represents some sort of “opposite” idea to “parameterizing”.&lt;/p&gt;
&lt;p&gt;The ways to get “out” of a tuple is &lt;code&gt;(r, a) -&amp;gt; b&lt;/code&gt;. The ways to go “into” a function is &lt;code&gt;a -&amp;gt; (r -&amp;gt; b)&lt;/code&gt;. Haskellers will recognize that these two types are the “same” (isomorphic) — any &lt;code&gt;(a, b) -&amp;gt; c&lt;/code&gt; can be re-written as &lt;code&gt;a -&amp;gt; (b -&amp;gt; c)&lt;/code&gt; (currying), and vice versa (uncurrying).&lt;/p&gt;
&lt;p&gt;Another common pair is with same-typed either and tuple:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L31-L34&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SameEither&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SE&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; a a)&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SameTuple&lt;/span&gt;  a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ST&lt;/span&gt; (a, a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;People familiar with &lt;code&gt;Either&lt;/code&gt; (sums) and &lt;code&gt;(,)&lt;/code&gt; (products) in Haskell will recognize them as “opposite” ideas — one is “or”, and the other is “and” (depending on if you are talking about using them or making them).&lt;/p&gt;
&lt;p&gt;We can formalize this idea of opposites using adjunctions: Going “out of” &lt;code&gt;Either a a&lt;/code&gt; into &lt;code&gt;b&lt;/code&gt; can be encoded as going “into” &lt;code&gt;(b, b)&lt;/code&gt; from &lt;code&gt;a&lt;/code&gt;, and vice versa: &lt;code&gt;Either a a -&amp;gt; b&lt;/code&gt; can be encoded as &lt;code&gt;a -&amp;gt; (b, b)&lt;/code&gt;, which can be encoded as &lt;code&gt;Either a a -&amp;gt; b&lt;/code&gt; — the two types are isomorphic. This is because to go out of &lt;code&gt;Either a a&lt;/code&gt;, you have to handle the situation of getting a &lt;code&gt;Left&lt;/code&gt; and the situation of getting a &lt;code&gt;Right&lt;/code&gt;. To go into &lt;code&gt;(b, b)&lt;/code&gt;, you have to able to ask what goes in the first field, and what goes in the right field. Both &lt;code&gt;Either a a -&amp;gt; b&lt;/code&gt; and &lt;code&gt;a -&amp;gt; (b, b)&lt;/code&gt; have to answer the same questions. (A fun exercise would be to write the functions to convert between the two — &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L55-L56&#34;&gt;one solution is here&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&#34;big-picture&#34;&gt;Big Picture&lt;/h3&gt;
&lt;p&gt;Aside from being an interesting curiosity (formalizing the idea of “opposite idea” is pretty neat), hunting for adjunctions can be useful in figuring out “why” a functor is useful, what you can do with it, and also what functors are intimately connected with it. There’s also the helper functions in the &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html&#34;&gt;Data.Functor.Adjunction&lt;/a&gt; module that implement some nice helper functions on your types if an adjoint happens to exist — you can do some neat things by going “back and forth” between adjoint functors.&lt;/p&gt;
&lt;h2 id=&#34;hunting-for-adjunctions&#34;&gt;Hunting for Adjunctions&lt;/h2&gt;
&lt;p&gt;So, from the build-up, you’ve probably guessed what we’re going to do next: find a functor that is adjoint to &lt;code&gt;Fold r&lt;/code&gt;. What’s the “conceptual opposite” of &lt;code&gt;Fold r&lt;/code&gt;? Let’s go adjunction hunting!&lt;/p&gt;
&lt;p&gt;Important note — the rest of this section is not a set of hard rules, but rather an intuitive process of heuristics to search for candidates that would be adjoint to a given functor of interest. There are no hard and fast rules, and the adjoint might not always exist (it usually doesn’t). But when it does, it can be a pleasant surprise.&lt;/p&gt;
&lt;h3 id=&#34;patterns-to-look-for&#34;&gt;Patterns to look for&lt;/h3&gt;
&lt;p&gt;Now, on to the hunting. Let’s say we have functor &lt;code&gt;Q&lt;/code&gt; and we want to identify any adjoints. We want to spot functions that use both &lt;code&gt;Q a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; with some other value, in &lt;a href=&#34;https://www.foldl.io/posts/pos-neg-functions/&#34;&gt;opposite positions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;(Of course, this is only the case if we are using a functor that comes from a library. If we are writing our own functor from scratch, and want to hunt for adjunctions there, we have to instead &lt;em&gt;think&lt;/em&gt; of ways to use &lt;code&gt;Q a&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;One common pattern is functions for “converting between” the going-in and going-out functions. In &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Adjunction.html&#34;&gt;Data.Functor.Adjunctions&lt;/a&gt;, these are called &lt;code&gt;leftAdjunct&lt;/code&gt; and &lt;code&gt;rightAdjunct&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b)&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This pair is significant because it is the adjunctions “in practice”: Sure, an &lt;code&gt;(r, a) -&amp;gt; b&lt;/code&gt; is useful, but “using” the adjunction means that you can convert &lt;em&gt;between&lt;/em&gt; &lt;code&gt;(r, a) -&amp;gt; b&lt;/code&gt; and &lt;code&gt;a -&amp;gt; r -&amp;gt; b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Another common pattern that you can spot are “indexing” and “tabulating” functions, in the case that you have a right-adjoint:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; u b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (f () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; u b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;indexAdjunction&lt;/code&gt; means: if it’s possible to “extract” from &lt;code&gt;u b&lt;/code&gt; to &lt;code&gt;b&lt;/code&gt; using only an &lt;code&gt;f ()&lt;/code&gt; as extra information, then &lt;code&gt;u&lt;/code&gt; might be right-adjoint to &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tabulateAdjunction&lt;/code&gt; means: if it’s possible to “generate” a &lt;code&gt;u b&lt;/code&gt; based on a function that “builds” a &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;f ()&lt;/code&gt;, then &lt;code&gt;u&lt;/code&gt; might right-adjoint to &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This pair is equivalent in power — you can implement &lt;code&gt;rightAdjunct&lt;/code&gt; in terms of &lt;code&gt;indexAdjunction&lt;/code&gt; and &lt;code&gt;leftAdjunct&lt;/code&gt; in terms of &lt;code&gt;tabulateAdjunction&lt;/code&gt; and vice versa. This comes from the fact that all Adjunctions in Haskell &lt;code&gt;Functor&lt;/code&gt;s arise from some idea of “indexability”. We’ll go into more detail later, but this is the general intuition.&lt;/p&gt;
&lt;h3 id=&#34;adjoints-to-fold&#34;&gt;Adjoints to &lt;code&gt;Fold&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Now, let’s look out for examples of these functions for &lt;code&gt;Fold&lt;/code&gt;! In the case of &lt;code&gt;Fold&lt;/code&gt;, there is actually only one function I can find that directly takes a &lt;code&gt;Fold r a&lt;/code&gt; and returns an &lt;code&gt;a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fold ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(the type has been simplified and re-labeled, for illustration’s sake)&lt;/p&gt;
&lt;p&gt;You “give” a &lt;code&gt;Fold r b&lt;/code&gt; and “get” an &lt;code&gt;b&lt;/code&gt; (and so they have opposite polarities/positions). This sort of function would make &lt;code&gt;Fold r&lt;/code&gt; a &lt;em&gt;right adjoint&lt;/em&gt;, since the naked type &lt;code&gt;b&lt;/code&gt; (the final parameter of &lt;code&gt;Fold r b&lt;/code&gt;) is the final result, not the input.&lt;/p&gt;
&lt;p&gt;Of our common patterns, this one looks a looooot like &lt;code&gt;indexAdjunction&lt;/code&gt;.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fold            ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r]  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;Fold r b&lt;/code&gt; is right-adjoint to some functor &lt;code&gt;f&lt;/code&gt; where &lt;code&gt;f () = [r]&lt;/code&gt;. A good first guess (just a hunch?) would be to just have &lt;code&gt;f a = ([r], a)&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L73-L74&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; [r] a&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Eq&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;EnvList r&lt;/code&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; adds a &lt;em&gt;list&lt;/em&gt; of &lt;code&gt;r&lt;/code&gt;s to a type. It is now also our suspect for a potential left-adjoint to &lt;code&gt;Fold r&lt;/code&gt;: a “conceptual opposite”.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L76-L77&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexFold ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;indexFold fld (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs _) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold fld rs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To seal the deal, let’s find its pair, &lt;code&gt;tabulateAdjunction&lt;/code&gt;. That means we are looking for:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateFold ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or, to simplify the type by expanding the definition of &lt;code&gt;EnvList r ()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateFold ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This tells us that, given any list processor &lt;code&gt;[r] -&amp;gt; b&lt;/code&gt;, we can write a fold &lt;code&gt;Fold r b&lt;/code&gt; representing that list processor. Scanning things more, we can see that this actually looks a lot like &lt;code&gt;foldMap&lt;/code&gt; from the library:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;qualified&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Control.Foldl&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;F&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;F.foldMap&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; w&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; w)&lt;/span&gt;
&lt;span id=&#34;cb13-6&#34;&gt;&lt;a href=&#34;#cb13-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (w &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb13-7&#34;&gt;&lt;a href=&#34;#cb13-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb13-8&#34;&gt;&lt;a href=&#34;#cb13-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-9&#34;&gt;&lt;a href=&#34;#cb13-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-10&#34;&gt;&lt;a href=&#34;#cb13-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb13-11&#34;&gt;&lt;a href=&#34;#cb13-11&#34;&gt;&lt;/a&gt;F.foldMap (\r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r])&lt;/span&gt;
&lt;span id=&#34;cb13-12&#34;&gt;&lt;a href=&#34;#cb13-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb13-13&#34;&gt;&lt;a href=&#34;#cb13-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L79-L80&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateFold ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;tabulateFold f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) (\rs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs ()))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The fact the have &lt;em&gt;both&lt;/em&gt; of these gives us a pretty strong footing to claim that &lt;code&gt;EnvList r&lt;/code&gt; is the left-adjoint of &lt;code&gt;Fold r&lt;/code&gt;. Proof by hunch, for now.&lt;/p&gt;
&lt;p&gt;Note that if we had missed &lt;code&gt;fold&lt;/code&gt; during our adjunction hunt, we might have also lucked out by noticing &lt;code&gt;F.foldMap (:[])&lt;/code&gt; fitting the criteria for a candidate for &lt;code&gt;tabulateAdjunction&lt;/code&gt;, instead.&lt;/p&gt;
&lt;h2 id=&#34;opposite-concepts&#34;&gt;Opposite Concepts&lt;/h2&gt;
&lt;p&gt;We’ve identified a likely candidate for a left-adjoint to &lt;code&gt;Fold r&lt;/code&gt;! But … does any of this make any sense? Does this make sense as a left-adjoint, conceptually … and did we gain anything?&lt;/p&gt;
&lt;p&gt;Let’s think about this from the beginning: What is the conceptual opposite of “something that folds a list”?&lt;/p&gt;
&lt;p&gt;Well, what other thing is more naturally an opposite than “a list to be folded”!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnvList r&lt;/code&gt;: A list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fold r&lt;/code&gt;: Consumes a list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Or, in terms of the result of the functor application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;EnvList r a&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;… tupled with a list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fold r a&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;An &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;… parameterized by consumption of a list of &lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It seems to “flip” the idea of “list vs. list consumer”, and &lt;em&gt;also&lt;/em&gt; the idea of “tupled vs. parameterizing” (which was our first example of an adjunction earlier, as well).&lt;/p&gt;
&lt;p&gt;In addition, lists seem to be at the heart of how to create and consume a &lt;code&gt;Fold r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fold&lt;/code&gt; can be thought of as the fundamental way to &lt;em&gt;consuming&lt;/em&gt; a &lt;code&gt;Fold r&lt;/code&gt;. This makes the adjunction with &lt;code&gt;EnvList r&lt;/code&gt; make sense: what good is the &lt;em&gt;ability&lt;/em&gt; to fold … if there is nothing &lt;em&gt;to fold&lt;/em&gt;? &lt;code&gt;EnvList r&lt;/code&gt; (a list of &lt;code&gt;[r]&lt;/code&gt;) is intimately related to &lt;code&gt;Fold r&lt;/code&gt;: they are the yin and yang, peanut butter and jelly, night and day. Their fates are intertwined from their very inception. You cannot have one without the other.&lt;/p&gt;
&lt;p&gt;In addition, &lt;code&gt;F.foldMap&lt;/code&gt; is arguably a fundamental (although maybe inefficient) way to &lt;em&gt;specify&lt;/em&gt; a &lt;code&gt;Fold r&lt;/code&gt;. A &lt;code&gt;Fold r&lt;/code&gt; is, fundamentally, a list processor — which is what &lt;code&gt;EnvList r a -&amp;gt; b&lt;/code&gt; literally is (an &lt;code&gt;[r] -&amp;gt; b&lt;/code&gt;). &lt;code&gt;Fold r&lt;/code&gt; and &lt;code&gt;EnvList r&lt;/code&gt; — &lt;a href=&#34;https://starwars.fandom.com/wiki/Dyad_in_the_Force&#34;&gt;dyads in the force&lt;/a&gt;. (Or, well…literally &lt;em&gt;monads&lt;/em&gt;, since all adjunctions give rise to monads, as we will see later.)&lt;/p&gt;
&lt;p&gt;The fact that &lt;code&gt;EnvList r&lt;/code&gt; and &lt;code&gt;Fold r&lt;/code&gt; form an adjunction together formalizes the fact that they are conceptually “opposite” concepts, and also that they are bound together by destiny in a close and fundamental way.&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;&lt;strong&gt;A Note on Representable&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Note that in this case, a lot of what we are concluding simply stems from the fact that we can “index” a &lt;code&gt;Fold r a&lt;/code&gt; using an &lt;code&gt;[r]&lt;/code&gt;. This actually is more fundamentally associated with the concept of a &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Rep.html&#34;&gt;Representable Functor&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L87-L90&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Representable&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Rep&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; [r]&lt;/span&gt;
&lt;span id=&#34;cb15-5&#34;&gt;&lt;a href=&#34;#cb15-5&#34;&gt;&lt;/a&gt;    tabulate &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[])&lt;/span&gt;
&lt;span id=&#34;cb15-6&#34;&gt;&lt;a href=&#34;#cb15-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;index&lt;/span&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As it turns out, in Haskell, a functor being representable is &lt;em&gt;equivalent&lt;/em&gt; to it having a left adjoint. So thinking of &lt;code&gt;Fold r&lt;/code&gt; as a representable functor and thinking of it as a right adjoint are equivalent ideas. This article chooses to analyze it from the adjunctions perspective because we get to imagine the adjoint &lt;code&gt;Functor&lt;/code&gt;, which can sometimes reveal some extra insight over just looking at some index &lt;em&gt;value&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;the-helper-functions&#34;&gt;The Helper Functions&lt;/h2&gt;
&lt;p&gt;Let’s take a look at some of the useful helper functions that an instance of &lt;code&gt;Adjunction&lt;/code&gt; gives us for &lt;code&gt;Fold r&lt;/code&gt;, to see how their existence can better help us understand &lt;code&gt;Fold&lt;/code&gt;. For all of these, I’m going to write them first as &lt;code&gt;EnvList r a&lt;/code&gt;, and then also as &lt;code&gt;([r], a)&lt;/code&gt;, to help make things clearer.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;unit ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a)&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;unit ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r ([r], a)&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;counit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;counit ::&lt;/span&gt; [r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-7&#34;&gt;&lt;a href=&#34;#cb16-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b)&lt;/span&gt;
&lt;span id=&#34;cb16-8&#34;&gt;&lt;a href=&#34;#cb16-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b   ) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b)&lt;/span&gt;
&lt;span id=&#34;cb16-9&#34;&gt;&lt;a href=&#34;#cb16-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-10&#34;&gt;&lt;a href=&#34;#cb16-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)&lt;/span&gt;
&lt;span id=&#34;cb16-11&#34;&gt;&lt;a href=&#34;#cb16-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b   )&lt;/span&gt;
&lt;span id=&#34;cb16-12&#34;&gt;&lt;a href=&#34;#cb16-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-13&#34;&gt;&lt;a href=&#34;#cb16-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateAdjunction ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r () &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb16-14&#34;&gt;&lt;a href=&#34;#cb16-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;tabulateAdjunction ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)          &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;
&lt;span id=&#34;cb16-15&#34;&gt;&lt;a href=&#34;#cb16-15&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-16&#34;&gt;&lt;a href=&#34;#cb16-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb16-17&#34;&gt;&lt;a href=&#34;#cb16-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;indexAdjunction ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r]         &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb16-18&#34;&gt;&lt;a href=&#34;#cb16-18&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-19&#34;&gt;&lt;a href=&#34;#cb16-19&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;zipR ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r (a, b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;unit :: a -&amp;gt; Fold r ([r], a)&lt;/code&gt;, when we specialize &lt;code&gt;a ~ ()&lt;/code&gt;, becomes:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;unit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r [r]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;unit&lt;/code&gt; for &lt;code&gt;Fold r&lt;/code&gt; folds a list &lt;code&gt;[r]&lt;/code&gt; into “itself”, while also tagging on a value&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;F.fold (unit &lt;span class=&#34;dt&#34;&gt;True&lt;/span&gt;) [&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;pp&#34;&gt;#   =&amp;gt; EnvList [1,2,3] True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;counit :: [r] -&amp;gt; Fold r a -&amp;gt; a&lt;/code&gt; is essentially just &lt;code&gt;F.fold&lt;/code&gt; when we expand it. Neat!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;leftAdjunct :: ([r] -&amp;gt; a -&amp;gt; b) -&amp;gt; (a -&amp;gt; Fold r b)&lt;/code&gt; … if we write it as &lt;code&gt;leftAdjunct :: a -&amp;gt; (a -&amp;gt; [r] -&amp;gt; b) -&amp;gt; Fold r b&lt;/code&gt;, and feed the &lt;code&gt;a&lt;/code&gt; into the first function, we get:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;leftAdjunct&amp;#39; ::&lt;/span&gt; ([r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is just &lt;code&gt;tabulateAdjunction&lt;/code&gt;, or &lt;code&gt;F.foldMap (:[])&lt;/code&gt;! It encodes our list processor &lt;code&gt;[r] -&amp;gt; b&lt;/code&gt; into a &lt;code&gt;Fold r b.&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;rightAdjunct :: (a -&amp;gt; Fold r b) -&amp;gt; ([r] -&amp;gt; a -&amp;gt; b)&lt;/code&gt; – if we again rewrite as &lt;code&gt;rightAdjunct :: a -&amp;gt; (a -&amp;gt; Fold r b) -&amp;gt; [r] -&amp;gt; b&lt;/code&gt;, and again feed the &lt;code&gt;a&lt;/code&gt; into the first function, becomes:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;rightAdjunct&amp;#39; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [r] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which happens to just be &lt;code&gt;fold&lt;/code&gt;, or &lt;code&gt;counit&lt;/code&gt;!&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tabulateAdjunction&lt;/code&gt; and &lt;code&gt;indexAdjunction&lt;/code&gt; we went over earlier, seeing them as &lt;code&gt;F.foldMap (:[])&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;zipR :: Fold r a -&amp;gt; Fold r b -&amp;gt; Fold r (a, b)&lt;/code&gt; takes two &lt;code&gt;Fold r&lt;/code&gt;s and combines them into a single fold. This is exactly the “combining fold” behavior that makes &lt;code&gt;Fold&lt;/code&gt;s so useful! The implementation of &lt;code&gt;zipR&lt;/code&gt; is less efficient than the implementation of &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;/&lt;code&gt;liftA2&lt;/code&gt; for &lt;code&gt;Fold r&lt;/code&gt;, but knowing that &lt;code&gt;zipR&lt;/code&gt; exists means that we know &lt;code&gt;Fold r&lt;/code&gt;s can be combined.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Seeing how these functions all fit together, we can write a full instance of &lt;code&gt;Adjunction&lt;/code&gt;. We can choose to provide &lt;code&gt;unit&lt;/code&gt; and &lt;code&gt;counit&lt;/code&gt;, or &lt;code&gt;leftAdjunct&lt;/code&gt; and &lt;code&gt;rightAdjunct&lt;/code&gt;&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;; the &lt;code&gt;unit&lt;/code&gt;/&lt;code&gt;counit&lt;/code&gt; definitions are the easiest to conceptualize, for me, but the other pair isn’t much tricker to write.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L92-L97&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r) (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;    unit x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) (&lt;span class=&#34;ot&#34;&gt;`EnvList`&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb21-5&#34;&gt;&lt;a href=&#34;#cb21-5&#34;&gt;&lt;/a&gt;    counit (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs fld) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold fld rs&lt;/span&gt;
&lt;span id=&#34;cb21-6&#34;&gt;&lt;a href=&#34;#cb21-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-7&#34;&gt;&lt;a href=&#34;#cb21-7&#34;&gt;&lt;/a&gt;    leftAdjunct f x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.foldMap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) (\rs &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs x))&lt;/span&gt;
&lt;span id=&#34;cb21-8&#34;&gt;&lt;a href=&#34;#cb21-8&#34;&gt;&lt;/a&gt;    rightAdjunct f (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; rs x) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; F.fold (f x) rs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;induced-monad-and-comonad&#34;&gt;Induced Monad and Comonad&lt;/h3&gt;
&lt;p&gt;Another interesting thing we might want to look at is the monad and comonad that our adjunction defines. &lt;a href=&#34;https://bartoszmilewski.com/2016/12/27/monads-categorically/&#34;&gt;All adjunctions&lt;/a&gt; &lt;a href=&#34;http://www.stephendiehl.com/posts/adjunctions.html&#34;&gt;define a monad&lt;/a&gt;, so what does our new knowledge of the &lt;code&gt;Fold r&lt;/code&gt; adjunction give us?&lt;/p&gt;
&lt;h4 id=&#34;induced-monad&#34;&gt;Induced Monad&lt;/h4&gt;
&lt;p&gt;If we have &lt;code&gt;F -| U&lt;/code&gt;, then &lt;code&gt;U . F&lt;/code&gt; is a monad. In this case, we have &lt;code&gt;FoldEnv&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L99-L100&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FE&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getFE ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r a) }&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r ([r], a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As it turns out, this is essentially equivalent to the famous &lt;a href=&#34;https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-State-Lazy.html&#34;&gt;State Monad&lt;/a&gt;! More specifically, it’s the &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Control-Monad-Representable-State.html&#34;&gt;&lt;em&gt;Representable&lt;/em&gt; State Monad&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; [r]&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or, more literally, from Control.Monad.Representable.State&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FoldEnv&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the induced monad from the adjunction we just found is essentially the same as the &lt;code&gt;State&lt;/code&gt; monad over a list — except with some potentially different performance characteristics.&lt;/p&gt;
&lt;p&gt;In the end, finding this adjunction gives us a neat way to represent stateful computations on lists, which is arguably an extension of what &lt;code&gt;Fold&lt;/code&gt; was really meant for in the first place.&lt;/p&gt;
&lt;h4 id=&#34;induced-comonad&#34;&gt;Induced Comonad&lt;/h4&gt;
&lt;p&gt;If we have &lt;code&gt;F -| U&lt;/code&gt;, then &lt;code&gt;F . U&lt;/code&gt; is a comonad. In this case, we have &lt;code&gt;EnvFold&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl.hs#L111-L112&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-3&#34;&gt;&lt;a href=&#34;#cb24-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getEF ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvList&lt;/span&gt; r (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a) }&lt;/span&gt;
&lt;span id=&#34;cb24-4&#34;&gt;&lt;a href=&#34;#cb24-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-5&#34;&gt;&lt;a href=&#34;#cb24-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-6&#34;&gt;&lt;a href=&#34;#cb24-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-7&#34;&gt;&lt;a href=&#34;#cb24-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; ([r], &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This one is exactly the &lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Control-Comonad-Representable-Store.html&#34;&gt;Representable Store comonad&lt;/a&gt;. It’s essentially the normal &lt;a href=&#34;https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Store.html&#34;&gt;&lt;code&gt;Store&lt;/code&gt; comonad&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Store&lt;/span&gt; [r]&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-3&#34;&gt;&lt;a href=&#34;#cb25-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or, more literally, from Control.Comonad.Representable.Store&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-4&#34;&gt;&lt;a href=&#34;#cb25-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvFold&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Store&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This comonad “stores” an &lt;code&gt;[r]&lt;/code&gt; as well as a way to produce an &lt;code&gt;a&lt;/code&gt; from an &lt;code&gt;[r]&lt;/code&gt;. All of the utility of this induced comonad basically is the same as the utility of &lt;code&gt;Store&lt;/code&gt;, except with potentially different performance profiles.&lt;/p&gt;
&lt;p&gt;In the end, finding this adjunction gives us a neat way to define a comonadic contextual projection on lists, which I would say is also an extension of the original purpose of &lt;code&gt;Fold&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In the end, in a “practical” sense, we got some nice helper functions, as well as a new way to extend the conceptual idea of &lt;code&gt;Fold&lt;/code&gt; using the induced monad and comonad.&lt;/p&gt;
&lt;p&gt;Admittedly, the selection of helper functions that &lt;code&gt;Adjunction&lt;/code&gt; gives us pales in comparison to abstractions like &lt;code&gt;Monoid&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt;, &lt;code&gt;Monad&lt;/code&gt;, etc., which makes &lt;code&gt;Adjunction&lt;/code&gt; (in my opinion) nowhere as practical when compared to them. A lot of these helper functions (like the induced state monad and store comonad) actually also just exist if we only talk about &lt;code&gt;Representable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, to me (and, as how I’ve seen other people use it), &lt;code&gt;Adjunction&lt;/code&gt; is most useful as a conceptual tool in Haskell. The idea of “opposites” or “duals” show up a lot in Haskell, starting from the most basic level – sums and products, products and functions. From day 1, Haskellers are introduced to natural pairs and opposites in concepts. The idea of opposites and how they interact with each other is always on the mind of a Haskeller, and close to their heart.&lt;/p&gt;
&lt;p&gt;So, what makes &lt;code&gt;Adjunction&lt;/code&gt; so useful to me is that it actually is able to formalize what we mean by “opposite concepts”. The process of identifying a functor’s “opposite concept” (if it exists) will only help is better understand the functor we’re thinking about, in terms of how it works and how it is used.&lt;/p&gt;
&lt;p&gt;Hopefully this blog post helps you appreciate both &lt;code&gt;Fold&lt;/code&gt; in a new way, and also the fundamental “idea” of adjunctions in Haskell.&lt;/p&gt;
&lt;h2 id=&#34;the-algebraic-way&#34;&gt;The Algebraic Way&lt;/h2&gt;
&lt;p&gt;This article is done! Our first guess for an adjunction seems to be morally correct. But as an aside … let’s see if we can take this idea further.&lt;/p&gt;
&lt;p&gt;In this section we’re going to get a bit mathy and look at the definition of &lt;code&gt;Fold&lt;/code&gt;, to see if we can &lt;em&gt;algebraically&lt;/em&gt; find an adjunction of &lt;code&gt;Fold&lt;/code&gt;, instead of just trying to hunt for API functions like before. In practice you don’t often have to make algebraic deductions like this, but it’s at least nice to know that something like this possible from a purely algebraic and logical sense. You never &lt;em&gt;need&lt;/em&gt; all this fancy math to be able to write Haskell … but many feel like it can make things a lot more fun! :)&lt;/p&gt;
&lt;p&gt;Be warned that this method &lt;em&gt;does&lt;/em&gt; require some familiarity (or at least awareness) of certain types that appear often in the more … esoteric corners of Haskelldom :)&lt;/p&gt;
&lt;p&gt;The game plan here is to start with the definition of &lt;code&gt;Fold&lt;/code&gt;, and then rearrange it using algebraic substitutions until it matches something that already has an &lt;code&gt;Adjunction&lt;/code&gt; instance in the &lt;em&gt;adjunctions&lt;/em&gt; library.&lt;/p&gt;
&lt;p&gt;First, the actual definition of &lt;code&gt;Fold&lt;/code&gt; in the &lt;em&gt;foldl&lt;/em&gt; library itself is:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Maybe not the friendliest definition at first! But something in this looks a little familiar, maybe. Let’s do some re-arranging:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb27-2&#34;&gt;&lt;a href=&#34;#cb27-2&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb27-3&#34;&gt;&lt;a href=&#34;#cb27-3&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x, a))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ah, this looks a &lt;em&gt;lot&lt;/em&gt; like the constructor &lt;code&gt;Nu&lt;/code&gt; for some &lt;code&gt;f&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f x) x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Nu&lt;/code&gt; is one of the three main famous &lt;a href=&#34;https://hackage.haskell.org/package/recursion-schemes/docs/Data-Functor-Foldable.html&#34;&gt;fixed-point type combinators&lt;/a&gt; in Haskell. The other two are &lt;code&gt;Mu&lt;/code&gt; and &lt;code&gt;Fix&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f x) x&lt;/span&gt;
&lt;span id=&#34;cb29-2&#34;&gt;&lt;a href=&#34;#cb29-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fix&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fix&lt;/span&gt; (f (&lt;span class=&#34;dt&#34;&gt;Fix&lt;/span&gt; f))&lt;/span&gt;
&lt;span id=&#34;cb29-3&#34;&gt;&lt;a href=&#34;#cb29-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Haskell these are all equivalent&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;, but they have very different performance profiles for certain operations. &lt;code&gt;Nu&lt;/code&gt; is easy to “build up”, and &lt;code&gt;Mu&lt;/code&gt; is easy to “tear down” – and they exist sort of opposite to each other. &lt;code&gt;Fix&lt;/code&gt; exists in opposite to … itself. Sorry, &lt;code&gt;Fix&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, looking at &lt;code&gt;Fold r a&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb30&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb30-1&#34;&gt;&lt;a href=&#34;#cb30-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x, a))&lt;/span&gt;
&lt;span id=&#34;cb30-2&#34;&gt;&lt;a href=&#34;#cb30-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt;   f   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt;   x (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it seems like we can pick an &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;Nu (F r a) = Fold r a&lt;/code&gt;. Let’s try…&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb31&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb31-1&#34;&gt;&lt;a href=&#34;#cb31-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; g) x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; (f (g x))&lt;/span&gt;
&lt;span id=&#34;cb31-2&#34;&gt;&lt;a href=&#34;#cb31-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-3&#34;&gt;&lt;a href=&#34;#cb31-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; (((,) a) &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; ((&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;) r))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From here, some might recognize the fixed point of &lt;code&gt;(,) a :.: f&lt;/code&gt; as &lt;code&gt;Cofree&lt;/code&gt;, from &lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Comonad-Cofree.html&#34;&gt;Control.Comonad.Cofree&lt;/a&gt; — one of the more commonly used fixed points.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb32&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb32-1&#34;&gt;&lt;a href=&#34;#cb32-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Cofree&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; ((,) a &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; f     )&lt;/span&gt;
&lt;span id=&#34;cb32-2&#34;&gt;&lt;a href=&#34;#cb32-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb32-3&#34;&gt;&lt;a href=&#34;#cb32-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nu&lt;/span&gt; ((,) a &lt;span class=&#34;op&#34;&gt;:.:&lt;/span&gt; (&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;) r)&lt;/span&gt;
&lt;span id=&#34;cb32-4&#34;&gt;&lt;a href=&#34;#cb32-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r     &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Cofree&lt;/span&gt; ((&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;) r)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It looks like &lt;code&gt;Fold r&lt;/code&gt; is just &lt;code&gt;Cofree ((-&amp;gt;) r)&lt;/code&gt; &lt;a href=&#34;#fn6&#34; class=&#34;footnote-ref&#34; id=&#34;fnref6&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt; … and now we’ve hit the jackpot! That’s because &lt;code&gt;Cofree f&lt;/code&gt; has an instance of &lt;code&gt;Adjunction&lt;/code&gt;!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb33&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb33-1&#34;&gt;&lt;a href=&#34;#cb33-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; f u &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Adjunction&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt; f) (&lt;span class=&#34;dt&#34;&gt;Cofree&lt;/span&gt; u)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that &lt;code&gt;Cofree u&lt;/code&gt; is right-adjoint to &lt;code&gt;Free f&lt;/code&gt;, if &lt;code&gt;f&lt;/code&gt; is right-adjoint to &lt;code&gt;u&lt;/code&gt;. Well, our &lt;code&gt;u&lt;/code&gt; here is &lt;code&gt;(-&amp;gt;) r&lt;/code&gt;, which was actually our very first example of a right-adjoint functor — it’s right-adjoint to &lt;code&gt;(,)&lt;/code&gt;. So, &lt;code&gt;Fold r&lt;/code&gt; is apparently a right-adjoint, like we guessed previously! More specifically, it looks like like &lt;code&gt;Fold r&lt;/code&gt; is right-adjoint to &lt;code&gt;Free ((,) r)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At least, we’ve reached our goal! We found an adjunction for &lt;code&gt;Fold r&lt;/code&gt; in a purely algebraic way, and deduced it to be right-adjunct to &lt;code&gt;Free ((,) r)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At this point we have our answer, so we can stop here. But it’s possible to go a little further, to find a true “perfect companion” for &lt;code&gt;Fold r&lt;/code&gt;. Its perfect match and conceptual opposite, as the adjunction mythos claims.&lt;/p&gt;
&lt;p&gt;We know that &lt;code&gt;Free f&lt;/code&gt; is, itself, a fixed-point – it’s the fixed point of &lt;code&gt;Sum (Const a) f&lt;/code&gt; (from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html&#34;&gt;Data.Functor.Sum&lt;/a&gt;&lt;/em&gt;). So &lt;code&gt;Free ((,) r) a&lt;/code&gt; is the fixed-point of &lt;code&gt;Sum (Const a) ((,) r)&lt;/code&gt;. Since we are looking at conceptual opposites, maybe let’s try using the &lt;code&gt;Mu&lt;/code&gt; fixed-point operator, to be opposite of the &lt;code&gt;Nu&lt;/code&gt; that &lt;code&gt;Fold r&lt;/code&gt; is. This also makes sense because this is something we’re going to “tear down” with a &lt;code&gt;Fold&lt;/code&gt;, and &lt;code&gt;Mu&lt;/code&gt; is good at being torn down.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb34&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb34-1&#34;&gt;&lt;a href=&#34;#cb34-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)&lt;/span&gt;
&lt;span id=&#34;cb34-2&#34;&gt;&lt;a href=&#34;#cb34-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-3&#34;&gt;&lt;a href=&#34;#cb34-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Mu&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Sum&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Const&lt;/span&gt; a) ((,) r))&lt;/span&gt;
&lt;span id=&#34;cb34-4&#34;&gt;&lt;a href=&#34;#cb34-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-5&#34;&gt;&lt;a href=&#34;#cb34-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&#34;cb34-6&#34;&gt;&lt;a href=&#34;#cb34-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    runEL ::&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; a (r, x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb34-7&#34;&gt;&lt;a href=&#34;#cb34-7&#34;&gt;&lt;/a&gt;  }&lt;/span&gt;
&lt;span id=&#34;cb34-8&#34;&gt;&lt;a href=&#34;#cb34-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-9&#34;&gt;&lt;a href=&#34;#cb34-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- or, with some shuffling around, recognizing that `Either a b -&amp;gt; c` is&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-10&#34;&gt;&lt;a href=&#34;#cb34-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- equivalent to `(a -&amp;gt; c, b -&amp;gt; c)`&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-11&#34;&gt;&lt;a href=&#34;#cb34-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; {&lt;/span&gt;
&lt;span id=&#34;cb34-12&#34;&gt;&lt;a href=&#34;#cb34-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    runEL ::&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb34-13&#34;&gt;&lt;a href=&#34;#cb34-13&#34;&gt;&lt;/a&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The new &lt;code&gt;EL&lt;/code&gt; is actually isomorphic to the &lt;code&gt;EnvList&lt;/code&gt; one we wrote earlier (as long as the list is finite), meaning that one can encode the other, and they have identical structure. Writing functions to convert between the two can be fun; &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L31-L39&#34;&gt;here is one solution&lt;/a&gt;, and there’s a &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L73-L79&#34;&gt;bonus solution&lt;/a&gt; if you can write it using only the &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L58-L71&#34;&gt;&lt;em&gt;new&lt;/em&gt; instance&lt;/a&gt; for &lt;code&gt;Adjunction (EL r) (Fold r)&lt;/code&gt; and &lt;code&gt;F.foldMap&lt;/code&gt;, since it can be shown that all adjuncts are unique up to isomorphism.&lt;/p&gt;
&lt;p&gt;And…this looks pretty neat, I think. In the end we discover that these two types are adjoints to each other:&lt;a href=&#34;#fn7&#34; class=&#34;footnote-ref&#34; id=&#34;fnref7&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb35&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb35-1&#34;&gt;&lt;a href=&#34;#cb35-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt;            (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)    (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)    x&lt;/span&gt;
&lt;span id=&#34;cb35-2&#34;&gt;&lt;a href=&#34;#cb35-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt;   r a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt;   (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;They look superficially syntactically similar and I don’t really know what to make of that … but a lot of “opposites” seem to be paired here. The existential &lt;code&gt;x&lt;/code&gt; in &lt;code&gt;Fold&lt;/code&gt; becomes a Rank2 universal in &lt;code&gt;EList&lt;/code&gt;, and the &lt;code&gt;x -&amp;gt; a&lt;/code&gt; in &lt;code&gt;Fold&lt;/code&gt; becomes an &lt;code&gt;a -&amp;gt; x&lt;/code&gt; in &lt;code&gt;EList&lt;/code&gt;. Neat neat.&lt;/p&gt;
&lt;p&gt;Adjunctions: take an idea and just make everything opposite.&lt;/p&gt;
&lt;p&gt;One nice thing about this representation is that writing the fundamental operation of &lt;code&gt;Fold&lt;/code&gt; (that is, &lt;code&gt;fold&lt;/code&gt;) becomes really clean:&lt;a href=&#34;#fn8&#34; class=&#34;footnote-ref&#34; id=&#34;fnref8&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb36&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb36-1&#34;&gt;&lt;a href=&#34;#cb36-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L51-L52&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-2&#34;&gt;&lt;a href=&#34;#cb36-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-3&#34;&gt;&lt;a href=&#34;#cb36-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;foldEL ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; r b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EL&lt;/span&gt; r a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb36-4&#34;&gt;&lt;a href=&#34;#cb36-4&#34;&gt;&lt;/a&gt;foldEL (&lt;span class=&#34;dt&#34;&gt;Fold&lt;/span&gt; step &lt;span class=&#34;fu&#34;&gt;init&lt;/span&gt; extr) el &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; extr (runEL el (&lt;span class=&#34;fu&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;init&lt;/span&gt;) step)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And this is, maybe, the real treasure all along.&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Note that the intuition we are going to be going into is specifically for adjunctions between &lt;code&gt;Functor&lt;/code&gt; functors — functors that the &lt;code&gt;Functor&lt;/code&gt; typeclass models (aka, endofunctors in Hask). For a more general view of adjunctions in general, see the links above.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;As it so happens, &lt;code&gt;fold&lt;/code&gt; is actually exactly &lt;code&gt;index&lt;/code&gt; for &lt;code&gt;Representable (Fold r)&lt;/code&gt;, from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/adjunctions/docs/Data-Functor-Rep.html&#34;&gt;Data.Functor.Rep&lt;/a&gt;&lt;/em&gt;. Here we are utilizing the fact that a representable Functor gives rise to a left-adjoint for free — the two ideas are equivalent in Haskell. We go into this in more detail in an upcoming aside.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;The name here is inspired by the &lt;a href=&#34;https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Trans-Env.html&#34;&gt;&lt;code&gt;Env&lt;/code&gt; comonad&lt;/a&gt; — &lt;code&gt;EnvList r&lt;/code&gt; is &lt;code&gt;Env [r]&lt;/code&gt;.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;We should also be able to define it using &lt;code&gt;tabulateAdjunction&lt;/code&gt; and &lt;code&gt;indexAdjunction&lt;/code&gt; … but this isn’t allowed for some reason?&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;They are only equivalent in Haskell because of laziness — in strict languages, they are different.&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Some might recognize &lt;code&gt;Cofree ((-&amp;gt;) r)&lt;/code&gt; as a common way of implementing a &lt;a href=&#34;https://en.wikipedia.org/wiki/Moore_machine&#34;&gt;Moore machine&lt;/a&gt; in Haskell. In fact, our derivation here is basically a backwards version of &lt;a href=&#34;https://www.schoolofhaskell.com/user/edwardk/moore/for-less&#34;&gt;the process described here by Edward Kmett&lt;/a&gt;.&lt;a href=&#34;#fnref6&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn7&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;The instance is &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L58-L71&#34;&gt;written out here&lt;/a&gt;.&lt;a href=&#34;#fnref7&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn8&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Implementing a &lt;code&gt;tabulate&lt;/code&gt; equivalent (&lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/adjunctions/foldl-algebraic.hs#L54-L56&#34;&gt;solution here&lt;/a&gt;) reveals that this refactoring is only really useful for &lt;code&gt;index&lt;/code&gt; (to “consume” a &lt;code&gt;Fold&lt;/code&gt;) … using &lt;code&gt;tabulate&lt;/code&gt; or &lt;code&gt;leftAdjunct&lt;/code&gt; to “produce” a &lt;code&gt;Fold&lt;/code&gt; reveals how inefficient this is.&lt;a href=&#34;#fnref8&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Math</category><guid isPermaLink="true">https://blog.jle.im/entry/foldl-adjunction.html</guid><pubDate>Mon, 13 Jan 2020 21:04:16 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Math</subject><date>2020-01-13</date></item><item><title>Dead-simple TCP/IP services using servant</title><link>https://blog.jle.im/entry/simple-tcpip-services-servant.html</link><description>&lt;p&gt;In my time I’ve written a lot of throwaway binary TCP/IP services (servers and services you can interact with over an internet connection, through command line interface or GUI). For me, this involves designing a protocol from scratch every time with varying levels of hand-rolled authentication and error detection (Send this byte for this command, this byte for this other command, etc.). Once I design the protocol, I then have to write both the command line client and the server — something I usually do from scratch over the raw TCP streams.&lt;/p&gt;
&lt;p&gt;This process was fun (and informative) the first few times I did it, but spinning it up from scratch again every time discouraged me from doing it very often. However, thankfully, with the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/servant&#34;&gt;servant&lt;/a&gt;&lt;/em&gt; haskell library (and &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/servant-cli&#34;&gt;servant-cli&lt;/a&gt;&lt;/em&gt;, for command line clients), writing a TCP server/client pair for a TCP service (using HTTP under the hood) becomes dead-simple — the barrier for creating one fades away that designing/writing a service becomes a tool that I reach for immediately in a lot of cases without second thought.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;servant&lt;/em&gt; is usually advertised as a tool for writing web servers, web applications, and REST APIs, but it’s easily adapted to write non-web things as well. Let’s dive in and write a simple TCP/IP service (a todo list manager) to see how straightforward the process is!&lt;/p&gt;
&lt;p&gt;To goal of this article is to take service/program that you already have planned out, and &lt;em&gt;easily provide&lt;/em&gt; it with a networked API that can be used over any TCP/IP connection (over the internet, or even locally). This won’t teach you &lt;em&gt;how&lt;/em&gt; to write a todo app, but rather how to &lt;em&gt;hook up&lt;/em&gt; a todo app over a TCP/IP connection quickly, with a command line client — and in such a simple way that you wouldn’t give a second thought based on complexity issues.&lt;/p&gt;
&lt;p&gt;This post can also serve as a stepping-stone to a “microservices architecture”, if you intend to build towards one (this is explored deeper by &lt;a href=&#34;https://github.com/k-bx/owlcloud&#34;&gt;k-bx&lt;/a&gt;)…but really it’s more focused for standalone user-facing applications. How you apply these techniques is up to you :)&lt;/p&gt;
&lt;p&gt;All of the code in this article is available online, and the server and client are available as “stack executables”: if you download them all, and set the permissions properly (&lt;code&gt;chmod u+x&lt;/code&gt;), you can directly run them to launch the server and client (if they are all download to the same directory).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/Api.hs&#34;&gt;API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/server.hs&#34;&gt;Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/client.hs&#34;&gt;Client&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;todo-api&#34;&gt;Todo API&lt;/h2&gt;
&lt;p&gt;As an example, we’ll work through building one of my favorite self-contained mini-app projects, a &lt;a href=&#34;http://todomvc.com/&#34;&gt;Todo list manager a la todo-mvc&lt;/a&gt;. Our service will provide functionality for:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Viewing all tasks and their status&lt;/li&gt;
&lt;li&gt;Adding a new task&lt;/li&gt;
&lt;li&gt;Setting a task’s completion status&lt;/li&gt;
&lt;li&gt;Deleting a task&lt;/li&gt;
&lt;li&gt;Pruning all completed tasks&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To facilitate doing this over an API, we’ll assign each task a task ID when it comes in, and so commands 3 and 4 will require a task ID.&lt;/p&gt;
&lt;p&gt;To formally specify our API:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt;: View all tasks by their ID, status, and description. Optionally be able to filter for only incomplete tasks.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add&lt;/code&gt;: Given a new task description, insert a new uncompleted task. Return the ID of the new task.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt;: Given a task ID and an updated status, update the task’s status.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;: Given a task ID, delete the task.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prune&lt;/code&gt;: Remove all completed tasks. Returns all the task IDs that where deleted.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can state this using servant’s type level DSL, using an &lt;code&gt;IntMap&lt;/code&gt; (from &lt;em&gt;containers&lt;/em&gt;) to represent the current tasks and an &lt;code&gt;IntSet&lt;/code&gt; to represent a set of task IDs.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/Api.hs&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;{-# LANGUAGE DeriveGeneric #-}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;{-# LANGUAGE TypeInType    #-}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-5&#34;&gt;&lt;a href=&#34;#cb1-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;{-# LANGUAGE TypeOperators #-}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-6&#34;&gt;&lt;a href=&#34;#cb1-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;{-# OPTIONS_GHC -Wall      #-}&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-7&#34;&gt;&lt;a href=&#34;#cb1-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-8&#34;&gt;&lt;a href=&#34;#cb1-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;module&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Api&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-9&#34;&gt;&lt;a href=&#34;#cb1-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-10&#34;&gt;&lt;a href=&#34;#cb1-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Data.Aeson&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-11&#34;&gt;&lt;a href=&#34;#cb1-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Data.IntMap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;IntMap&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb1-12&#34;&gt;&lt;a href=&#34;#cb1-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Data.IntSet&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;IntSet&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb1-13&#34;&gt;&lt;a href=&#34;#cb1-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Data.Proxy&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-14&#34;&gt;&lt;a href=&#34;#cb1-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Data.Text&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Text&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb1-15&#34;&gt;&lt;a href=&#34;#cb1-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;GHC.Generics&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-16&#34;&gt;&lt;a href=&#34;#cb1-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Servant.API&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-17&#34;&gt;&lt;a href=&#34;#cb1-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-18&#34;&gt;&lt;a href=&#34;#cb1-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-19&#34;&gt;&lt;a href=&#34;#cb1-19&#34;&gt;&lt;/a&gt;    {&lt;span class=&#34;ot&#34;&gt; taskStatus ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-20&#34;&gt;&lt;a href=&#34;#cb1-20&#34;&gt;&lt;/a&gt;    ,&lt;span class=&#34;ot&#34;&gt; taskDesc   ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Text&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-21&#34;&gt;&lt;a href=&#34;#cb1-21&#34;&gt;&lt;/a&gt;    }&lt;/span&gt;
&lt;span id=&#34;cb1-22&#34;&gt;&lt;a href=&#34;#cb1-22&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Generic&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb1-23&#34;&gt;&lt;a href=&#34;#cb1-23&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ToJSON&lt;/span&gt;   &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-24&#34;&gt;&lt;a href=&#34;#cb1-24&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FromJSON&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-25&#34;&gt;&lt;a href=&#34;#cb1-25&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-26&#34;&gt;&lt;a href=&#34;#cb1-26&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TodoApi&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;list&amp;quot;&lt;/span&gt;   &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;QueryFlag&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;filtered&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-27&#34;&gt;&lt;a href=&#34;#cb1-27&#34;&gt;&lt;/a&gt;                        &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Get&lt;/span&gt;  &amp;#39;[&lt;span class=&#34;dt&#34;&gt;JSON&lt;/span&gt;] (&lt;span class=&#34;dt&#34;&gt;IntMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb1-28&#34;&gt;&lt;a href=&#34;#cb1-28&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;add&amp;quot;&lt;/span&gt;    &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;QueryParam&amp;#39;&lt;/span&gt; &amp;#39;[&lt;span class=&#34;dt&#34;&gt;Required&lt;/span&gt;] &lt;span class=&#34;st&#34;&gt;&amp;quot;desc&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Text&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-29&#34;&gt;&lt;a href=&#34;#cb1-29&#34;&gt;&lt;/a&gt;                        &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; &amp;#39;[&lt;span class=&#34;dt&#34;&gt;JSON&lt;/span&gt;] &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-30&#34;&gt;&lt;a href=&#34;#cb1-30&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;set&amp;quot;&lt;/span&gt;    &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Capture&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-31&#34;&gt;&lt;a href=&#34;#cb1-31&#34;&gt;&lt;/a&gt;                        &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;QueryParam&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;completed&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-32&#34;&gt;&lt;a href=&#34;#cb1-32&#34;&gt;&lt;/a&gt;                        &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; &amp;#39;[&lt;span class=&#34;dt&#34;&gt;JSON&lt;/span&gt;] ()&lt;/span&gt;
&lt;span id=&#34;cb1-33&#34;&gt;&lt;a href=&#34;#cb1-33&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;delete&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Capture&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-34&#34;&gt;&lt;a href=&#34;#cb1-34&#34;&gt;&lt;/a&gt;                        &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; &amp;#39;[&lt;span class=&#34;dt&#34;&gt;JSON&lt;/span&gt;] ()&lt;/span&gt;
&lt;span id=&#34;cb1-35&#34;&gt;&lt;a href=&#34;#cb1-35&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;prune&amp;quot;&lt;/span&gt;  &lt;span class=&#34;op&#34;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Post&lt;/span&gt; &amp;#39;[&lt;span class=&#34;dt&#34;&gt;JSON&lt;/span&gt;] &lt;span class=&#34;dt&#34;&gt;IntSet&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-36&#34;&gt;&lt;a href=&#34;#cb1-36&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-37&#34;&gt;&lt;a href=&#34;#cb1-37&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;todoApi ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TodoApi&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-38&#34;&gt;&lt;a href=&#34;#cb1-38&#34;&gt;&lt;/a&gt;todoApi &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(This is how you specify an API (via a type) using &lt;em&gt;servant&lt;/em&gt;, with their provided &lt;code&gt;:&amp;lt;|&amp;gt;&lt;/code&gt; and &lt;code&gt;:&amp;gt;&lt;/code&gt; operators — &lt;code&gt;:&amp;lt;|&amp;gt;&lt;/code&gt; combines routes, &lt;code&gt;:&amp;gt;&lt;/code&gt; combines path components, and &lt;code&gt;QueryParam&lt;/code&gt;, &lt;code&gt;Capture&lt;/code&gt;, etc. all add parts to components and routes.)&lt;/p&gt;
&lt;p&gt;We have five routes, which more or less mirror exactly the five bullet points listed above, with some minor implementation choices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;list&lt;/code&gt;, we take “filtered or not filtered” as a query flag, and return an &lt;code&gt;IntMap&lt;/code&gt; of a &lt;code&gt;Task&lt;/code&gt; data type (status, description) under their integer ID key.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;add&lt;/code&gt;, we take the task description as a query parameter, and return the new ID.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;set&lt;/code&gt;, we take the task ID as a capture (path component) and an optional boolean query parameter. If the parameter is not given, it will be taken as a toggle; otherwise, it will be taken as a setting of the completion status.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;delete&lt;/code&gt;, we also take the task ID as a capture.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;prune&lt;/code&gt;, we return the deleted IDs as an &lt;code&gt;IntSet&lt;/code&gt; (also from &lt;em&gt;containers&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;“Query flag”, “query parameter”, “capture” are all a part of the language of HTTP and W3C. In our case, since we aren’t ever directly programming against the actual protocol-HTTP (it’s only used under the hood) or pretending to write an actual web-interfacing server, we don’t really need to care too much to distinguish them. However, it can be useful to pick meaningful choices if we ever do want to expose this API as a web service.&lt;/p&gt;
&lt;h2 id=&#34;todo-service-server&#34;&gt;Todo Service Server&lt;/h2&gt;
&lt;p&gt;The logic to implement a todo server is pretty straightforward, which is why we chose it as an example project. It only really needs one state: the &lt;code&gt;IntMap&lt;/code&gt; of current tasks.&lt;/p&gt;
&lt;p&gt;To write a servant server with &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/servant-server&#34;&gt;servant-server&lt;/a&gt;&lt;/em&gt;, I usually like to just set up a skeleton with each route:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;serveTodoApi ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IORef&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;IntMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Server&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TodoApi&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;serveTodoApi taskRef &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; serveList&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; serveAdd&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; serveSet&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; serveDelete&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; servePrune&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The corresponding GHC error tells us everything we need:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server.hs:15:24: error:
    Variable not in scope: serveList :: Bool -&amp;gt; Handler (IntMap Task)
   |
15 | serveTodoApi taskRef = serveList
   |                        ^^^^^^^^^

server.hs:16:24: error:
    Variable not in scope: serveAdd :: Text -&amp;gt; Handler Int
   |
16 |                   :&amp;lt;|&amp;gt; serveAdd
   |                        ^^^^^^^^

server.hs:17:24: error:
    Variable not in scope: serveSet :: Int -&amp;gt; Maybe Bool -&amp;gt; Handler ()
   |
17 |                   :&amp;lt;|&amp;gt; serveSet
   |                        ^^^^^^^^

server.hs:18:24: error:
    Variable not in scope: serveDelete :: Int -&amp;gt; Handler ()
   |
18 |                   :&amp;lt;|&amp;gt; serveDelete
   |                        ^^^^^^^^^^^

server.hs:19:24: error:
    Variable not in scope: servePrune :: Handler IntSet
   |
19 |                   :&amp;lt;|&amp;gt; servePrune
   |                        ^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It tells us exactly the types of each handler we need.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;Handler&lt;/code&gt; has a &lt;code&gt;MonadIO&lt;/code&gt; instance, we can now directly just write every handler in terms of how it manipulates the &lt;code&gt;IntMap&lt;/code&gt; in the &lt;code&gt;IORef&lt;/code&gt;, and use &lt;code&gt;liftIO&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/server.hs#L16-L46&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;serveTodoApi ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IORef&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;IntMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Server&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TodoApi&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;serveTodoApi taskRef &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; serveList&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; serveAdd&lt;/span&gt;
&lt;span id=&#34;cb4-6&#34;&gt;&lt;a href=&#34;#cb4-6&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; serveSet&lt;/span&gt;
&lt;span id=&#34;cb4-7&#34;&gt;&lt;a href=&#34;#cb4-7&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; serveDelete&lt;/span&gt;
&lt;span id=&#34;cb4-8&#34;&gt;&lt;a href=&#34;#cb4-8&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; servePrune&lt;/span&gt;
&lt;span id=&#34;cb4-9&#34;&gt;&lt;a href=&#34;#cb4-9&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-10&#34;&gt;&lt;a href=&#34;#cb4-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    serveList ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Handler&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;IntMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb4-11&#34;&gt;&lt;a href=&#34;#cb4-11&#34;&gt;&lt;/a&gt;    serveList filt &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; filtFunction &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; liftIO (readIORef taskRef)&lt;/span&gt;
&lt;span id=&#34;cb4-12&#34;&gt;&lt;a href=&#34;#cb4-12&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-13&#34;&gt;&lt;a href=&#34;#cb4-13&#34;&gt;&lt;/a&gt;        filtFunction&lt;/span&gt;
&lt;span id=&#34;cb4-14&#34;&gt;&lt;a href=&#34;#cb4-14&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; filt      &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; IM.filter (&lt;span class=&#34;fu&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; taskStatus)&lt;/span&gt;
&lt;span id=&#34;cb4-15&#34;&gt;&lt;a href=&#34;#cb4-15&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;otherwise&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-16&#34;&gt;&lt;a href=&#34;#cb4-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    serveAdd ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Text&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Handler&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-17&#34;&gt;&lt;a href=&#34;#cb4-17&#34;&gt;&lt;/a&gt;    serveAdd t &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; liftIO &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; atomicModifyIORef&amp;#39; taskRef &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \ts &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-18&#34;&gt;&lt;a href=&#34;#cb4-18&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;let&lt;/span&gt; newKey &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;maybe&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; ((&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fst&lt;/span&gt;) (IM.lookupMax ts)&lt;/span&gt;
&lt;span id=&#34;cb4-19&#34;&gt;&lt;a href=&#34;#cb4-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;in&lt;/span&gt;  ( IM.insert newKey (&lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;False&lt;/span&gt; t) ts, newKey )&lt;/span&gt;
&lt;span id=&#34;cb4-20&#34;&gt;&lt;a href=&#34;#cb4-20&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    serveSet ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Handler&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb4-21&#34;&gt;&lt;a href=&#34;#cb4-21&#34;&gt;&lt;/a&gt;    serveSet tid s &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; liftIO &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; atomicModifyIORef&amp;#39; taskRef &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \ts &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-22&#34;&gt;&lt;a href=&#34;#cb4-22&#34;&gt;&lt;/a&gt;        ( IM.adjust adjuster tid ts, () )&lt;/span&gt;
&lt;span id=&#34;cb4-23&#34;&gt;&lt;a href=&#34;#cb4-23&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-24&#34;&gt;&lt;a href=&#34;#cb4-24&#34;&gt;&lt;/a&gt;        adjuster (&lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; c d) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; s &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-25&#34;&gt;&lt;a href=&#34;#cb4-25&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;not&lt;/span&gt; c) d&lt;/span&gt;
&lt;span id=&#34;cb4-26&#34;&gt;&lt;a href=&#34;#cb4-26&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; c&amp;#39; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; c&amp;#39;      d&lt;/span&gt;
&lt;span id=&#34;cb4-27&#34;&gt;&lt;a href=&#34;#cb4-27&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    serveDelete ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Handler&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb4-28&#34;&gt;&lt;a href=&#34;#cb4-28&#34;&gt;&lt;/a&gt;    serveDelete tid &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; liftIO &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; atomicModifyIORef&amp;#39; taskRef &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \ts &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-29&#34;&gt;&lt;a href=&#34;#cb4-29&#34;&gt;&lt;/a&gt;      ( IM.delete tid ts, () )&lt;/span&gt;
&lt;span id=&#34;cb4-30&#34;&gt;&lt;a href=&#34;#cb4-30&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    servePrune ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Handler&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IntSet&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-31&#34;&gt;&lt;a href=&#34;#cb4-31&#34;&gt;&lt;/a&gt;    servePrune &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; liftIO &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; atomicModifyIORef&amp;#39; taskRef &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \ts &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-32&#34;&gt;&lt;a href=&#34;#cb4-32&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;let&lt;/span&gt; (compl,incompl) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; IM.partition taskStatus ts&lt;/span&gt;
&lt;span id=&#34;cb4-33&#34;&gt;&lt;a href=&#34;#cb4-33&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;in&lt;/span&gt;  (incompl, IM.keysSet compl)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it!&lt;/p&gt;
&lt;p&gt;To run our server, we can use &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/warp&#34;&gt;warp&lt;/a&gt;&lt;/em&gt;’s &lt;code&gt;run&lt;/code&gt; with &lt;em&gt;servant-server&lt;/em&gt;’s &lt;code&gt;serve&lt;/code&gt;, after initializing the &lt;code&gt;IORef&lt;/code&gt; that our server will use with an empty map:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/server.hs#L48-L53&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;main ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;main &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;    taskRef &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; newIORef IM.empty&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;putStrLn&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Launching server...&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-7&#34;&gt;&lt;a href=&#34;#cb5-7&#34;&gt;&lt;/a&gt;    run &lt;span class=&#34;dv&#34;&gt;3434&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-8&#34;&gt;&lt;a href=&#34;#cb5-8&#34;&gt;&lt;/a&gt;      serve todoApi (serveTodoApi taskRef)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now have a todo TCP/IP service running on port 3434!&lt;/p&gt;
&lt;h2 id=&#34;todo-service-client&#34;&gt;Todo Service Client&lt;/h2&gt;
&lt;p&gt;To write a client, we have a couple of options.&lt;/p&gt;
&lt;p&gt;You &lt;em&gt;could&lt;/em&gt; hand-write a command-line client using either &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/optparse-applicative&#34;&gt;optparse-applicative&lt;/a&gt;&lt;/em&gt; (or your favorite command line args parser) for an options-and-arguments style interface or a readline library like &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/haskeline&#34;&gt;haskeline&lt;/a&gt;&lt;/em&gt; for an interactive interface.&lt;/p&gt;
&lt;p&gt;Hand-writing one is made pretty simple with &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/servant-client&#34;&gt;servant-client&lt;/a&gt;&lt;/em&gt;, which allows you to generate all of the HTTP calls using the &lt;code&gt;client&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;list &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; add &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; set &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; delete &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; prune &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; client todoApi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will give you the functions &lt;code&gt;list :: Bool -&amp;gt; ClientM (IntMap Task)&lt;/code&gt;, &lt;code&gt;add :: Text -&amp;gt; ClientM Int&lt;/code&gt;, &lt;code&gt;set :: Int -&amp;gt; Maybe Bool -&amp;gt; ClientM ()&lt;/code&gt;, etc., that you can now run whenever you want to dispatch a command or make a fetch according to your hand-rolled needs.&lt;/p&gt;
&lt;p&gt;However, this blog post is about “dead-simple” setups that you can roll out within minutes. For &lt;em&gt;that&lt;/em&gt;, you can use the library &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/servant-cli&#34;&gt;servant-cli&lt;/a&gt;&lt;/em&gt; to automatically generate an &lt;em&gt;optparse-applicative&lt;/em&gt;-based command line interface that allows you to directly specify your commands based on command line arguments&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/client.hs#L34-L60&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;main ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;main &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;    c &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; parseHandleClient todoApi (&lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ClientM&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;        ( header &lt;span class=&#34;st&#34;&gt;&amp;quot;todo&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; progDesc &lt;span class=&#34;st&#34;&gt;&amp;quot;Todo TCP/IP service client&amp;quot;&lt;/span&gt; )&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;        ( displayList&lt;/span&gt;
&lt;span id=&#34;cb7-8&#34;&gt;&lt;a href=&#34;#cb7-8&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; (\i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Added with ID &amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;show&lt;/span&gt; i)&lt;/span&gt;
&lt;span id=&#34;cb7-9&#34;&gt;&lt;a href=&#34;#cb7-9&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Set!&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-10&#34;&gt;&lt;a href=&#34;#cb7-10&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Deleted!&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-11&#34;&gt;&lt;a href=&#34;#cb7-11&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; (\ts &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;Cleared items: &amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;++&lt;/span&gt; intercalate &lt;span class=&#34;st&#34;&gt;&amp;quot;, &amp;quot;&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;show&lt;/span&gt; (IS.toList ts)))&lt;/span&gt;
&lt;span id=&#34;cb7-12&#34;&gt;&lt;a href=&#34;#cb7-12&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;
&lt;span id=&#34;cb7-13&#34;&gt;&lt;a href=&#34;#cb7-13&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-14&#34;&gt;&lt;a href=&#34;#cb7-14&#34;&gt;&lt;/a&gt;    res &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; newManager defaultManagerSettings &lt;span class=&#34;op&#34;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; \mgr &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-15&#34;&gt;&lt;a href=&#34;#cb7-15&#34;&gt;&lt;/a&gt;      runClientM c &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-16&#34;&gt;&lt;a href=&#34;#cb7-16&#34;&gt;&lt;/a&gt;        mkClientEnv mgr (&lt;span class=&#34;dt&#34;&gt;BaseUrl&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Http&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;localhost&amp;quot;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3434&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb7-17&#34;&gt;&lt;a href=&#34;#cb7-17&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-18&#34;&gt;&lt;a href=&#34;#cb7-18&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; res &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-19&#34;&gt;&lt;a href=&#34;#cb7-19&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Left&lt;/span&gt;  e &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; throwIO e&lt;/span&gt;
&lt;span id=&#34;cb7-20&#34;&gt;&lt;a href=&#34;#cb7-20&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Right&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;putStrLn&lt;/span&gt; r&lt;/span&gt;
&lt;span id=&#34;cb7-21&#34;&gt;&lt;a href=&#34;#cb7-21&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-22&#34;&gt;&lt;a href=&#34;#cb7-22&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;displayList ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IntMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-23&#34;&gt;&lt;a href=&#34;#cb7-23&#34;&gt;&lt;/a&gt;displayList &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;unlines&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-24&#34;&gt;&lt;a href=&#34;#cb7-24&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; (\(k, t) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; printf &lt;span class=&#34;st&#34;&gt;&amp;quot;%d) %s&amp;quot;&lt;/span&gt; k (displayTask t))&lt;/span&gt;
&lt;span id=&#34;cb7-25&#34;&gt;&lt;a href=&#34;#cb7-25&#34;&gt;&lt;/a&gt;            &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; IM.toList&lt;/span&gt;
&lt;span id=&#34;cb7-26&#34;&gt;&lt;a href=&#34;#cb7-26&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-27&#34;&gt;&lt;a href=&#34;#cb7-27&#34;&gt;&lt;/a&gt;    displayTask (&lt;span class=&#34;dt&#34;&gt;Task&lt;/span&gt; c t)&lt;/span&gt;
&lt;span id=&#34;cb7-28&#34;&gt;&lt;a href=&#34;#cb7-28&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; c         &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;[x] &amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;++&lt;/span&gt; T.unpack t&lt;/span&gt;
&lt;span id=&#34;cb7-29&#34;&gt;&lt;a href=&#34;#cb7-29&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;otherwise&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;[ ] &amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;++&lt;/span&gt; T.unpack t&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main thing that does the work is &lt;code&gt;parseHandleClient&lt;/code&gt;, which takes (after some proxies specifying the API and client type):&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;Extra arguments modifying the command line help messages&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A way to “handle” a response for every command.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;list&lt;/code&gt;, we display it using a nice pretty-printer&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;add&lt;/code&gt;, we show the new ID number.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, we just display the fact that it was successful (remember, these routes returned &lt;code&gt;()&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;prune&lt;/code&gt;, we pretty-print the deleted items.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We choose to handle each command as a &lt;code&gt;String&lt;/code&gt;, but we can choose to handle them each into any type we want (even something involving&lt;code&gt;IO&lt;/code&gt;) as long as each handler returns something of the same type.&lt;/p&gt;
&lt;p&gt;The handler is run and is returned as the value in &lt;code&gt;Right&lt;/code&gt; when used with &lt;code&gt;runClientM&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again, a nice way to “write” our &lt;code&gt;parseHandleClient&lt;/code&gt; function with its handlers is by writing a skeleton definition and letting GHC tell us what goes in each hole:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;main ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;main &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;    c &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; parseHandleClient todoApi (&lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ClientM&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;        ( header &lt;span class=&#34;st&#34;&gt;&amp;quot;todo&amp;quot;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; progDesc &lt;span class=&#34;st&#34;&gt;&amp;quot;Todo TCP/IP service client&amp;quot;&lt;/span&gt; )&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;        ( handleList&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; handleAdd&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; handleSet&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; handleDelete&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;     &lt;span class=&#34;op&#34;&gt;:&amp;lt;|&amp;gt;&lt;/span&gt; handlePrune&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; ()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;client.hs:36:11: error:
    • Variable not in scope: handleList :: IntMap Task -&amp;gt; [Char]
   |
36 |         ( handleList
   |           ^^^^^^^^^^

client.hs:37:11: error:
    Variable not in scope: handleAdd :: Int -&amp;gt; [Char]
   |
37 |      :&amp;lt;|&amp;gt; handleAdd
   |           ^^^^^^^^^

client.hs:38:11: error:
    Variable not in scope: handleSet :: () -&amp;gt; [Char]
   |
38 |      :&amp;lt;|&amp;gt; handleSet
   |           ^^^^^^^^^

client.hs:39:11: error:
    Variable not in scope: handleDelete :: () -&amp;gt; [Char]
   |
39 |      :&amp;lt;|&amp;gt; handleDelete
   |           ^^^^^^^^^^^^

client.hs:40:11: error:
    Variable not in scope: handlePrune :: IS.IntSet -&amp;gt; [Char]
   |
40 |      :&amp;lt;|&amp;gt; handlePrune
   |           ^^^^^^^^^^^&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One last thing — &lt;em&gt;servant-cli&lt;/em&gt; requires some instances to provide “help” documentation for the command line interfaces:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/servant-services/client.hs#L25-L32&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ToParam&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;QueryFlag&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;filtered&amp;quot;&lt;/span&gt;) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;    toParam _ &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DocQueryParam&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;filtered&amp;quot;&lt;/span&gt; [] &lt;span class=&#34;st&#34;&gt;&amp;quot;Whether or not to filter completed items&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Flag&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-5&#34;&gt;&lt;a href=&#34;#cb10-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ToParam&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;QueryParam&amp;#39;&lt;/span&gt; &amp;#39;[&lt;span class=&#34;dt&#34;&gt;Required&lt;/span&gt;] &lt;span class=&#34;st&#34;&gt;&amp;quot;desc&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Text&lt;/span&gt;) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-6&#34;&gt;&lt;a href=&#34;#cb10-6&#34;&gt;&lt;/a&gt;    toParam _ &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DocQueryParam&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;desc&amp;quot;&lt;/span&gt; [] &lt;span class=&#34;st&#34;&gt;&amp;quot;Task description&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Normal&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-7&#34;&gt;&lt;a href=&#34;#cb10-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ToParam&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;QueryParam&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;completed&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-8&#34;&gt;&lt;a href=&#34;#cb10-8&#34;&gt;&lt;/a&gt;    toParam _ &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DocQueryParam&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;completed&amp;quot;&lt;/span&gt; [&lt;span class=&#34;st&#34;&gt;&amp;quot;True&amp;quot;&lt;/span&gt;,&lt;span class=&#34;st&#34;&gt;&amp;quot;False&amp;quot;&lt;/span&gt;] &lt;span class=&#34;st&#34;&gt;&amp;quot;Set status to (leave out for toggle)&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Normal&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-9&#34;&gt;&lt;a href=&#34;#cb10-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ToCapture&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Capture&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-10&#34;&gt;&lt;a href=&#34;#cb10-10&#34;&gt;&lt;/a&gt;    toCapture _ &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;DocCapture&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;ID number of task&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And we now get a fully-featured client for our service!&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# make sure you run ./server.hs in a separate window
$ ./client.hs --help
todo

Usage: client.hs COMPONENT
  Todo TCP/IP service client

Available options:
  -h,--help                Show this help text

Path components:
  add
  delete
  list
  prune
  set

$ ./client.hs add --help
add

Usage: client.hs add --desc TEXT


Available options:
  --desc TEXT              Task description (Text)
  -h,--help                Show this help text

$ ./client.hs list --help
list

Usage: client.hs list [--filtered]


Available options:
  --filtered               Whether or not to filter completed items
  -h,--help                Show this help text

$ ./client.hs set --help
set

Usage: client.hs set &amp;lt;id&amp;gt; [--completed BOOL]


Available options:
  &amp;lt;id&amp;gt;                     ID number of task (Int)
  --completed BOOL         Set status to (leave out for toggle) (options: True,
                           False)
  -h,--help                Show this help text&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;One major thing I like about this method is that it’s very type-safe and allows for types to &lt;em&gt;drive&lt;/em&gt; your development. Note how all of the messiness of a binary protocol like TCP/IP are abstracted away, and you only ever deal with &lt;code&gt;IntMap&lt;/code&gt;s, &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;s. And also note how in every step of the way, we use types to guide us: in writing our server, we first used “blanks” to ask GHC what the type of each of the handlers needs to be, which helps us plan our server implementation and ensures that it handles everything properly. In writing our client, we also used “blanks” to ask GHC what the type of each of our response handlers needs to be, which allows us to quickly and effectively drill down every option. These are things that &lt;em&gt;all&lt;/em&gt; servant-based projects get to benefit from.&lt;/p&gt;
&lt;p&gt;Hopefully this post serves as a good introduction to the &lt;em&gt;servant&lt;/em&gt;, &lt;em&gt;servant-server&lt;/em&gt;, and &lt;em&gt;servant-cli&lt;/em&gt; libraries, and additionally shows how easy it is to give any application you want a TCP/IP interface to be usable as a TCP/IP service. In the real world, your applications might be a little more complex (and you might even require authentication), but hopefully after reading this article, the “network-facing” part of your service or application becomes a lot less intimidating :)&lt;/p&gt;
&lt;p&gt;I know for me, the main benefit has been to tear down the “barrier of entry”/mental startup cost, and I’ve started writing little services and clients like this as a first-step in a lot of cases, instead of as something I dread and only end up adding to a few programs.&lt;/p&gt;
&lt;p&gt;Also, fair disclosure: the author of &lt;em&gt;servant-cli&lt;/em&gt; is me! I’m not &lt;em&gt;super&lt;/em&gt; happy with the user experience story at the moment, but it has been usable for me so far. If you have any suggestions or ideas for improving &lt;em&gt;servant-cli&lt;/em&gt;, I’d &lt;a href=&#34;https://github.com/mstksg/servant-cli&#34;&gt;love to hear&lt;/a&gt; (and look at any PRs!)&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/simple-tcpip-services-servant.html</guid><pubDate>Mon,  5 Aug 2019 20:10:07 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Tutorials</subject><date>2019-08-05</date></item><item><title>The Functor Combinatorpedia</title><link>https://blog.jle.im/entry/functor-combinatorpedia.html</link><description>&lt;p&gt;&lt;strong&gt;functor-combinators&lt;/strong&gt;: &lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;hackage&lt;/a&gt; / &lt;a href=&#34;https://github.com/mstksg/functor-combinators&#34;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Note:&lt;/em&gt; This post has been heavily revised to reflect the functor-combinators-0.2 refactoring, as of November 2019. For reference, &lt;a href=&#34;https://github.com/mstksg/inCode/blob/ceee9f33492bb703380d877477728feb4fe60a6a/entry/functor-combinatorpedia.md&#34;&gt;the original post&lt;/a&gt; is available on github.)&lt;/p&gt;
&lt;p&gt;(&lt;em&gt;Note 2:&lt;/em&gt; The section on contravariant functor combinators was added following the release of &lt;em&gt;functor-combinators-0.3&lt;/em&gt; in August 2020, which added support for contravariant and invariant functor combinators.)&lt;/p&gt;
&lt;p&gt;Recently I’ve been very productive what I have been calling the “Functor Combinator” design pattern. It is heavily influenced by ideas like &lt;a href=&#34;http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf&#34;&gt;Data types a la Carte&lt;/a&gt; and &lt;a href=&#34;http://oleg.fi/gists/posts/2018-02-21-single-free.html&#34;&gt;unified free monoidal functors&lt;/a&gt;, but the end goal is slightly different in spirit. The goal is to represent schemas, DSL’s, and computations (things like parsers, things to execute, things to consume or produce data) by assembling “self-evident” basic primitives and subjecting them to many &lt;em&gt;different&lt;/em&gt; successive transformations and combiners (through combinators, free structures, tensors, and other options). The process of doing so:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Forces you to make explicit decisions about the structure of your computation type as an ADT.&lt;/li&gt;
&lt;li&gt;Allows you to retain isolation of fundamental parts of your domain as separate types&lt;/li&gt;
&lt;li&gt;Lets you manipulate the structure of your final computation type through &lt;em&gt;normal Haskell techniques&lt;/em&gt; like pattern matching. The structure is available throughout the entire process, so you can replace individual components and values within your structure.&lt;/li&gt;
&lt;li&gt;Allows you to fully &lt;em&gt;reflect&lt;/em&gt; the structure of your final computation through pattern matching and folds, so you can inspect the structure and produce useful summaries.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Like “data types a la carte” and free monad/applicative/alternative designs, these techniques allow you to separate the assembly and inspection of your programs from the “running” of them.&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; However, the main difference is that here we focus not just on products and sums, but many different varied and multi-purpose combinators — a “zoo” of combinators. The fixed point is &lt;em&gt;not&lt;/em&gt; the end goal. The actual ADT data types &lt;em&gt;themselves&lt;/em&gt; are the goal.&lt;/p&gt;
&lt;p&gt;This post is a run-down on the wide variety of such “functor combinators” across the Haskell ecosystem — a functor combinatorpedia. To speak about them all with the same language and vocabulary, this post also serves as an overview of the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;functor-combinators&lt;/a&gt;&lt;/em&gt; library, which doesn’t really define these functor combinators, but rather pulls them all together and provides a unified interface for working with them. Most of these types and typeclasses are exported by &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html&#34;&gt;Data.Functor.Combinator&lt;/a&gt;&lt;/em&gt;. Of course, the end-goal is to work with these data types &lt;em&gt;themselves&lt;/em&gt; directly, so not &lt;em&gt;everything&lt;/em&gt; is meant to be doable with these typeclasses; they only serve to unite some common aspects.&lt;/p&gt;
&lt;p&gt;Right now I already have some posts about this general design pattern, &lt;a href=&#34;https://blog.jle.im/entry/interpreters-a-la-carte-duet.html&#34;&gt;“Interpreters a la Carte” in Advent of Code 2017 Duet&lt;/a&gt; and &lt;a href=&#34;https://blog.jle.im/entry/free-alternative-regexp.html&#34;&gt;Applicative Regular Expressions using the Free Alternative&lt;/a&gt;, but I do have some posts planned in the future going through projects using this unified interface. In a way, this post also serves as the “introduction to free structures” that I always wanted to write :)&lt;/p&gt;
&lt;p&gt;Please refer to the &lt;a href=&#34;https://blog.jle.im/entry/functor-combinatorpedia.html#title&#34;&gt;table of contents&lt;/a&gt; if you are using this as a reference!&lt;/p&gt;
&lt;h2 id=&#34;preface-what-is-a-functor-combinator&#34;&gt;Preface: What is a functor combinator?&lt;/h2&gt;
&lt;p&gt;A functor combinator takes “functors” (or any other indexed type, &lt;code&gt;k -&amp;gt; Type&lt;/code&gt;) and returns a new functor, enhances or mixes them together in some way. That is, they take things of kind &lt;code&gt;k -&amp;gt; Type&lt;/code&gt; and themselves return a &lt;code&gt;j -&amp;gt; Type&lt;/code&gt;. This lets us build complex functors/indexed types out of simpler “primitive” ones. This includes many some monad transformers, free structures, and tensors.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;ReaderT r&lt;/code&gt; is a famous one that takes a functor &lt;code&gt;f&lt;/code&gt; and enhances it with “access to an &lt;code&gt;r&lt;/code&gt; environment” functionality. Another famous one is &lt;code&gt;Free&lt;/code&gt;, which takes a functor &lt;code&gt;f&lt;/code&gt; and enhances it with “sequential binding” capabilities: it turns &lt;code&gt;f&lt;/code&gt; into a &lt;code&gt;Monad&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The main thing that distinguishes these functor combinators from things like monad transformers is that they are “natural on &lt;code&gt;f&lt;/code&gt;”: they work on &lt;em&gt;all&lt;/em&gt; &lt;code&gt;f&lt;/code&gt;s, not just monads, and assume no structure (not even &lt;code&gt;Functor&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Sometimes, we have binary functor combinators, like &lt;code&gt;:+:&lt;/code&gt;, which takes two functors &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; and returns a functor that is “either” &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;g&lt;/code&gt;. Binary functor combinators “mix together” the functionality of different functors in different ways.&lt;/p&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;p&gt;If your final DSL/program/schema is some functor, then functor combinators allow you to construct your final functor by combining simpler “primitive” functors, and take advantage of common functionality.&lt;/p&gt;
&lt;p&gt;For example, if you were making a data type/EDSL to describe a command line argument parser, you might have two primitives: &lt;code&gt;data Arg a&lt;/code&gt;, for positional arguments parsing &lt;code&gt;a&lt;/code&gt;, and &lt;code&gt;data Option a&lt;/code&gt;, for &lt;code&gt;--flag&lt;/code&gt; non-positional options parsing &lt;code&gt;a&lt;/code&gt;. From there, you can &lt;em&gt;choose&lt;/em&gt; what structure of command line arguments you want to be able to express.&lt;/p&gt;
&lt;p&gt;For instance, a structure that can support multiple arguments and optionally a single &lt;code&gt;Option&lt;/code&gt; would be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CommandArgs&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Arg&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Option&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And a structure that supports &lt;em&gt;multiple named commands&lt;/em&gt; on top of that would be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CommandArgs&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Arg&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Option&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can mix or match combinators to decide exactly what sort of structures you allow in your DSL.&lt;/p&gt;
&lt;p&gt;Now, instead of writing one “giant” &lt;code&gt;runParser :: MapF String (Ap Arg :*: Lift Option) a -&amp;gt; IO a&lt;/code&gt; function, you can instead just write parsers for your simple primitives &lt;code&gt;Arg a -&amp;gt; IO a&lt;/code&gt; and &lt;code&gt;Option a -&amp;gt; IO a&lt;/code&gt;, and then use functor combinator tools to “promote” them to being runnable on a full &lt;code&gt;MapF String (Ap Arg :*: Lift Option)&lt;/code&gt; without any extra work.&lt;/p&gt;
&lt;h3 id=&#34;common-functionality&#34;&gt;Common Functionality&lt;/h3&gt;
&lt;p&gt;Most of these functor combinators allow us to “swap out” the underlying functor, retaining all of the “enhanced” structure. We abstract over all of these using &lt;code&gt;hmap&lt;/code&gt; for single-argument functor combinators (“enhancers”) and &lt;code&gt;hbimap&lt;/code&gt; for two-argument functor combinators (“mixers”).&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFunctor&lt;/span&gt; t &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;co&#34;&gt;-- | Swap out underlying functor for a single-argument functor combinator&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;    hmap&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x)&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t f a&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t g a&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HBifunctor&lt;/span&gt; t &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;co&#34;&gt;-- | Swap out underlying functors for a two-argument functor combinator&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;    hbimap&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; h x)&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; g x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; j x)&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t f g a&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t h j a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, for this post, the concept of a “natural transformation” between &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; — a function of type &lt;code&gt;forall x. f x -&amp;gt; g x&lt;/code&gt;, is given a type synonym:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then the type signatures of &lt;code&gt;hmap&lt;/code&gt; and &lt;code&gt;hbimap&lt;/code&gt; become:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFunctor&lt;/span&gt; t &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;    hmap&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t g&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HBifunctor&lt;/span&gt; t &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-7&#34;&gt;&lt;a href=&#34;#cb5-7&#34;&gt;&lt;/a&gt;    hbimap&lt;/span&gt;
&lt;span id=&#34;cb5-8&#34;&gt;&lt;a href=&#34;#cb5-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;
&lt;span id=&#34;cb5-9&#34;&gt;&lt;a href=&#34;#cb5-9&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; j&lt;/span&gt;
&lt;span id=&#34;cb5-10&#34;&gt;&lt;a href=&#34;#cb5-10&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t f g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t h j&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What does it mean exactly when we say that &lt;code&gt;hmap&lt;/code&gt; and &lt;code&gt;hbimap&lt;/code&gt; “preserve the enhanced structure”? Well, for example, the type &lt;code&gt;newtype ListF f a = ListF [f a]&lt;/code&gt; is essentially a list of &lt;code&gt;f a&lt;/code&gt;s. &lt;code&gt;hmap&lt;/code&gt; will swap out and replace each &lt;code&gt;f a&lt;/code&gt;, but it must &lt;em&gt;preserve the relative order&lt;/em&gt; between each of the original &lt;code&gt;f a&lt;/code&gt;s. It must also preserve the &lt;em&gt;length&lt;/em&gt; of the list. It’s a complete “in-place swap”. This is formalizing by requiring &lt;code&gt;hmap id == id&lt;/code&gt; and &lt;code&gt;hbimap id id == id&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can also always “lift” a functor value into its transformed type. We abstract over this by using &lt;code&gt;inject&lt;/code&gt; (for single-argument functors) and &lt;code&gt;inL&lt;/code&gt; and &lt;code&gt;inR&lt;/code&gt; (for two-argument functors):&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- single argument functor combinators&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inject ::&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t f&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- two-argument functor combinators&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inL ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt; t i f&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t f g&lt;/span&gt;
&lt;span id=&#34;cb6-7&#34;&gt;&lt;a href=&#34;#cb6-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-8&#34;&gt;&lt;a href=&#34;#cb6-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inR ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt; t i g&lt;/span&gt;
&lt;span id=&#34;cb6-9&#34;&gt;&lt;a href=&#34;#cb6-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t f g&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, in order to &lt;em&gt;use&lt;/em&gt; any functor combinators, you have to &lt;em&gt;interpret&lt;/em&gt; them into some target context. The choice of combinator imposes some constraints on the target context. We abstract over this using &lt;code&gt;interpret&lt;/code&gt; and &lt;code&gt;binterpret&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;co&#34;&gt;-- | Interpret unary functor combinator&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-3&#34;&gt;&lt;a href=&#34;#cb7-3&#34;&gt;&lt;/a&gt;    interpret&lt;/span&gt;
&lt;span id=&#34;cb7-4&#34;&gt;&lt;a href=&#34;#cb7-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f             &lt;span class=&#34;co&#34;&gt;-- ^ interpreting function&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-5&#34;&gt;&lt;a href=&#34;#cb7-5&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb7-6&#34;&gt;&lt;a href=&#34;#cb7-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-7&#34;&gt;&lt;a href=&#34;#cb7-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; t i f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-8&#34;&gt;&lt;a href=&#34;#cb7-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;co&#34;&gt;-- | Interpret binary functor combinator&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-9&#34;&gt;&lt;a href=&#34;#cb7-9&#34;&gt;&lt;/a&gt;    binterpret&lt;/span&gt;
&lt;span id=&#34;cb7-10&#34;&gt;&lt;a href=&#34;#cb7-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f             &lt;span class=&#34;co&#34;&gt;-- ^ interpreting function on g&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-11&#34;&gt;&lt;a href=&#34;#cb7-11&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f             &lt;span class=&#34;co&#34;&gt;-- ^ interpreting function on h&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb7-12&#34;&gt;&lt;a href=&#34;#cb7-12&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Having the typeclass &lt;code&gt;Interpret&lt;/code&gt; (and &lt;code&gt;SemigroupIn&lt;/code&gt;) take both &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; means that there are certain limits on what sort of &lt;code&gt;f&lt;/code&gt; you can interpret into.&lt;/p&gt;
&lt;p&gt;One nice consequence of this approach is that for many such schemas/functors you build, there might be many &lt;em&gt;useful&lt;/em&gt; target functors. For example, if you build a command line argument parser schema, you might want to run it in &lt;code&gt;Const String&lt;/code&gt; to build up a “help message”, or you might want to run it in &lt;code&gt;Parser&lt;/code&gt; to parse the actual arguments or run pure tests, or you might want to run it in &lt;code&gt;IO&lt;/code&gt; to do interactive parsing.&lt;/p&gt;
&lt;p&gt;For some concrete examples of these functor combinators and their constraints:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb8-5&#34;&gt;&lt;a href=&#34;#cb8-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb8-6&#34;&gt;&lt;a href=&#34;#cb8-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb8-7&#34;&gt;&lt;a href=&#34;#cb8-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb8-8&#34;&gt;&lt;a href=&#34;#cb8-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-9&#34;&gt;&lt;a href=&#34;#cb8-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb8-10&#34;&gt;&lt;a href=&#34;#cb8-10&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-11&#34;&gt;&lt;a href=&#34;#cb8-11&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb8-12&#34;&gt;&lt;a href=&#34;#cb8-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb8-13&#34;&gt;&lt;a href=&#34;#cb8-13&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb8-14&#34;&gt;&lt;a href=&#34;#cb8-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; h) a&lt;/span&gt;
&lt;span id=&#34;cb8-15&#34;&gt;&lt;a href=&#34;#cb8-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that &lt;code&gt;interpret&lt;/code&gt; lets you “run” a &lt;code&gt;Free&lt;/code&gt; in any monad &lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;binterpret&lt;/code&gt; lets you “run” a function over both &lt;em&gt;branches&lt;/em&gt; of an &lt;code&gt;g :+: h&lt;/code&gt; to produce an &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;From these, we can also build a lot of useful utility functions (like &lt;code&gt;retract&lt;/code&gt;, &lt;code&gt;biretract&lt;/code&gt;, &lt;code&gt;getI&lt;/code&gt;, &lt;code&gt;biget&lt;/code&gt;, etc.) for convenience in actually working on them. These are provided in &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators&#34;&gt;functor-combinators&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Without further ado, let’s dive into the zoo of functor combinators!&lt;/p&gt;
&lt;h2 id=&#34;two-argument&#34;&gt;Two-Argument&lt;/h2&gt;
&lt;p&gt;Binary functor combinators “mix together” two functors/indexed types in different ways.&lt;/p&gt;
&lt;p&gt;We can finally &lt;em&gt;interpret&lt;/em&gt; (or “run”) these into some target context (like &lt;code&gt;Parser&lt;/code&gt;, or &lt;code&gt;IO&lt;/code&gt;), provided the target satisfies some constraints.&lt;/p&gt;
&lt;p&gt;For the most part, binary functor combinators &lt;code&gt;t&lt;/code&gt; are instances of both &lt;code&gt;Associative t&lt;/code&gt; and &lt;code&gt;Tensor t i&lt;/code&gt;. Every &lt;code&gt;t&lt;/code&gt; is associated with &lt;code&gt;i&lt;/code&gt;, which is the “identity” functor that leaves &lt;code&gt;f&lt;/code&gt; unchanged: &lt;code&gt;t f i&lt;/code&gt; is the same as &lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;t i f&lt;/code&gt; is the same as &lt;code&gt;f&lt;/code&gt; as well.&lt;/p&gt;
&lt;p&gt;For example, we have &lt;code&gt;Comp&lt;/code&gt;, which is functor composition:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; (f (g a))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have an instance &lt;code&gt;Associative Comp&lt;/code&gt; and &lt;code&gt;Tensor Comp Identity&lt;/code&gt;, because &lt;code&gt;Comp f Identity&lt;/code&gt; (composing any functor with &lt;code&gt;Identity&lt;/code&gt;, &lt;code&gt;f (Identity a)&lt;/code&gt;) is just the same as &lt;code&gt;f a&lt;/code&gt; (the original functor); also, &lt;code&gt;Comp Identity f&lt;/code&gt; (or &lt;code&gt;Identity (f a)&lt;/code&gt;) is the same as &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;From there, some functors support being “merged” (interpreted, or collapsed) from a binary functor combinator, or being able to be injected “into” a binary functor combinator. Those functors &lt;code&gt;f&lt;/code&gt; have instances &lt;code&gt;SemigroupIn t f&lt;/code&gt; and &lt;code&gt;MonoidIn t i f&lt;/code&gt;. If a functor &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;SemigroupIn t f&lt;/code&gt;, we can &lt;code&gt;interpret&lt;/code&gt; out of it:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;binterpret&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; t f&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb10-5&#34;&gt;&lt;a href=&#34;#cb10-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (t g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb10-6&#34;&gt;&lt;a href=&#34;#cb10-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-7&#34;&gt;&lt;a href=&#34;#cb10-7&#34;&gt;&lt;/a&gt;biretract&lt;/span&gt;
&lt;span id=&#34;cb10-8&#34;&gt;&lt;a href=&#34;#cb10-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; t f&lt;/span&gt;
&lt;span id=&#34;cb10-9&#34;&gt;&lt;a href=&#34;#cb10-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; t f f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And if a functor &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;MonoidIn t i f&lt;/code&gt;, we can “inject” into it:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;pureT&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt; t i f&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; i &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-5&#34;&gt;&lt;a href=&#34;#cb11-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inL ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt; t i g&lt;/span&gt;
&lt;span id=&#34;cb11-6&#34;&gt;&lt;a href=&#34;#cb11-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t f g&lt;/span&gt;
&lt;span id=&#34;cb11-7&#34;&gt;&lt;a href=&#34;#cb11-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-8&#34;&gt;&lt;a href=&#34;#cb11-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;inR ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt; t i f&lt;/span&gt;
&lt;span id=&#34;cb11-9&#34;&gt;&lt;a href=&#34;#cb11-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t f g&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A more detailed run-down is available in the docs for &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html&#34;&gt;Data.Functor.Combinator&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;One interesting property of these is that for tensors, if we have a binary functor combinator &lt;code&gt;*&lt;/code&gt;, we can represent a type &lt;code&gt;f | f * f | f * f * f | f * f * f * f | ...&lt;/code&gt; (“repeatedly apply to something multiple times”), which essentially forms a linked list along that functor combinator. This is like a linked list with &lt;code&gt;t&lt;/code&gt; as the “cons” operation, so we call this &lt;code&gt;ListBy t&lt;/code&gt;. We can also make a “non-empty variant”, &lt;code&gt;NonEmptyBy t&lt;/code&gt;, which contains “at least one &lt;code&gt;f&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;For example, the type that is either &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;f a&lt;/code&gt;, &lt;code&gt;f (f a)&lt;/code&gt;, &lt;code&gt;f (f (f a))&lt;/code&gt;, etc. is &lt;code&gt;Free f a&lt;/code&gt;, so that &lt;code&gt;type ListBy Comp = Free&lt;/code&gt;. The type that is either &lt;code&gt;f a&lt;/code&gt;, &lt;code&gt;f (f a)&lt;/code&gt;, &lt;code&gt;f (f (f a))&lt;/code&gt;, etc. (at least one layer of &lt;code&gt;f&lt;/code&gt;) is &lt;code&gt;Free1 f a&lt;/code&gt;, so &lt;code&gt;type NonEmptyBy Comp = Free1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;functor-combinators&lt;/em&gt; provides functions like &lt;code&gt;toListBy :: t f f ~&amp;gt; ListBy t f&lt;/code&gt; to abstract over “converting” back and forth between &lt;code&gt;t f f a&lt;/code&gt; and linked list version &lt;code&gt;ListBy t f a&lt;/code&gt; (for example, between &lt;code&gt;Comp f f a&lt;/code&gt; and &lt;code&gt;Free f a&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&#34;sum&#34;&gt;:+: / Sum&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/GHC-Generics.html&#34;&gt;GHC.Generics&lt;/a&gt;&lt;/em&gt; (for &lt;code&gt;:+:&lt;/code&gt;) / &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Sum.html&#34;&gt;Data.Functor.Sum&lt;/a&gt;&lt;/em&gt; (for &lt;code&gt;Sum&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Either-or”: provide either case, and user has to handle both possibilities. Basically higher-order &lt;code&gt;Either&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; g) a&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; (f a)&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (g a)&lt;/span&gt;
&lt;span id=&#34;cb12-4&#34;&gt;&lt;a href=&#34;#cb12-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-5&#34;&gt;&lt;a href=&#34;#cb12-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Sum&lt;/span&gt; f g a&lt;/span&gt;
&lt;span id=&#34;cb12-6&#34;&gt;&lt;a href=&#34;#cb12-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;InL&lt;/span&gt; (f a)&lt;/span&gt;
&lt;span id=&#34;cb12-7&#34;&gt;&lt;a href=&#34;#cb12-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;InR&lt;/span&gt; (g a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It can be useful for situations where you can validly use one or the other in your schema or functor. For example, if you are describing an HTTP request, we could have &lt;code&gt;data GET a&lt;/code&gt; describing a GET request and &lt;code&gt;data POST a&lt;/code&gt; describing a POST request; &lt;code&gt;(GET :+: POST) a&lt;/code&gt; would be a functor that describes either a GET or POST request.&lt;/p&gt;
&lt;p&gt;The person who creates the &lt;code&gt;f :+: g&lt;/code&gt; decides which one to give, and the person who consumes/interprets/runs the &lt;code&gt;f :+: g&lt;/code&gt; must provide a way of handling &lt;em&gt;both&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb13-3&#34;&gt;&lt;a href=&#34;#cb13-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb13-4&#34;&gt;&lt;a href=&#34;#cb13-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; h) a&lt;/span&gt;
&lt;span id=&#34;cb13-5&#34;&gt;&lt;a href=&#34;#cb13-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;binterpret&lt;/code&gt; becomes analogous to &lt;code&gt;either&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Either.html&#34;&gt;Data.Either&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Data type with no inhabitants&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;f :+: V1&lt;/code&gt; is equivalent to just &lt;code&gt;f&lt;/code&gt;, because you can never have a value of the right branch.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;) f&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb15-5&#34;&gt;&lt;a href=&#34;#cb15-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb15-6&#34;&gt;&lt;a href=&#34;#cb15-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb15-7&#34;&gt;&lt;a href=&#34;#cb15-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; h) a&lt;/span&gt;
&lt;span id=&#34;cb15-8&#34;&gt;&lt;a href=&#34;#cb15-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb15-9&#34;&gt;&lt;a href=&#34;#cb15-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-10&#34;&gt;&lt;a href=&#34;#cb15-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:+:) ::&lt;/span&gt; f     &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb15-11&#34;&gt;&lt;a href=&#34;#cb15-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:+:) ::&lt;/span&gt; g     &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb15-12&#34;&gt;&lt;a href=&#34;#cb15-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:+:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;All&lt;/em&gt; haskell functors are monoids in &lt;code&gt;:+:&lt;/code&gt;. You can call &lt;code&gt;binterpret&lt;/code&gt;, &lt;code&gt;inL&lt;/code&gt;, &lt;code&gt;inR&lt;/code&gt;, etc. with anything.&lt;/p&gt;
&lt;p&gt;However, note that &lt;code&gt;pureT&lt;/code&gt; is effectively impossible to call, because no values of type &lt;code&gt;V1 a&lt;/code&gt; exist.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt;     (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Step&lt;/code&gt; is the result of an infinite application of &lt;code&gt;:+:&lt;/code&gt; to the same value:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;...&lt;/span&gt; etc&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- actual implementation&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;  {&lt;span class=&#34;ot&#34;&gt; stepPos ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Natural&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-6&#34;&gt;&lt;a href=&#34;#cb17-6&#34;&gt;&lt;/a&gt;  ,&lt;span class=&#34;ot&#34;&gt; stepVal ::&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb17-7&#34;&gt;&lt;a href=&#34;#cb17-7&#34;&gt;&lt;/a&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The correspondence is:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; x           &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; y)      &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; y&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; z)) &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; z&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- etc.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s not a particularly useful type, but it can be useful if you want to provide an &lt;code&gt;f a&lt;/code&gt; alongside “which position” it is on the infinite list.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;product&#34;&gt;:*: / Product&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/GHC-Generics.html&#34;&gt;GHC.Generics&lt;/a&gt;&lt;/em&gt; (for &lt;code&gt;:*:&lt;/code&gt;) / &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Product.html&#34;&gt;Data.Functor.Product&lt;/a&gt;&lt;/em&gt; (for &lt;code&gt;Product&lt;/code&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Both, separately”: provide values from &lt;em&gt;both&lt;/em&gt; functors, and the user can choose which one they want to use. Basically a higher-order tuple.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; g) a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; f a &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; g a&lt;/span&gt;
&lt;span id=&#34;cb19-2&#34;&gt;&lt;a href=&#34;#cb19-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-3&#34;&gt;&lt;a href=&#34;#cb19-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Product&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Pair&lt;/span&gt; (f a) (g a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It can be useful for situations where your schema/functor must be &lt;em&gt;specified&lt;/em&gt; using &lt;em&gt;both&lt;/em&gt; functors, but the &lt;em&gt;interpreter&lt;/em&gt; can choose to use only one or the other (or both).&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;prodOutL ::&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; g) &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;prodOutL (x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; _) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb20-3&#34;&gt;&lt;a href=&#34;#cb20-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-4&#34;&gt;&lt;a href=&#34;#cb20-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;prodOutR ::&lt;/span&gt; (f &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; g) &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb20-5&#34;&gt;&lt;a href=&#34;#cb20-5&#34;&gt;&lt;/a&gt;prodOutR (_ &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; y) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Data type with only a single constructor and no information&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;f :*: Proxy&lt;/code&gt; is equivalent to just &lt;code&gt;f&lt;/code&gt;, because the left hand side doesn’t add anything extra to the pair.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) f&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb22-5&#34;&gt;&lt;a href=&#34;#cb22-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-6&#34;&gt;&lt;a href=&#34;#cb22-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-7&#34;&gt;&lt;a href=&#34;#cb22-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-8&#34;&gt;&lt;a href=&#34;#cb22-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; h) &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb22-9&#34;&gt;&lt;a href=&#34;#cb22-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-10&#34;&gt;&lt;a href=&#34;#cb22-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:*:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f     &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb22-11&#34;&gt;&lt;a href=&#34;#cb22-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:*:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g     &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb22-12&#34;&gt;&lt;a href=&#34;#cb22-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:*:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; h &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt;, from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Alt.html&#34;&gt;Data.Functor.Alt&lt;/a&gt;&lt;/em&gt; in &lt;em&gt;semigroupoids&lt;/em&gt;, can be thought of a “higher-kinded semigroup”: it’s like &lt;code&gt;Alternative&lt;/code&gt;, but with no &lt;code&gt;Applicative&lt;/code&gt; constraint and no identity:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    (&amp;lt;!&amp;gt;) ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is used to combine the results in both branches of the &lt;code&gt;:*:&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To introduce an “empty” branch, we need &lt;code&gt;Plus&lt;/code&gt; (in &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Plus.html&#34;&gt;Data.Functor.Plus&lt;/a&gt;&lt;/em&gt;), which is like a higher-kinded &lt;code&gt;Monoid&lt;/code&gt;, or &lt;code&gt;Alternative&lt;/code&gt; with no &lt;code&gt;Applicative&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    zero ::&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt;     (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ListF f a&lt;/code&gt; is a “list of &lt;code&gt;f a&lt;/code&gt;s”. It represents the possibility of having &lt;code&gt;Proxy&lt;/code&gt; (zero items), &lt;code&gt;x :: f a&lt;/code&gt; (one item), &lt;code&gt;x :*: y&lt;/code&gt; (two items), &lt;code&gt;x :*: y :*: z&lt;/code&gt; (three items), etc.&lt;/p&gt;
&lt;p&gt;It’s basically an ordered collection of &lt;code&gt;f a&lt;/code&gt;s &lt;code&gt;:*:&lt;/code&gt;d with each other.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;         &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; []&lt;/span&gt;
&lt;span id=&#34;cb26-2&#34;&gt;&lt;a href=&#34;#cb26-2&#34;&gt;&lt;/a&gt;x             &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x]&lt;/span&gt;
&lt;span id=&#34;cb26-3&#34;&gt;&lt;a href=&#34;#cb26-3&#34;&gt;&lt;/a&gt;x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; y       &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x,y]&lt;/span&gt;
&lt;span id=&#34;cb26-4&#34;&gt;&lt;a href=&#34;#cb26-4&#34;&gt;&lt;/a&gt;x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; y &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; z &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x,y,z]&lt;/span&gt;
&lt;span id=&#34;cb26-5&#34;&gt;&lt;a href=&#34;#cb26-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- etc.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is useful if you want to define a schema where you can offer &lt;em&gt;multiple&lt;/em&gt; options for the &lt;code&gt;f a&lt;/code&gt;, and the interpreter/consumer can freely pick any one that they want to use.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NonEmptyF&lt;/code&gt; is the version of &lt;code&gt;ListF&lt;/code&gt; that has “at least one &lt;code&gt;f a&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;See the information later on &lt;code&gt;ListF&lt;/code&gt; alone (in the single-argument functor combinator section) for more information on usage and utility.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;day&#34;&gt;Day&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Day.html&#34;&gt;Data.Functor.Day&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Both, together forever”: provide values from &lt;em&gt;both&lt;/em&gt; functors, and the user &lt;em&gt;must&lt;/em&gt; also &lt;em&gt;use&lt;/em&gt; both.&lt;/p&gt;
&lt;p&gt;It can be useful for situations where your schema/functor must be &lt;em&gt;specified&lt;/em&gt; using &lt;em&gt;both&lt;/em&gt; functors, and the user must also &lt;em&gt;use&lt;/em&gt; both.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-2&#34;&gt;&lt;a href=&#34;#cb27-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt; f          &lt;span class=&#34;co&#34;&gt;-- superclass of Applicative&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-3&#34;&gt;&lt;a href=&#34;#cb27-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb27-4&#34;&gt;&lt;a href=&#34;#cb27-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb27-5&#34;&gt;&lt;a href=&#34;#cb27-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike for &lt;code&gt;:*:&lt;/code&gt;, you always have to interpret &lt;em&gt;both&lt;/em&gt; functor values in order to interpret a &lt;code&gt;Day&lt;/code&gt;. It’s a “full mixing”.&lt;/p&gt;
&lt;p&gt;The mechanism for this is interesting in and of itself. Looking at the definition of the data type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x y&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; (f x) (g y) (x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We see that because &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are “hidden” from the external world, we can’t directly use them without applying the “joining” function &lt;code&gt;x -&amp;gt; y -&amp;gt; a&lt;/code&gt;. Due to how existential types work, we can’t get anything out of it that “contains” &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;. Because of this, &lt;em&gt;using&lt;/em&gt; the joining function requires &lt;em&gt;both&lt;/em&gt; &lt;code&gt;f x&lt;/code&gt; and &lt;code&gt;g y&lt;/code&gt;. If we only use &lt;code&gt;f x&lt;/code&gt;, we can only get, at best,&lt;code&gt;f (y -&amp;gt; a)&lt;/code&gt;; if we only use &lt;code&gt;g y&lt;/code&gt;, we can only get, at best, &lt;code&gt;g (x -&amp;gt; a)&lt;/code&gt;. In order to fully eliminate &lt;em&gt;both&lt;/em&gt; existential variables, we need to get the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; from &lt;em&gt;both&lt;/em&gt; &lt;code&gt;f x&lt;/code&gt; and &lt;code&gt;g y&lt;/code&gt;, as if the two values held separate halves of the key.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Day f Identity&lt;/code&gt; is equivalent to just &lt;code&gt;f&lt;/code&gt;, because &lt;code&gt;Identity&lt;/code&gt; adds no extra effects or structure.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb30&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb30-1&#34;&gt;&lt;a href=&#34;#cb30-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt;       f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb30-2&#34;&gt;&lt;a href=&#34;#cb30-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb30-3&#34;&gt;&lt;a href=&#34;#cb30-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb30-4&#34;&gt;&lt;a href=&#34;#cb30-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb30-5&#34;&gt;&lt;a href=&#34;#cb30-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb30-6&#34;&gt;&lt;a href=&#34;#cb30-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb30-7&#34;&gt;&lt;a href=&#34;#cb30-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb30-8&#34;&gt;&lt;a href=&#34;#cb30-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb30-9&#34;&gt;&lt;a href=&#34;#cb30-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb30-10&#34;&gt;&lt;a href=&#34;#cb30-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f        &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb30-11&#34;&gt;&lt;a href=&#34;#cb30-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g        &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb30-12&#34;&gt;&lt;a href=&#34;#cb30-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; h &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Apply&lt;/code&gt;, from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Apply.html&#34;&gt;Data.Functor.Apply&lt;/a&gt;&lt;/em&gt; in &lt;em&gt;semigroupoids&lt;/em&gt;, is “&lt;code&gt;Applicative&lt;/code&gt; without &lt;code&gt;pure&lt;/code&gt;”; it only has &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; (called &lt;code&gt;&amp;lt;.&amp;gt;&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pureT&lt;/code&gt; is essentially &lt;code&gt;pure :: Applicative h =&amp;gt; a -&amp;gt; h a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb31&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb31-1&#34;&gt;&lt;a href=&#34;#cb31-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-2&#34;&gt;&lt;a href=&#34;#cb31-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt;     &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Ap f a&lt;/code&gt; is a bunch of &lt;code&gt;f x&lt;/code&gt;s &lt;code&gt;Day&lt;/code&gt;d with each other. It is either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; (zero &lt;code&gt;f&lt;/code&gt;s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f a&lt;/code&gt; (one &lt;code&gt;f&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Day f f a&lt;/code&gt; (two &lt;code&gt;f&lt;/code&gt;s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Day f (Day f f) a&lt;/code&gt; (three &lt;code&gt;f&lt;/code&gt;s)&lt;/li&gt;
&lt;li&gt;.. etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Like &lt;code&gt;ListF&lt;/code&gt; this is very useful if you want your schema to provide a “bag” of &lt;code&gt;f a&lt;/code&gt;s and your interpreter &lt;em&gt;must use all of them&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, if we have a schema for a command line argument parser, each &lt;code&gt;f&lt;/code&gt; may represent a command line option. To interpret it, we must look at &lt;em&gt;all&lt;/em&gt; command line options.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ap1&lt;/code&gt; is a version with “at least one” &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the information later on &lt;code&gt;Ap&lt;/code&gt; alone (in the single-argument functor combinator section) for more information on usage and utility.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;comp&#34;&gt;Comp&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Monad-Freer-Church.html&#34;&gt;Control.Monad.Freer.Church&lt;/a&gt;&lt;/em&gt;. Note that an equivalent type is also found in &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/GHC-Generics.html&#34;&gt;GHC.Generics&lt;/a&gt;&lt;/em&gt; and &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Compose.html&#34;&gt;Data.Functor.Compose&lt;/a&gt;&lt;/em&gt;, but they are incompatible with the &lt;code&gt;HBifunctor&lt;/code&gt; typeclass because they require the second input to have a &lt;code&gt;Functor&lt;/code&gt; instance.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Both, together, sequentially” : provide values from &lt;em&gt;both&lt;/em&gt; functors; the user must &lt;em&gt;use&lt;/em&gt; both, and &lt;em&gt;in order&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb32&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb32-1&#34;&gt;&lt;a href=&#34;#cb32-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; (f (g a))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It can be useful for situations where your schema/functor must be specified using both functors, and the user must &lt;em&gt;use&lt;/em&gt; both, but also enforcing that they must use both in the &lt;em&gt;given order&lt;/em&gt;: that is, for a &lt;code&gt;Comp f g&lt;/code&gt;, they interpret &lt;code&gt;f&lt;/code&gt; &lt;em&gt;before&lt;/em&gt; they interpret &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb33&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb33-1&#34;&gt;&lt;a href=&#34;#cb33-1&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-2&#34;&gt;&lt;a href=&#34;#cb33-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt; f          &lt;span class=&#34;co&#34;&gt;-- superclass of Monad&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-3&#34;&gt;&lt;a href=&#34;#cb33-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb33-4&#34;&gt;&lt;a href=&#34;#cb33-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb33-5&#34;&gt;&lt;a href=&#34;#cb33-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unlike for &lt;code&gt;:*:&lt;/code&gt;, you always have to interpret &lt;em&gt;both&lt;/em&gt; functor values. And, unlike for &lt;code&gt;Day&lt;/code&gt;, you must interpret both functor values &lt;em&gt;in that order&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb34&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb34-1&#34;&gt;&lt;a href=&#34;#cb34-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Comp f Identity&lt;/code&gt; is equivalent to just &lt;code&gt;f&lt;/code&gt;, because &lt;code&gt;Identity&lt;/code&gt; adds no extra effects or structure.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb35&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb35-1&#34;&gt;&lt;a href=&#34;#cb35-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb35-2&#34;&gt;&lt;a href=&#34;#cb35-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb35-3&#34;&gt;&lt;a href=&#34;#cb35-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-4&#34;&gt;&lt;a href=&#34;#cb35-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-5&#34;&gt;&lt;a href=&#34;#cb35-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb35-6&#34;&gt;&lt;a href=&#34;#cb35-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb35-7&#34;&gt;&lt;a href=&#34;#cb35-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb35-8&#34;&gt;&lt;a href=&#34;#cb35-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb35-9&#34;&gt;&lt;a href=&#34;#cb35-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-10&#34;&gt;&lt;a href=&#34;#cb35-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f        &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb35-11&#34;&gt;&lt;a href=&#34;#cb35-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g        &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb35-12&#34;&gt;&lt;a href=&#34;#cb35-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; h &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Bind&lt;/code&gt;, from &lt;em&gt;[Data.Functor.Bind][]&lt;/em&gt; in &lt;em&gt;semigroupoids&lt;/em&gt;, is “&lt;code&gt;Monad&lt;/code&gt; without &lt;code&gt;return&lt;/code&gt;”; it only has &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (called &lt;code&gt;&amp;gt;&amp;gt;-&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Somewhat serendipitously, the constraint associated with monoids in &lt;code&gt;Comp&lt;/code&gt; is none other than the infamous &lt;code&gt;Monad&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This might sound familiar to your ears — it’s the realization of the joke that “monads are monoids in the category of (endo)functors”. The idea is that we can make a tensor like &lt;code&gt;Comp&lt;/code&gt; over functors, and that “monoids in” that tensor correspond exactly to &lt;code&gt;Monad&lt;/code&gt; instances. A part of the joke that we can now also see is that monads aren’t the &lt;em&gt;only&lt;/em&gt; monoids in the category of endofunctors: they’re just the ones that you get when you tensor over &lt;code&gt;Comp&lt;/code&gt;. But we see now that if you use &lt;code&gt;Day&lt;/code&gt; as your tensor, then “monoids in the category of functors over &lt;code&gt;Day&lt;/code&gt;” are actually &lt;code&gt;Applicative&lt;/code&gt; instances! And that the monoids over &lt;code&gt;:*:&lt;/code&gt; are &lt;code&gt;Alt&lt;/code&gt; instances, etc.&lt;/p&gt;
&lt;p&gt;Theory aside, hopefully this insight also gives you some insight on the nature of &lt;code&gt;Monad&lt;/code&gt; as an abstraction: it’s a way to “interpret” in and out of &lt;code&gt;Comp&lt;/code&gt;, which enforces an ordering in interpretation :)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb36&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb36-1&#34;&gt;&lt;a href=&#34;#cb36-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-2&#34;&gt;&lt;a href=&#34;#cb36-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;LIstBy&lt;/span&gt;     &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Free f a&lt;/code&gt; is a bunch of &lt;code&gt;f x&lt;/code&gt;s composed with each other. It is either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; (zero &lt;code&gt;f&lt;/code&gt;s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f a&lt;/code&gt; (one &lt;code&gt;f&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f (f a)&lt;/code&gt; (two &lt;code&gt;f&lt;/code&gt;s)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f (f (f a))&lt;/code&gt; (three &lt;code&gt;f&lt;/code&gt;s)&lt;/li&gt;
&lt;li&gt;.. etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Free&lt;/code&gt; is very useful because it allows you to specify that your schema can have many &lt;code&gt;f&lt;/code&gt;s, sequenced one after the other, in which the &lt;em&gt;choice&lt;/em&gt; of “the next &lt;code&gt;f&lt;/code&gt;” is allowed to depend on the &lt;em&gt;result&lt;/em&gt; of “the previous &lt;code&gt;f&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;For example, in an interactive “wizard” sort of schema, we can have a functor representing a dialog box with its result type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb37&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb37-1&#34;&gt;&lt;a href=&#34;#cb37-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dialog&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can then represent our wizard using &lt;code&gt;Free Dialog a&lt;/code&gt; — an ordered sequence of dialog boxes, where the choice of the next box can depend on result of the previous box.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Free1&lt;/code&gt; is a version with “at least one” &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the information later on &lt;code&gt;Free&lt;/code&gt; alone (in the single-argument functor combinator section) for more information on usage and utility.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let us pause for a brief aside to compare and contrast the hierarchy of the above functor combinators, as there is an interesting progression we can draw from them.&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;code&gt;:+:&lt;/code&gt;: Provide either, be ready for both.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:*:&lt;/code&gt;: Provide both, be ready for either.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Day&lt;/code&gt;: Provide both, be ready for both.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Comp&lt;/code&gt;: Provide both, be ready for both (in order).&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;h3 id=&#34;these1&#34;&gt;These1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/these/docs/Data-Functor-These.html&#34;&gt;Data.Functor.These&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Either-or, or both”: provide either (or both) cases, and user has to handle both possibilities. An “inclusive either”&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb38&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb38-1&#34;&gt;&lt;a href=&#34;#cb38-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt; f g a&lt;/span&gt;
&lt;span id=&#34;cb38-2&#34;&gt;&lt;a href=&#34;#cb38-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;This1&lt;/span&gt;  (f a)&lt;/span&gt;
&lt;span id=&#34;cb38-3&#34;&gt;&lt;a href=&#34;#cb38-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;That1&lt;/span&gt;        (g a)&lt;/span&gt;
&lt;span id=&#34;cb38-4&#34;&gt;&lt;a href=&#34;#cb38-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt; (f a) (g a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can be useful for situations where your schema/functor can be specified using one functor or another, or even both. See description on &lt;code&gt;:+:&lt;/code&gt; for examples.&lt;/p&gt;
&lt;p&gt;The person who creates the &lt;code&gt;These1 f g&lt;/code&gt; decides which one to give, and the person who consumes/interprets/runs the &lt;code&gt;f :+: g&lt;/code&gt; must provide a way of handling &lt;em&gt;both&lt;/em&gt; situations.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb39&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb39-1&#34;&gt;&lt;a href=&#34;#cb39-1&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;These&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-2&#34;&gt;&lt;a href=&#34;#cb39-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb39-3&#34;&gt;&lt;a href=&#34;#cb39-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb39-4&#34;&gt;&lt;a href=&#34;#cb39-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb39-5&#34;&gt;&lt;a href=&#34;#cb39-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These&lt;/span&gt; g h a&lt;/span&gt;
&lt;span id=&#34;cb39-6&#34;&gt;&lt;a href=&#34;#cb39-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can also pattern match on the &lt;code&gt;These1&lt;/code&gt; directly to be more explicit with how you handle each of the tree cases.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb40&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb40-1&#34;&gt;&lt;a href=&#34;#cb40-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;These1 f V1&lt;/code&gt; is equivalent to just &lt;code&gt;f&lt;/code&gt;, because it means the &lt;code&gt;That1&lt;/code&gt; and &lt;code&gt;These1&lt;/code&gt; branches will be impossible to construct, and you are left with only the &lt;code&gt;This1&lt;/code&gt; branch.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb41&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb41-1&#34;&gt;&lt;a href=&#34;#cb41-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb41-2&#34;&gt;&lt;a href=&#34;#cb41-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb41-3&#34;&gt;&lt;a href=&#34;#cb41-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-4&#34;&gt;&lt;a href=&#34;#cb41-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;These&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-5&#34;&gt;&lt;a href=&#34;#cb41-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb41-6&#34;&gt;&lt;a href=&#34;#cb41-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb41-7&#34;&gt;&lt;a href=&#34;#cb41-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb41-8&#34;&gt;&lt;a href=&#34;#cb41-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb41-9&#34;&gt;&lt;a href=&#34;#cb41-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-10&#34;&gt;&lt;a href=&#34;#cb41-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f  &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb41-11&#34;&gt;&lt;a href=&#34;#cb41-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g  &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb41-12&#34;&gt;&lt;a href=&#34;#cb41-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; h &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;V1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You need at least &lt;code&gt;Alt&lt;/code&gt; to be able to interpret out of a &lt;code&gt;These1&lt;/code&gt;, because you need to be able to handle the case where you have &lt;em&gt;both&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;, and need to combine the result. However, you never need a full &lt;code&gt;Plus&lt;/code&gt; because we always have at least one value to use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb42&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb42-1&#34;&gt;&lt;a href=&#34;#cb42-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Steps&lt;/code&gt;, the list type, is the result of an infinite application of &lt;code&gt;These1&lt;/code&gt; to the same value:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb43&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb43-1&#34;&gt;&lt;a href=&#34;#cb43-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;`These1`&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;`These1`&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;`These1`&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;`These1`&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;...&lt;/span&gt; etc&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-2&#34;&gt;&lt;a href=&#34;#cb43-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-3&#34;&gt;&lt;a href=&#34;#cb43-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- actual implementation&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-4&#34;&gt;&lt;a href=&#34;#cb43-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;NEMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Natural&lt;/span&gt; (f a))&lt;/span&gt;
&lt;span id=&#34;cb43-5&#34;&gt;&lt;a href=&#34;#cb43-5&#34;&gt;&lt;/a&gt;                &lt;span class=&#34;co&#34;&gt;-- NEMap is a non-empty Map&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It essentially represents an infinite &lt;em&gt;sparse&lt;/em&gt; array of &lt;code&gt;f a&lt;/code&gt;s, where an &lt;code&gt;f a&lt;/code&gt; might exist at many different positions, with gaps here and there. There is always at least &lt;em&gt;one&lt;/em&gt; &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Like &lt;code&gt;Step&lt;/code&gt;, it’s not particularly useful, but it can be used in situations where you want a giant infinite sparse array of &lt;code&gt;f a&lt;/code&gt;s, each at a given position, with many gaps between them.&lt;/p&gt;
&lt;p&gt;I’ve skipped over the the “non-empty” version, which is &lt;code&gt;ComposeT Flagged Steps&lt;/code&gt;; it requires an extra boolean “flag” because of some of the quirks of nonemptiness. I feel it is even less useful than &lt;code&gt;Steps&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;leftf-rightf&#34;&gt;LeftF / RightF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HBifunctor.html&#34;&gt;Data.HBifunctor&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Ignore the left” / “ignore the right”.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb44&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb44-1&#34;&gt;&lt;a href=&#34;#cb44-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;LeftF&lt;/span&gt;  f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;LeftF&lt;/span&gt;  {&lt;span class=&#34;ot&#34;&gt; runLeftF  ::&lt;/span&gt; f a }&lt;/span&gt;
&lt;span id=&#34;cb44-2&#34;&gt;&lt;a href=&#34;#cb44-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb44-3&#34;&gt;&lt;a href=&#34;#cb44-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RightF&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RightF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runRightF ::&lt;/span&gt; g a }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can think of &lt;code&gt;LeftF&lt;/code&gt; as “&lt;code&gt;:+:&lt;/code&gt; without the Right case, &lt;code&gt;R1&lt;/code&gt;”, or &lt;code&gt;RightF&lt;/code&gt; as “&lt;code&gt;:+:&lt;/code&gt; without the Left case, &lt;code&gt;L1&lt;/code&gt;”. &lt;code&gt;RightF&lt;/code&gt; can be considered a higher-order version of &lt;em&gt;Tagged&lt;/em&gt;, which “tags” a value with some type-level information.&lt;/p&gt;
&lt;p&gt;This can be useful if you want the second (or first) argument to be ignored, and only be used maybe at the type level.&lt;/p&gt;
&lt;p&gt;For example, &lt;code&gt;RightF IgnoreMe MyFunctor&lt;/code&gt; is equivalent to just &lt;code&gt;MyFunctor&lt;/code&gt;, but you might want to use &lt;code&gt;IgnoreMe&lt;/code&gt; as a phantom type to help limit what values can be used for what functions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Unlike the previous functor combinators, these three are only &lt;code&gt;Associative&lt;/code&gt;, not &lt;code&gt;Tensor&lt;/code&gt;: this is because there is no functor &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;LeftF i g&lt;/code&gt; is equal to &lt;code&gt;g&lt;/code&gt;, for all &lt;code&gt;g&lt;/code&gt;, and no functor &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;RightF f i&lt;/code&gt; is equal to &lt;code&gt;f&lt;/code&gt;, for all &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Constraints&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb45&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb45-1&#34;&gt;&lt;a href=&#34;#cb45-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;LeftF&lt;/span&gt;  f&lt;/span&gt;
&lt;span id=&#34;cb45-2&#34;&gt;&lt;a href=&#34;#cb45-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RightF&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of either of these is unconstrained, and can be done in any context.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb46&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb46-1&#34;&gt;&lt;a href=&#34;#cb46-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;LeftF&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Flagged&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;LeftF&lt;/code&gt;, the non-empty list type is &lt;code&gt;Flagged&lt;/code&gt;, which is the &lt;code&gt;f a&lt;/code&gt; tupled with a &lt;code&gt;Bool&lt;/code&gt;. See the information on &lt;code&gt;Flagged&lt;/code&gt; for more details. This can be useful as a type that marks if an &lt;code&gt;f&lt;/code&gt; is made with &lt;code&gt;inject&lt;/code&gt;/&lt;code&gt;pure&lt;/code&gt; and is “pure” (&lt;code&gt;False&lt;/code&gt;), or “tainted” (&lt;code&gt;True&lt;/code&gt;). The &lt;em&gt;provider&lt;/em&gt; of a &lt;code&gt;Flagged&lt;/code&gt; can specify “pure or tainted”, and the &lt;em&gt;interpreter&lt;/em&gt; can make a decision based on that tag.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb47&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb47-1&#34;&gt;&lt;a href=&#34;#cb47-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RightF&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;RightF&lt;/code&gt;, the non-empty list type is &lt;code&gt;Step&lt;/code&gt;. See &lt;code&gt;Step&lt;/code&gt; and the information on &lt;code&gt;:+:&lt;/code&gt; for more details. This can be useful for having a value of &lt;code&gt;f a&lt;/code&gt; at “some point”, indexed by a &lt;code&gt;Natural&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;single-argument&#34;&gt;Single-Argument&lt;/h2&gt;
&lt;p&gt;Unary functor combinators usually directly “enhance” a functor with extra capabilities — usually in the form of a typeclass instance, or extra data fields/constructors.&lt;/p&gt;
&lt;p&gt;All of these can be “lifted into” with any constraint on &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb48&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb48-1&#34;&gt;&lt;a href=&#34;#cb48-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFunctor&lt;/span&gt; t &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Inject&lt;/span&gt; t &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb48-2&#34;&gt;&lt;a href=&#34;#cb48-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    inject ::&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; t f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Inject&lt;/code&gt; seems very similar to &lt;code&gt;MonadTrans&lt;/code&gt;’s &lt;code&gt;lift&lt;/code&gt;; the difference is that &lt;code&gt;inject&lt;/code&gt; must be &lt;em&gt;natural&lt;/em&gt; on &lt;code&gt;f&lt;/code&gt;: it can assume nothing about the structure of &lt;code&gt;f&lt;/code&gt;, and must work universally the same. &lt;code&gt;MonadTrans&lt;/code&gt;, in contrast, requires &lt;code&gt;Monad f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Each one can also be “interpreted to” certain functors &lt;code&gt;f&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb49&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb49-1&#34;&gt;&lt;a href=&#34;#cb49-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Inject&lt;/span&gt; t &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb49-2&#34;&gt;&lt;a href=&#34;#cb49-2&#34;&gt;&lt;/a&gt;    interpret&lt;/span&gt;
&lt;span id=&#34;cb49-3&#34;&gt;&lt;a href=&#34;#cb49-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;        ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb49-4&#34;&gt;&lt;a href=&#34;#cb49-4&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;An important law is that:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb50&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb50-1&#34;&gt;&lt;a href=&#34;#cb50-1&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; inject &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This means that if we inject and immediately interpret out of, we should never &lt;em&gt;lose&lt;/em&gt; any information in &lt;code&gt;f&lt;/code&gt;. All of the original structure in &lt;code&gt;f&lt;/code&gt; must stay intact: functor combinators only ever &lt;em&gt;add&lt;/em&gt; structure.&lt;/p&gt;
&lt;h3 id=&#34;coyoneda&#34;&gt;Coyoneda&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Coyoneda.html&#34;&gt;Data.Functor.Coyoneda&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to map over the parameter; it’s the free &lt;code&gt;Functor&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Can be useful if &lt;code&gt;f&lt;/code&gt; is created using a &lt;code&gt;GADT&lt;/code&gt; that cannot be given a &lt;code&gt;Functor&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;For example, here is an indexed type that represents the type of a “form element”, where the type parameter represents the output result of the form element.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb51&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb51-1&#34;&gt;&lt;a href=&#34;#cb51-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-2&#34;&gt;&lt;a href=&#34;#cb51-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;FInput&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-3&#34;&gt;&lt;a href=&#34;#cb51-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;FTextbox&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Text&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-4&#34;&gt;&lt;a href=&#34;#cb51-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;FCheckbox&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb51-5&#34;&gt;&lt;a href=&#34;#cb51-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;FNumber&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;   ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then &lt;code&gt;Coyoneda FormElem&lt;/code&gt; has a &lt;code&gt;Functor&lt;/code&gt; instance. We can now fmap over the result type of the form element; for example, &lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; Coyoneda FormElem a -&amp;gt; Coyoneda FormElem b&lt;/code&gt; takes a form element whose result is an &lt;code&gt;a&lt;/code&gt; and returns a form element whose result is a &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb52&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb52-1&#34;&gt;&lt;a href=&#34;#cb52-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb52-2&#34;&gt;&lt;a href=&#34;#cb52-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-3&#34;&gt;&lt;a href=&#34;#cb52-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb52-4&#34;&gt;&lt;a href=&#34;#cb52-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb52-5&#34;&gt;&lt;a href=&#34;#cb52-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb52-6&#34;&gt;&lt;a href=&#34;#cb52-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Coyoneda f&lt;/code&gt; requires the target context to itself be &lt;code&gt;Functor&lt;/code&gt;. Usually, the context is an &lt;code&gt;Applicative&lt;/code&gt; or &lt;code&gt;Monad&lt;/code&gt;, so this is typically always satisfied.&lt;/p&gt;
&lt;p&gt;For example, if we want to “run” a &lt;code&gt;Coyoneda FormElem&lt;/code&gt; in &lt;code&gt;IO&lt;/code&gt; (maybe as an interactive CLI form), this would be &lt;code&gt;interpret :: (forall x. FormElem x -&amp;gt; IO x) -&amp;gt; Coyoneda FormElem a -&amp;gt; IO a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;listf-nonemptyf&#34;&gt;ListF / NonEmptyF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-ListF.html&#34;&gt;Control.Applicative.ListF&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to offer multiple options for the interpreter to pick from; &lt;code&gt;ListF&lt;/code&gt; is the free &lt;code&gt;Plus&lt;/code&gt;, and &lt;code&gt;NonEmptyF&lt;/code&gt; is the free &lt;code&gt;Alt&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb53&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb53-1&#34;&gt;&lt;a href=&#34;#cb53-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;     f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;     {&lt;span class=&#34;ot&#34;&gt; runListF     ::&lt;/span&gt; [f a]          }&lt;/span&gt;
&lt;span id=&#34;cb53-2&#34;&gt;&lt;a href=&#34;#cb53-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runNonEmptyF ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmpty&lt;/span&gt; (f a) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can be useful if you want to provide the ability when you &lt;em&gt;define&lt;/em&gt; your schema to provide multiple &lt;code&gt;f a&lt;/code&gt;s that the &lt;em&gt;interpreter&lt;/em&gt;/consumer can freely pick from.&lt;/p&gt;
&lt;p&gt;For example, for a schema specifying a form, you might have multiple ways to enter a name. If you had a &lt;code&gt;Name&lt;/code&gt; schema &lt;code&gt;data Name a&lt;/code&gt;, then you can represent “many different potential name inputs” schema as &lt;code&gt;ListF Name a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Because this has a &lt;code&gt;Plus&lt;/code&gt; instance, you can use &lt;code&gt;(&amp;lt;!&amp;gt;) :: ListF f a -&amp;gt; ListF f a -&amp;gt; ListF f a&lt;/code&gt; to combine multiple option sets, and &lt;code&gt;zero :: ListF f a&lt;/code&gt; to provide the “choice that always fails/is unusuable”.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NonEmptyF&lt;/code&gt; is a variety of &lt;code&gt;ListF&lt;/code&gt; where you always have “at least one &lt;code&gt;f a&lt;/code&gt;”. Can be useful if you want to ensure, for your interpreter’s sake, that you always have at least one &lt;code&gt;f a&lt;/code&gt; option to pick from. For example, &lt;code&gt;NonEmptyF Name a&lt;/code&gt; will always have at least &lt;em&gt;one&lt;/em&gt; name schema.&lt;/p&gt;
&lt;p&gt;This is essentially &lt;code&gt;f&lt;/code&gt; &lt;code&gt;:*:&lt;/code&gt;d with itself multiple times; &lt;code&gt;ListF&lt;/code&gt; is the linked list list made by &lt;code&gt;:*:&lt;/code&gt;, and &lt;code&gt;NonEmptyF&lt;/code&gt; is the non-empty linked list made by &lt;code&gt;:*:&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb54&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb54-1&#34;&gt;&lt;a href=&#34;#cb54-1&#34;&gt;&lt;/a&gt;x             &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x]     &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; (x &lt;span class=&#34;op&#34;&gt;:|&lt;/span&gt; [])&lt;/span&gt;
&lt;span id=&#34;cb54-2&#34;&gt;&lt;a href=&#34;#cb54-2&#34;&gt;&lt;/a&gt;x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; y       &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x,y]   &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; (x &lt;span class=&#34;op&#34;&gt;:|&lt;/span&gt; [y])&lt;/span&gt;
&lt;span id=&#34;cb54-3&#34;&gt;&lt;a href=&#34;#cb54-3&#34;&gt;&lt;/a&gt;x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; y &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; z &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x,y,z] &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; (x &lt;span class=&#34;op&#34;&gt;:|&lt;/span&gt; [y,z])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb55&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb55-1&#34;&gt;&lt;a href=&#34;#cb55-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;     f&lt;/span&gt;
&lt;span id=&#34;cb55-2&#34;&gt;&lt;a href=&#34;#cb55-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb55-3&#34;&gt;&lt;a href=&#34;#cb55-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb55-4&#34;&gt;&lt;a href=&#34;#cb55-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb55-5&#34;&gt;&lt;a href=&#34;#cb55-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb55-6&#34;&gt;&lt;a href=&#34;#cb55-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb55-7&#34;&gt;&lt;a href=&#34;#cb55-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb55-8&#34;&gt;&lt;a href=&#34;#cb55-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb55-9&#34;&gt;&lt;a href=&#34;#cb55-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb55-10&#34;&gt;&lt;a href=&#34;#cb55-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb55-11&#34;&gt;&lt;a href=&#34;#cb55-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb55-12&#34;&gt;&lt;a href=&#34;#cb55-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;ListF f&lt;/code&gt; requires the target context to be &lt;code&gt;Plus&lt;/code&gt;, and interpreting out of a &lt;code&gt;NonEmptyF f&lt;/code&gt; requires &lt;code&gt;Alt&lt;/code&gt; (because you will never have the empty case). However, you always have the option to directly pattern match on the list and pick an item you want directly, which requires no constraint.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ap-ap1&#34;&gt;Ap / Ap1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Applicative-Free.html&#34;&gt;Control.Applicative.Free&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Apply-Free.html&#34;&gt;Data.Functor.Apply.Free&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s that the interpreter &lt;em&gt;must&lt;/em&gt; consume &lt;em&gt;all&lt;/em&gt; of; &lt;code&gt;Ap&lt;/code&gt; is the free &lt;code&gt;Applicative&lt;/code&gt;, and &lt;code&gt;Ap1&lt;/code&gt; is the free &lt;code&gt;Apply&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While &lt;code&gt;ListF&lt;/code&gt; may be considered “multiple options &lt;em&gt;offered&lt;/em&gt;”, &lt;code&gt;Ap&lt;/code&gt; can be considered “multiple actions all &lt;em&gt;required&lt;/em&gt;”. The interpreter must consume/interpret &lt;em&gt;all&lt;/em&gt; of the multiple &lt;code&gt;f&lt;/code&gt;s in order to interpret an &lt;code&gt;Ap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, for a form schema, you might want to have multiple form elements. If a single form element is &lt;code&gt;data FormElem a&lt;/code&gt;, then you can make a multi-form schema with &lt;code&gt;Ap FormElem a&lt;/code&gt;. The consumer of the form schema must handle &lt;em&gt;every&lt;/em&gt; &lt;code&gt;FormElem&lt;/code&gt; provided.&lt;/p&gt;
&lt;p&gt;Note that ordering is not enforced: while the consumer must handle each &lt;code&gt;f&lt;/code&gt; eventually, they are free to handle it in whatever order they desire. In fact, they could even all be handled in parallel. See &lt;code&gt;Free&lt;/code&gt; for a version where ordering is enforced.&lt;/p&gt;
&lt;p&gt;Because this has an &lt;code&gt;Applicative&lt;/code&gt; instance, you can use &lt;code&gt;(&amp;lt;*&amp;gt;) :: Ap f (a -&amp;gt; b) -&amp;gt; Ap f a -&amp;gt; Ap f b&lt;/code&gt; to sequence multiple &lt;code&gt;Ap f&lt;/code&gt;s together, and &lt;code&gt;pure :: a -&amp;gt; Ap f a&lt;/code&gt; to produce a “no-op” &lt;code&gt;Ap&lt;/code&gt; without any &lt;code&gt;f&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ap&lt;/code&gt; has some utility over &lt;code&gt;Free&lt;/code&gt; in that you can pattern match on the constructors directly and look at each individual sequenced &lt;code&gt;f a&lt;/code&gt;, for static analysis, before anything is ever run or interpreted.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Structurally&lt;/em&gt;, &lt;code&gt;Ap&lt;/code&gt; is built like a linked list of &lt;code&gt;f x&lt;/code&gt;s, which each link being existentially bound together:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb56&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb56-1&#34;&gt;&lt;a href=&#34;#cb56-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb56-2&#34;&gt;&lt;a href=&#34;#cb56-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Pure&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; a   &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb56-3&#34;&gt;&lt;a href=&#34;#cb56-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;   ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; f b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Pure&lt;/code&gt; is like “nil”, and &lt;code&gt;Ap&lt;/code&gt; is like “cons”:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb57&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb57-1&#34;&gt;&lt;a href=&#34;#cb57-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb57-2&#34;&gt;&lt;a href=&#34;#cb57-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Nil&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb57-3&#34;&gt;&lt;a href=&#34;#cb57-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Cons&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;List&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The existential type in the &lt;code&gt;Ap&lt;/code&gt; branch plays the same role that it does in the definition of &lt;code&gt;Day&lt;/code&gt; (see the description of &lt;code&gt;Day&lt;/code&gt; for more information).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ap1&lt;/code&gt; is a variety of &lt;code&gt;Ap&lt;/code&gt; where you always have to have “at least one &lt;code&gt;f&lt;/code&gt;”. Can be useful if you want to ensure, for example, that your form has at least one element.&lt;/p&gt;
&lt;p&gt;Note that this is essentially &lt;code&gt;f&lt;/code&gt; &lt;code&gt;Day&lt;/code&gt;d with itself multiple times; &lt;code&gt;Ap&lt;/code&gt; is the linked list made by &lt;code&gt;Day&lt;/code&gt; and &lt;code&gt;Ap1&lt;/code&gt; is the non-empty linked list made by &lt;code&gt;Day&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb58&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb58-1&#34;&gt;&lt;a href=&#34;#cb58-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;  f&lt;/span&gt;
&lt;span id=&#34;cb58-2&#34;&gt;&lt;a href=&#34;#cb58-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt;       f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb58-3&#34;&gt;&lt;a href=&#34;#cb58-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-4&#34;&gt;&lt;a href=&#34;#cb58-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-5&#34;&gt;&lt;a href=&#34;#cb58-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb58-6&#34;&gt;&lt;a href=&#34;#cb58-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb58-7&#34;&gt;&lt;a href=&#34;#cb58-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb58-8&#34;&gt;&lt;a href=&#34;#cb58-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-9&#34;&gt;&lt;a href=&#34;#cb58-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Ap1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb58-10&#34;&gt;&lt;a href=&#34;#cb58-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb58-11&#34;&gt;&lt;a href=&#34;#cb58-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb58-12&#34;&gt;&lt;a href=&#34;#cb58-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap1&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of an &lt;code&gt;Ap f&lt;/code&gt; requires the target context to be &lt;code&gt;Applicative&lt;/code&gt;, and interpreting out of a &lt;code&gt;Ap1 f&lt;/code&gt; requires &lt;code&gt;Apply&lt;/code&gt; (because you will never need the pure case).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;alt&#34;&gt;Alt&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Alternative-Free.html&#34;&gt;Control.Alternative.Free&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: A combination of both &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;Ap&lt;/code&gt;: provide a choice (&lt;code&gt;ListF&lt;/code&gt;-style) of sequences (&lt;code&gt;Ap&lt;/code&gt;-style) of choices of sequences of choices ….; it’s the free &lt;code&gt;Alternative&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb59&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb59-1&#34;&gt;&lt;a href=&#34;#cb59-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;...&lt;/span&gt;))))&lt;/span&gt;
&lt;span id=&#34;cb59-2&#34;&gt;&lt;a href=&#34;#cb59-2&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This type imbues &lt;code&gt;f&lt;/code&gt; with both sequential “must use both” operations (via &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;) and choice-like “can use either” operations (via &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;It can be useful for implementing parser schemas, which often involve both sequential and choice-like combinations. If &lt;code&gt;f&lt;/code&gt; is a primitive parsing unit, then &lt;code&gt;Alt f&lt;/code&gt; represents a non-deterministic parser of a bunch of &lt;code&gt;f&lt;/code&gt;s one after the other, with multiple possible results. I wrote &lt;a href=&#34;https://blog.jle.im/entry/free-alternative-regexp.html&#34;&gt;an entire article&lt;/a&gt; on the usage of this combinator alone to implement a version of regular expressions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb60&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb60-1&#34;&gt;&lt;a href=&#34;#cb60-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alternative&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb60-2&#34;&gt;&lt;a href=&#34;#cb60-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb60-3&#34;&gt;&lt;a href=&#34;#cb60-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb60-4&#34;&gt;&lt;a href=&#34;#cb60-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alternative&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb60-5&#34;&gt;&lt;a href=&#34;#cb60-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb60-6&#34;&gt;&lt;a href=&#34;#cb60-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of an &lt;code&gt;Alt f&lt;/code&gt; requires the target context to be &lt;code&gt;Alternative&lt;/code&gt; — it uses &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; for sequencing, and &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; for choice.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;free-free1&#34;&gt;Free / Free1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Monad-Freer-Church.html&#34;&gt;Control.Monad.Freer.Church&lt;/a&gt;&lt;/em&gt;, which is a variant of &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/free/docs/Control-Monad-Free.html&#34;&gt;Control.Monad.Free&lt;/a&gt;&lt;/em&gt; that is compatible with &lt;code&gt;HFunctor&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s that the interpreter must consume &lt;em&gt;in order&lt;/em&gt;, sequentially — the free &lt;code&gt;Monad&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Contrast with &lt;code&gt;Ap&lt;/code&gt;, which also sequences multiple &lt;code&gt;f&lt;/code&gt;s together, but without any enforced order. It does this by &lt;em&gt;hiding&lt;/em&gt; the “next &lt;code&gt;f a&lt;/code&gt;” until the previous &lt;code&gt;f a&lt;/code&gt; has already been interpreted.&lt;/p&gt;
&lt;p&gt;Perhaps more importantly, you can sequence &lt;code&gt;f&lt;/code&gt;s in a way where the &lt;em&gt;choice of the next &lt;code&gt;f&lt;/code&gt;&lt;/em&gt; is allowed to depend on the &lt;em&gt;result of the previous &lt;code&gt;f&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For example, in an interactive “wizard” sort of schema, we can create a functor to represent a dialog box with its result type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb61&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb61-1&#34;&gt;&lt;a href=&#34;#cb61-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dialog&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can then construct a type for a wizard:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb62&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb62-1&#34;&gt;&lt;a href=&#34;#cb62-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Wizard&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dialog&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Wizard&lt;/code&gt; is now an ordered sequence of dialog boxes, where the choice of the next box can depend on result of the previous box. Contrast to &lt;code&gt;Ap Dialog&lt;/code&gt;, where the choice of all dialog boxes must be made in advanced, up-front, before reading any input from the user.&lt;/p&gt;
&lt;p&gt;In having this, however, we loose the ability to be able to inspect each &lt;code&gt;f a&lt;/code&gt; before interpreting anything.&lt;/p&gt;
&lt;p&gt;Because this has a &lt;code&gt;Monad&lt;/code&gt; instance, you can use &lt;code&gt;(&amp;lt;*&amp;gt;) :: Free f (a -&amp;gt; b) -&amp;gt; Free f a -&amp;gt; Free f b&lt;/code&gt; and &lt;code&gt;(&amp;gt;&amp;gt;=) :: Free f a -&amp;gt; (a -&amp;gt; Free f b) -&amp;gt; Free f b)&lt;/code&gt; to sequence multiple &lt;code&gt;Free f&lt;/code&gt;s together, and &lt;code&gt;pure :: a -&amp;gt; Free f a&lt;/code&gt; to produce a “no-op” &lt;code&gt;Free&lt;/code&gt; without any &lt;code&gt;f&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Free1&lt;/code&gt; is a variety of &lt;code&gt;Free1&lt;/code&gt; where you always have to have “at least one &lt;code&gt;f&lt;/code&gt;”. Can be useful if you want to ensure, for example, that your wizard has at least one dialog box.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb63&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb63-1&#34;&gt;&lt;a href=&#34;#cb63-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyWizard&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dialog&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this is essentially &lt;code&gt;f&lt;/code&gt; &lt;code&gt;Comp&lt;/code&gt;d with itself multiple times; &lt;code&gt;Free&lt;/code&gt; is the linked list made by &lt;code&gt;Comp&lt;/code&gt; and &lt;code&gt;Free1&lt;/code&gt; is the non-empty linked list made by &lt;code&gt;Comp&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb64&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb64-1&#34;&gt;&lt;a href=&#34;#cb64-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt;  f&lt;/span&gt;
&lt;span id=&#34;cb64-2&#34;&gt;&lt;a href=&#34;#cb64-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb64-3&#34;&gt;&lt;a href=&#34;#cb64-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb64-4&#34;&gt;&lt;a href=&#34;#cb64-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb64-5&#34;&gt;&lt;a href=&#34;#cb64-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb64-6&#34;&gt;&lt;a href=&#34;#cb64-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb64-7&#34;&gt;&lt;a href=&#34;#cb64-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb64-8&#34;&gt;&lt;a href=&#34;#cb64-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb64-9&#34;&gt;&lt;a href=&#34;#cb64-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb64-10&#34;&gt;&lt;a href=&#34;#cb64-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb64-11&#34;&gt;&lt;a href=&#34;#cb64-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb64-12&#34;&gt;&lt;a href=&#34;#cb64-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Free f&lt;/code&gt; requires the target context to be &lt;code&gt;Monad&lt;/code&gt;, and interpreting out of a &lt;code&gt;Free1 f&lt;/code&gt; requires &lt;code&gt;Bind&lt;/code&gt; (because you will never need the pure case).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lift-maybeapply&#34;&gt;Lift / MaybeApply&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/transformers/docs/Control-Applicative-Lift.html&#34;&gt;Control.Applicative.Lift&lt;/a&gt;&lt;/em&gt; / &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Apply.html&#34;&gt;Data.Functor.Apply&lt;/a&gt;&lt;/em&gt; (the same type)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Make &lt;code&gt;f&lt;/code&gt; “optional” in the schema in a way that the interpreter can still work with as if the &lt;code&gt;f&lt;/code&gt; was still there; it’s the free &lt;code&gt;Pointed&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb65&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb65-1&#34;&gt;&lt;a href=&#34;#cb65-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Pure&lt;/span&gt;  a&lt;/span&gt;
&lt;span id=&#34;cb65-2&#34;&gt;&lt;a href=&#34;#cb65-2&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Other&lt;/span&gt; (f a)&lt;/span&gt;
&lt;span id=&#34;cb65-3&#34;&gt;&lt;a href=&#34;#cb65-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb65-4&#34;&gt;&lt;a href=&#34;#cb65-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MaybeApply&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MaybeApply&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runMaybeApply ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; a (f a) }&lt;/span&gt;
&lt;span id=&#34;cb65-5&#34;&gt;&lt;a href=&#34;#cb65-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;co&#34;&gt;-- ^ same type, from semigroupoids&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can be useful so that an &lt;code&gt;f a&lt;/code&gt; is &lt;em&gt;optional&lt;/em&gt; for the schema definition, but in a way where the consumer can still continue from it as if they &lt;em&gt;had&lt;/em&gt; the &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It can be used, for example, to turn an required parameter &lt;code&gt;Param a&lt;/code&gt; into an optional parameter &lt;code&gt;Lift Param a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Contrast this to &lt;code&gt;MaybeF&lt;/code&gt;: this allows the interpreter to still “continue on” as normal even if the &lt;code&gt;f&lt;/code&gt; is not there. However, &lt;code&gt;MaybeF&lt;/code&gt; forces the interpreter to abort if the &lt;code&gt;f&lt;/code&gt; is not there.&lt;/p&gt;
&lt;p&gt;This can be thought of as &lt;code&gt;Identity :+: f&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb66&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb66-1&#34;&gt;&lt;a href=&#34;#cb66-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Pointed&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb66-2&#34;&gt;&lt;a href=&#34;#cb66-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb66-3&#34;&gt;&lt;a href=&#34;#cb66-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb66-4&#34;&gt;&lt;a href=&#34;#cb66-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Pointed&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb66-5&#34;&gt;&lt;a href=&#34;#cb66-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb66-6&#34;&gt;&lt;a href=&#34;#cb66-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Lift f&lt;/code&gt; requires the target context to be &lt;code&gt;Pointed&lt;/code&gt;, from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/pointed/docs/Data-Pointed.html&#34;&gt;Data.Pointed&lt;/a&gt;&lt;/em&gt; — it uses &lt;code&gt;point :: Pointed f =&amp;gt; a -&amp;gt; f a&lt;/code&gt; to handle the case where the &lt;code&gt;f&lt;/code&gt; is not there.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;maybef&#34;&gt;MaybeF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-ListF.html&#34;&gt;Control.Applicative.ListF&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Make &lt;code&gt;f&lt;/code&gt; “optional” in the schema in a way that the interpreter &lt;em&gt;must fail&lt;/em&gt; if the &lt;code&gt;f&lt;/code&gt; is not present.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb67&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb67-1&#34;&gt;&lt;a href=&#34;#cb67-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MaybeF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MaybeF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runMaybeF ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; (f a) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can be useful so that an &lt;code&gt;f a&lt;/code&gt; is &lt;em&gt;optional&lt;/em&gt; for the schema definition; if the &lt;code&gt;f&lt;/code&gt; is not present, the consumer must abort the current branch, or find some other external way to continue onwards.&lt;/p&gt;
&lt;p&gt;Contrast this to &lt;code&gt;Lift&lt;/code&gt;, which is an “optional” &lt;code&gt;f&lt;/code&gt; that the consumer may continue on from.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb68&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb68-1&#34;&gt;&lt;a href=&#34;#cb68-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MaybeF&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb68-2&#34;&gt;&lt;a href=&#34;#cb68-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb68-3&#34;&gt;&lt;a href=&#34;#cb68-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;MaybeF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb68-4&#34;&gt;&lt;a href=&#34;#cb68-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb68-5&#34;&gt;&lt;a href=&#34;#cb68-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb68-6&#34;&gt;&lt;a href=&#34;#cb68-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MaybeF&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Lift f&lt;/code&gt; requires the target context to be &lt;code&gt;Plus&lt;/code&gt; — it uses &lt;code&gt;zero :: f a&lt;/code&gt; to handle the case where the &lt;code&gt;f&lt;/code&gt; is not there. Note that this is actually “over-constrained”: we really only need &lt;code&gt;zero&lt;/code&gt;, and not all of &lt;code&gt;Plus&lt;/code&gt; (which includes &lt;code&gt;&amp;lt;!&amp;gt;&lt;/code&gt;). However, there is no common typeclass in Haskell that provides this, so this is the most pragmatic choice.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;envt&#34;&gt;EnvT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/comonad/docs/Control-Comonad-Trans-Env.html&#34;&gt;Control.Comonad.Trans.Env&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Provide extra (monoidal) data alongside &lt;code&gt;f a&lt;/code&gt; that the interpreter can access. Basically tuples extra &lt;code&gt;e&lt;/code&gt; alongside the &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb69&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb69-1&#34;&gt;&lt;a href=&#34;#cb69-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvT&lt;/span&gt; e f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvT&lt;/span&gt; e (f a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can use this to basically tuple some extra data alongside an &lt;code&gt;f a&lt;/code&gt;. It can be useful if you want to provide extra information that isn’t inside the &lt;code&gt;f&lt;/code&gt; for the interpreter use for interpretation.&lt;/p&gt;
&lt;p&gt;When using &lt;code&gt;inject :: Monoid e =&amp;gt; f a -&amp;gt; EnvT e f a&lt;/code&gt;, it uses &lt;code&gt;mempty&lt;/code&gt; as the initial &lt;code&gt;e&lt;/code&gt; value.&lt;/p&gt;
&lt;p&gt;One of my personal favorite uses of &lt;code&gt;EnvT&lt;/code&gt; is the &lt;em&gt;&lt;a href=&#34;https://github.com/sharkdp/purescript-flare&#34;&gt;flare&lt;/a&gt;&lt;/em&gt; purescript library, which uses the &lt;code&gt;e&lt;/code&gt; as the observed HTML of a form, and the &lt;code&gt;f a&lt;/code&gt; as an active way to get information from a form interactively. &lt;code&gt;inject&lt;/code&gt; is used to insert an active form element without caring about its HTML representation, and &lt;code&gt;interpret&lt;/code&gt; would “run” the active elements to get the results.&lt;/p&gt;
&lt;p&gt;This type exists specialized a few times here, as well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Step&lt;/code&gt; is &lt;code&gt;EnvT (Sum Natural)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Flagged&lt;/code&gt; is &lt;code&gt;EnvT Any&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb70&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb70-1&#34;&gt;&lt;a href=&#34;#cb70-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;EnvT&lt;/span&gt; e) f&lt;/span&gt;
&lt;span id=&#34;cb70-2&#34;&gt;&lt;a href=&#34;#cb70-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb70-3&#34;&gt;&lt;a href=&#34;#cb70-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;EnvT&lt;/span&gt; e)&lt;/span&gt;
&lt;span id=&#34;cb70-4&#34;&gt;&lt;a href=&#34;#cb70-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb70-5&#34;&gt;&lt;a href=&#34;#cb70-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;EnvT&lt;/span&gt; e g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of &lt;code&gt;EnvT e&lt;/code&gt; requires no constraints.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mapf-nemapf&#34;&gt;MapF / NEMapF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-ListF.html&#34;&gt;Control.Applicative.ListF&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Contain multiple &lt;code&gt;f a&lt;/code&gt;s, each indexed at a specific &lt;em&gt;key&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb71&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb71-1&#34;&gt;&lt;a href=&#34;#cb71-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt;   k f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt;   {&lt;span class=&#34;ot&#34;&gt; runMapF ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt;   k (f a) }&lt;/span&gt;
&lt;span id=&#34;cb71-2&#34;&gt;&lt;a href=&#34;#cb71-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NEMapF&lt;/span&gt; k f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NEMapF&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runMapF ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NEMap&lt;/span&gt; k (f a) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is very similar in functionality to &lt;code&gt;ListF&lt;/code&gt; and &lt;code&gt;NonEmptyF&lt;/code&gt;, except instead of “positional” location, each &lt;code&gt;f a&lt;/code&gt; exists at a given index. &lt;code&gt;NEMapF k&lt;/code&gt; is the “non-empty” variant. You can think of this as a &lt;code&gt;ListF&lt;/code&gt; plus &lt;code&gt;EnvT&lt;/code&gt;: it’s a “container” of multiple &lt;code&gt;f a&lt;/code&gt;s, but each one exists with a given “tag” index &lt;code&gt;k&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In usage, like for &lt;code&gt;ListF&lt;/code&gt;, the &lt;em&gt;definer&lt;/em&gt; provides multiple “labeled” &lt;code&gt;f a&lt;/code&gt;s, and the &lt;em&gt;interpreter&lt;/em&gt; can choose to interpret some or all of them, with access to each labeled.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inject&lt;/code&gt; creates a singleton &lt;code&gt;Map&lt;/code&gt; at key &lt;code&gt;mempty&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is very useful in schemas that have sub-schemas indexed at specific keys. For example, in a command line argument parser, if we have a functor that represents a single command:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb72&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb72-1&#34;&gt;&lt;a href=&#34;#cb72-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can immediately promote it to be a functor representing &lt;em&gt;multiple possible&lt;/em&gt; named commands, each at a given string:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb73&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb73-1&#34;&gt;&lt;a href=&#34;#cb73-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Commands&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we can implement “git push” and “git pull” using:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb74&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb74-1&#34;&gt;&lt;a href=&#34;#cb74-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;push ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Action&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb74-2&#34;&gt;&lt;a href=&#34;#cb74-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;pull ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Action&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb74-3&#34;&gt;&lt;a href=&#34;#cb74-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb74-4&#34;&gt;&lt;a href=&#34;#cb74-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;gitCommands ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Commands&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Action&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb74-5&#34;&gt;&lt;a href=&#34;#cb74-5&#34;&gt;&lt;/a&gt;gitCOmmands &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; M.fromList &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb74-6&#34;&gt;&lt;a href=&#34;#cb74-6&#34;&gt;&lt;/a&gt;    [ (&lt;span class=&#34;st&#34;&gt;&amp;quot;push&amp;quot;&lt;/span&gt;, push)&lt;/span&gt;
&lt;span id=&#34;cb74-7&#34;&gt;&lt;a href=&#34;#cb74-7&#34;&gt;&lt;/a&gt;    , (&lt;span class=&#34;st&#34;&gt;&amp;quot;pull&amp;quot;&lt;/span&gt;, pull)&lt;/span&gt;
&lt;span id=&#34;cb74-8&#34;&gt;&lt;a href=&#34;#cb74-8&#34;&gt;&lt;/a&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is also useful for specifying things like routes in a server.&lt;/p&gt;
&lt;p&gt;This type exists specialized as &lt;code&gt;Steps&lt;/code&gt;, which is &lt;code&gt;NEMapF (Sum Natural)&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb75&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb75-1&#34;&gt;&lt;a href=&#34;#cb75-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt;  k) f&lt;/span&gt;
&lt;span id=&#34;cb75-2&#34;&gt;&lt;a href=&#34;#cb75-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;NEMap&lt;/span&gt; k) f&lt;/span&gt;
&lt;span id=&#34;cb75-3&#34;&gt;&lt;a href=&#34;#cb75-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb75-4&#34;&gt;&lt;a href=&#34;#cb75-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; k)&lt;/span&gt;
&lt;span id=&#34;cb75-5&#34;&gt;&lt;a href=&#34;#cb75-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb75-6&#34;&gt;&lt;a href=&#34;#cb75-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb75-7&#34;&gt;&lt;a href=&#34;#cb75-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb75-8&#34;&gt;&lt;a href=&#34;#cb75-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb75-9&#34;&gt;&lt;a href=&#34;#cb75-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;NEMapF&lt;/span&gt; k)&lt;/span&gt;
&lt;span id=&#34;cb75-10&#34;&gt;&lt;a href=&#34;#cb75-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb75-11&#34;&gt;&lt;a href=&#34;#cb75-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb75-12&#34;&gt;&lt;a href=&#34;#cb75-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NEMapF&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;MapF k f&lt;/code&gt; requires the target context to be &lt;code&gt;Plus&lt;/code&gt;, and interpreting out of a &lt;code&gt;NEMapF k f&lt;/code&gt; requires &lt;code&gt;Alt&lt;/code&gt; (because you will never have the empty case). However, you can directly &lt;em&gt;look up&lt;/em&gt; into the &lt;code&gt;Map&lt;/code&gt; and pick an item you want directly, which requires no constraint.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;readert&#34;&gt;ReaderT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/transformers/docs/Control-Monad-Trans-Reader.html&#34;&gt;Control.Monad.Trans.Reader&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Provide each &lt;code&gt;f a&lt;/code&gt; with access to some “environment” &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb76&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb76-1&#34;&gt;&lt;a href=&#34;#cb76-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ReaderT&lt;/span&gt; r f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ReaderT&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runReaderT ::&lt;/span&gt; r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ReaderT r&lt;/code&gt; is often used to model some form of &lt;a href=&#34;https://en.wikipedia.org/wiki/Dependency_injection&#34;&gt;dependency injection&lt;/a&gt;: it allows you to work “assuming” you had an &lt;code&gt;r&lt;/code&gt;; later, when you &lt;em&gt;run&lt;/em&gt; it, you provide the &lt;code&gt;r&lt;/code&gt;. It delays the evaluation of your final result until you provide the missing &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another way of looking at it is that it makes your entire functor have values that are &lt;em&gt;parameterized&lt;/em&gt; with an &lt;code&gt;r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, if you have a form data type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb77&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb77-1&#34;&gt;&lt;a href=&#34;#cb77-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;you can now make a form data type that is parameterized by the current server hostname:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb78&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb78-1&#34;&gt;&lt;a href=&#34;#cb78-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElemWithHost&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ReaderT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HostName&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;FormElem&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The actual structure of your &lt;code&gt;FormElem&lt;/code&gt; is deferred until you provide the &lt;code&gt;HostName&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that, unlike &lt;code&gt;ReaderT&lt;/code&gt;, most monad transformers from &lt;em&gt;transformers&lt;/em&gt; are actually &lt;em&gt;not&lt;/em&gt; valid functor combinators under our perspective here, because most of them are not &lt;em&gt;natural&lt;/em&gt; on &lt;code&gt;f&lt;/code&gt;: they require &lt;code&gt;Functor f&lt;/code&gt;, at least, to implement &lt;code&gt;inject&lt;/code&gt; or &lt;code&gt;hmap&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb79&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb79-1&#34;&gt;&lt;a href=&#34;#cb79-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonadReader&lt;/span&gt; r f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;ReaderT&lt;/span&gt; r) f&lt;/span&gt;
&lt;span id=&#34;cb79-2&#34;&gt;&lt;a href=&#34;#cb79-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb79-3&#34;&gt;&lt;a href=&#34;#cb79-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;ReaderT&lt;/span&gt; r)&lt;/span&gt;
&lt;span id=&#34;cb79-4&#34;&gt;&lt;a href=&#34;#cb79-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonadReader&lt;/span&gt; r f&lt;/span&gt;
&lt;span id=&#34;cb79-5&#34;&gt;&lt;a href=&#34;#cb79-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb79-6&#34;&gt;&lt;a href=&#34;#cb79-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ReaderT&lt;/span&gt; r g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;ReaderT r&lt;/code&gt; requires requires the target context to be &lt;code&gt;MonadReader r&lt;/code&gt;, which means it must have access to &lt;code&gt;ask :: MonadReader r f =&amp;gt; f r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In a way, &lt;code&gt;ReaderT r&lt;/code&gt; is the “free” instance of &lt;code&gt;MonadReader r&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;step&#34;&gt;Step&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html&#34;&gt;Control.Applicative.Step&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Tuples the &lt;code&gt;f a&lt;/code&gt; with an extra natural number index.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb80&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb80-1&#34;&gt;&lt;a href=&#34;#cb80-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; stepPos ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Natural&lt;/span&gt;,&lt;span class=&#34;ot&#34;&gt; stepVal ::&lt;/span&gt; f a }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is essentially a specialized &lt;code&gt;EnvT&lt;/code&gt;: it’s &lt;code&gt;EnvT (Sum Natural)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is a useful type because it can be seen as equivalent to &lt;code&gt;f :+: f :+: f :+: f :+: f ...&lt;/code&gt; forever: it’s an &lt;code&gt;f&lt;/code&gt;, but at some index. In &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html&#34;&gt;Control.Applicative.Step&lt;/a&gt;&lt;/em&gt;, we have specialized functions &lt;code&gt;stepUp&lt;/code&gt; and &lt;code&gt;stepDown&lt;/code&gt;, which allows you to “match” on the “first” &lt;code&gt;f&lt;/code&gt; in that infinite chain; it will increment and decrement the index relatively to make this work properly.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb81&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb81-1&#34;&gt;&lt;a href=&#34;#cb81-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb81-2&#34;&gt;&lt;a href=&#34;#cb81-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb81-3&#34;&gt;&lt;a href=&#34;#cb81-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb81-4&#34;&gt;&lt;a href=&#34;#cb81-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb81-5&#34;&gt;&lt;a href=&#34;#cb81-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of &lt;code&gt;Step&lt;/code&gt; requires no constraints; we just drop the &lt;code&gt;Natural&lt;/code&gt; data.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;steps&#34;&gt;Steps&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html&#34;&gt;Control.Applicative.Step&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to offer multiple &lt;em&gt;indexed&lt;/em&gt; options for the interpreter to pick from. Like &lt;code&gt;NonEmptyF&lt;/code&gt;, except with each &lt;code&gt;f a&lt;/code&gt; existing at an indexed position that the consumer/interpreter can look up or access.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb82&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb82-1&#34;&gt;&lt;a href=&#34;#cb82-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getSteps ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NEMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Natural&lt;/span&gt; (f a) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is like a mix between &lt;code&gt;NonEmptyF&lt;/code&gt; and &lt;code&gt;Step&lt;/code&gt;: multiple &lt;code&gt;f a&lt;/code&gt; options (at least one) for the consumer/interpreter to pick from. Unlike &lt;code&gt;NonEmptyF&lt;/code&gt;, each &lt;code&gt;f a&lt;/code&gt; exists at an “index” — there might be one at 0, one at 5, one at 100, etc.&lt;/p&gt;
&lt;p&gt;Another way of looking at this is like an infinite &lt;em&gt;sparse array&lt;/em&gt; of &lt;code&gt;f a&lt;/code&gt;s: it’s an inifinitely large collection where each spot may potentially have an &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Useful for “provide options that the consumer can pick from, index, or access”, like &lt;code&gt;ListF&lt;/code&gt;/&lt;code&gt;NonEmptyF&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This type can be seen as an infinite &lt;code&gt;f `These1` f `These1` f `These1` f ...&lt;/code&gt;, and along these lines, &lt;code&gt;stepsDown&lt;/code&gt; and &lt;code&gt;stepsUp&lt;/code&gt; exist inside &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html&#34;&gt;Control.Applicative.Step&lt;/a&gt;&lt;/em&gt; analogous to &lt;code&gt;stepUp&lt;/code&gt; and &lt;code&gt;stepDown&lt;/code&gt; to treat a &lt;code&gt;Steps&lt;/code&gt; in this manner.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb83&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb83-1&#34;&gt;&lt;a href=&#34;#cb83-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb83-2&#34;&gt;&lt;a href=&#34;#cb83-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb83-3&#34;&gt;&lt;a href=&#34;#cb83-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb83-4&#34;&gt;&lt;a href=&#34;#cb83-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb83-5&#34;&gt;&lt;a href=&#34;#cb83-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb83-6&#34;&gt;&lt;a href=&#34;#cb83-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of &lt;code&gt;Steps&lt;/code&gt; requires an &lt;code&gt;Alt&lt;/code&gt; to combine different possibilities. It does not require a full &lt;code&gt;Plus&lt;/code&gt; constraint because we never need &lt;code&gt;zero&lt;/code&gt;: a &lt;code&gt;Steps f a&lt;/code&gt; always has at least one &lt;code&gt;f a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;flagged&#34;&gt;Flagged&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Control-Applicative-Step.html&#34;&gt;Control.Applicative.Step&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to “tag” a functor value with a &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt; boolean value.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb84&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb84-1&#34;&gt;&lt;a href=&#34;#cb84-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Flagged&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Flagged&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; flaggedFlag ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;,&lt;span class=&#34;ot&#34;&gt; flaggedVal ::&lt;/span&gt; f a }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is essentially a specialized &lt;code&gt;EnvT&lt;/code&gt;: it’s &lt;code&gt;EnvT Any&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If created with &lt;code&gt;inject&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt;, it adds the flag &lt;code&gt;False&lt;/code&gt;. This is helpful for helping indicate if the value was created using a “pure” method like &lt;code&gt;inject&lt;/code&gt; or &lt;code&gt;pure&lt;/code&gt;, or an “impure” method (any other method, including direct construction).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb85&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb85-1&#34;&gt;&lt;a href=&#34;#cb85-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Flagged&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb85-2&#34;&gt;&lt;a href=&#34;#cb85-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb85-3&#34;&gt;&lt;a href=&#34;#cb85-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Flagged&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb85-4&#34;&gt;&lt;a href=&#34;#cb85-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb85-5&#34;&gt;&lt;a href=&#34;#cb85-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Flagged&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of &lt;code&gt;Flagged&lt;/code&gt; requires no constraints; we just drop the boolean flag.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;final&#34;&gt;Final&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Final.html&#34;&gt;Data.HFunctor.Final&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: &lt;code&gt;Final c&lt;/code&gt; will lift &lt;code&gt;f&lt;/code&gt; into a free structure of any typeclass &lt;code&gt;c&lt;/code&gt;; it will give it all of the actions/API of a typeclass for “free”. &lt;code&gt;Final c f&lt;/code&gt; is the “free &lt;code&gt;c&lt;/code&gt;” over &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb86&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb86-1&#34;&gt;&lt;a href=&#34;#cb86-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; c f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a way, this is the “ultimate free structure”: it can fully replace all other free structures of typeclasses of kind &lt;code&gt;Type -&amp;gt; Type&lt;/code&gt;. For example:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb87&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb87-1&#34;&gt;&lt;a href=&#34;#cb87-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt;  &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-2&#34;&gt;&lt;a href=&#34;#cb87-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;     &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-3&#34;&gt;&lt;a href=&#34;#cb87-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-4&#34;&gt;&lt;a href=&#34;#cb87-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;        &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-5&#34;&gt;&lt;a href=&#34;#cb87-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Ap1&lt;/span&gt;       &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-6&#34;&gt;&lt;a href=&#34;#cb87-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-7&#34;&gt;&lt;a href=&#34;#cb87-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt;     &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-8&#34;&gt;&lt;a href=&#34;#cb87-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Lift&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Pointed&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb87-9&#34;&gt;&lt;a href=&#34;#cb87-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;IdentityT&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Unconstrained&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All of these are connections are witnessed by instances of the typeclass &lt;code&gt;FreeOf&lt;/code&gt; in &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Final.html&#34;&gt;Data.HFunctor.Final&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In fact, &lt;code&gt;Final c&lt;/code&gt; is often more performant for many operations than the actual concrete free structures.&lt;/p&gt;
&lt;p&gt;The main downside is that you cannot directly pattern match on the structure of a &lt;code&gt;Final c&lt;/code&gt; the same way you can pattern match on, say, &lt;code&gt;Ap&lt;/code&gt; or &lt;code&gt;ListF&lt;/code&gt;. However, you can get often around this by using &lt;code&gt;Final Plus&lt;/code&gt; for most of your operations, and then &lt;code&gt;interpret inject&lt;/code&gt;-ing it into &lt;code&gt;ListF&lt;/code&gt; when you want to actually pattern match.&lt;/p&gt;
&lt;p&gt;You can also think of this as the “ultimate &lt;code&gt;Interpret&lt;/code&gt;”, because with &lt;code&gt;inject&lt;/code&gt; you can push &lt;code&gt;f&lt;/code&gt; into &lt;code&gt;Final c f&lt;/code&gt;, and with &lt;code&gt;interpret&lt;/code&gt; you only ever need the &lt;code&gt;c&lt;/code&gt; constraint to “run”/interpret this.&lt;/p&gt;
&lt;p&gt;So, next time you want to give an &lt;code&gt;f&lt;/code&gt; the ability to &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; and &lt;code&gt;pure&lt;/code&gt;, you can throw it into &lt;code&gt;Final Applicative&lt;/code&gt;: &lt;code&gt;f&lt;/code&gt; now gets “sequencing” abilities, and is equivalent to &lt;code&gt;Ap f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you want the API of a given typeclass &lt;code&gt;c&lt;/code&gt;, you can inject &lt;code&gt;f&lt;/code&gt; into &lt;code&gt;Final c&lt;/code&gt;, and you get the API of that typeclass for free on &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Constraint&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb88&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb88-1&#34;&gt;&lt;a href=&#34;#cb88-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; c f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; c) f&lt;/span&gt;
&lt;span id=&#34;cb88-2&#34;&gt;&lt;a href=&#34;#cb88-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb88-3&#34;&gt;&lt;a href=&#34;#cb88-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; c)&lt;/span&gt;
&lt;span id=&#34;cb88-4&#34;&gt;&lt;a href=&#34;#cb88-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; c f&lt;/span&gt;
&lt;span id=&#34;cb88-5&#34;&gt;&lt;a href=&#34;#cb88-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb88-6&#34;&gt;&lt;a href=&#34;#cb88-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Final&lt;/span&gt; c g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Final c&lt;/code&gt; requires &lt;code&gt;c&lt;/code&gt;, since that is the extra context that &lt;code&gt;f&lt;/code&gt; is lifted into.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;chain-chain1&#34;&gt;Chain / Chain1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Chain.html&#34;&gt;Data.HFunctor.Chain&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: &lt;code&gt;Chain t&lt;/code&gt; will lift &lt;code&gt;f&lt;/code&gt; into a linked list of &lt;code&gt;f&lt;/code&gt;s chained by &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb89&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb89-1&#34;&gt;&lt;a href=&#34;#cb89-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- i is intended to be the identity of t&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb89-2&#34;&gt;&lt;a href=&#34;#cb89-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Done&lt;/span&gt; (i a)&lt;/span&gt;
&lt;span id=&#34;cb89-3&#34;&gt;&lt;a href=&#34;#cb89-3&#34;&gt;&lt;/a&gt;                   &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (t f (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i f a))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example, for &lt;code&gt;:*:&lt;/code&gt;, &lt;code&gt;Chain (:*:) Proxy f&lt;/code&gt; is equivalent to one of:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb90&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb90-1&#34;&gt;&lt;a href=&#34;#cb90-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;   &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Done&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;                           &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; []&lt;/span&gt;
&lt;span id=&#34;cb90-2&#34;&gt;&lt;a href=&#34;#cb90-2&#34;&gt;&lt;/a&gt;x       &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Done&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;)              &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x]&lt;/span&gt;
&lt;span id=&#34;cb90-3&#34;&gt;&lt;a href=&#34;#cb90-3&#34;&gt;&lt;/a&gt;x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; y &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (x &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (y &lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Done&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;)) &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; [x,y]&lt;/span&gt;
&lt;span id=&#34;cb90-4&#34;&gt;&lt;a href=&#34;#cb90-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- etc.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;:+:&lt;/code&gt;, &lt;code&gt;Chain (:+:) V1 f&lt;/code&gt; is equivalent to one of:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb91&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb91-1&#34;&gt;&lt;a href=&#34;#cb91-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; x           &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; x)                         &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; x&lt;/span&gt;
&lt;span id=&#34;cb91-2&#34;&gt;&lt;a href=&#34;#cb91-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; y)      &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; y)))             &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; y&lt;/span&gt;
&lt;span id=&#34;cb91-3&#34;&gt;&lt;a href=&#34;#cb91-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; z)) &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;R1&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;More&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;L1&lt;/span&gt; z))))) &lt;span class=&#34;op&#34;&gt;&amp;lt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; z&lt;/span&gt;
&lt;span id=&#34;cb91-4&#34;&gt;&lt;a href=&#34;#cb91-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- etc.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is useful because it provides a nice uniform way to work with all “linked list over tensors”. That’s because the following types are all isomorphic:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb92&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb92-1&#34;&gt;&lt;a href=&#34;#cb92-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;)  &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb92-2&#34;&gt;&lt;a href=&#34;#cb92-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt;    &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb92-3&#34;&gt;&lt;a href=&#34;#cb92-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Free&lt;/span&gt;  &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;   &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb92-4&#34;&gt;&lt;a href=&#34;#cb92-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;  &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;)  &lt;span class=&#34;dt&#34;&gt;Void&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb92-5&#34;&gt;&lt;a href=&#34;#cb92-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Void&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This isomorphism is witnessed by &lt;code&gt;unroll&lt;/code&gt; (turn into the &lt;code&gt;Chain&lt;/code&gt;) and &lt;code&gt;reroll&lt;/code&gt; (convert back from the &lt;code&gt;Chain&lt;/code&gt;) in &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor-Chain.html&#34;&gt;Data.HFunctor.Chain&lt;/a&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We can “fold down” a &lt;code&gt;Chain t (I t) f a&lt;/code&gt; into an &lt;code&gt;f a&lt;/code&gt;, if &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;Monoidal&lt;/code&gt;, using &lt;code&gt;interpret id&lt;/code&gt;. In fact, this ability could be used as a fundamental property of monoidal nature.&lt;/p&gt;
&lt;p&gt;We also have a “non-empty” version, &lt;code&gt;Chain1&lt;/code&gt;, for non-empty linked lists over tensors:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb93&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb93-1&#34;&gt;&lt;a href=&#34;#cb93-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Done1&lt;/span&gt; (f a)&lt;/span&gt;
&lt;span id=&#34;cb93-2&#34;&gt;&lt;a href=&#34;#cb93-2&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;More1&lt;/span&gt; (t f (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t f a))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb94&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb94-1&#34;&gt;&lt;a href=&#34;#cb94-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb94-2&#34;&gt;&lt;a href=&#34;#cb94-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Ap1&lt;/span&gt;       &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb94-3&#34;&gt;&lt;a href=&#34;#cb94-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Free1&lt;/span&gt;     &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb94-4&#34;&gt;&lt;a href=&#34;#cb94-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:+:&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb94-5&#34;&gt;&lt;a href=&#34;#cb94-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Steps&lt;/span&gt;     &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;These1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb94-6&#34;&gt;&lt;a href=&#34;#cb94-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;EnvT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Any&lt;/span&gt;  &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;LeftF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb94-7&#34;&gt;&lt;a href=&#34;#cb94-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Step&lt;/span&gt;      &lt;span class=&#34;op&#34;&gt;~&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RightF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can “fold down” a &lt;code&gt;Chain1 t f a&lt;/code&gt; into an &lt;code&gt;f a&lt;/code&gt;, if &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;Semigroupoidal&lt;/code&gt;, using &lt;code&gt;interpret id&lt;/code&gt;. In fact, this ability could be used as a fundamental property of semigroupoidal nature.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;ListF&lt;/code&gt;, &lt;code&gt;Ap&lt;/code&gt;, &lt;code&gt;Free&lt;/code&gt;, &lt;code&gt;Step&lt;/code&gt;, &lt;code&gt;Steps&lt;/code&gt;, etc. can sometimes feel very different, but with &lt;code&gt;Chain&lt;/code&gt; you get a uniform interface to pattern match on (and construct) all of them in the same way.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;NonEmptyF&lt;/code&gt;, &lt;code&gt;Ap1&lt;/code&gt;, &lt;code&gt;Free1&lt;/code&gt;, &lt;code&gt;Step&lt;/code&gt;, &lt;code&gt;Flagged&lt;/code&gt;, etc. can sometimes feel very different, but with &lt;code&gt;Chain1&lt;/code&gt; you get a uniform interface to pattern match on (and construct) all of them in the same way.&lt;/p&gt;
&lt;p&gt;Universally, we can concatenate linked chains, with:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb95&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb95-1&#34;&gt;&lt;a href=&#34;#cb95-1&#34;&gt;&lt;/a&gt;appendChain&lt;/span&gt;
&lt;span id=&#34;cb95-2&#34;&gt;&lt;a href=&#34;#cb95-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; t i&lt;/span&gt;
&lt;span id=&#34;cb95-3&#34;&gt;&lt;a href=&#34;#cb95-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; t (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i f) (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i f) &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i f&lt;/span&gt;
&lt;span id=&#34;cb95-4&#34;&gt;&lt;a href=&#34;#cb95-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb95-5&#34;&gt;&lt;a href=&#34;#cb95-5&#34;&gt;&lt;/a&gt;appendChain1&lt;/span&gt;
&lt;span id=&#34;cb95-6&#34;&gt;&lt;a href=&#34;#cb95-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Associative&lt;/span&gt; t&lt;/span&gt;
&lt;span id=&#34;cb95-7&#34;&gt;&lt;a href=&#34;#cb95-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; t (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t f) (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t f) &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These operations are associative, and this property is gained from the tensor nature of &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The construction of &lt;code&gt;Chain&lt;/code&gt; is inspired by &lt;a href=&#34;http://oleg.fi/gists/posts/2018-02-21-single-free.html&#34;&gt;Oleg Grenrus’s blog post&lt;/a&gt;, and the construction of &lt;code&gt;Chain1&lt;/code&gt; is inspired by implementations of finite automata and iteratees.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb96&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb96-1&#34;&gt;&lt;a href=&#34;#cb96-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    t i f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt;  t i) f&lt;/span&gt;
&lt;span id=&#34;cb96-2&#34;&gt;&lt;a href=&#34;#cb96-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; t   f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t  ) f&lt;/span&gt;
&lt;span id=&#34;cb96-3&#34;&gt;&lt;a href=&#34;#cb96-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb96-4&#34;&gt;&lt;a href=&#34;#cb96-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i)&lt;/span&gt;
&lt;span id=&#34;cb96-5&#34;&gt;&lt;a href=&#34;#cb96-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt; t i f&lt;/span&gt;
&lt;span id=&#34;cb96-6&#34;&gt;&lt;a href=&#34;#cb96-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb96-7&#34;&gt;&lt;a href=&#34;#cb96-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; t i g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb96-8&#34;&gt;&lt;a href=&#34;#cb96-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb96-9&#34;&gt;&lt;a href=&#34;#cb96-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t)&lt;/span&gt;
&lt;span id=&#34;cb96-10&#34;&gt;&lt;a href=&#34;#cb96-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; t f&lt;/span&gt;
&lt;span id=&#34;cb96-11&#34;&gt;&lt;a href=&#34;#cb96-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb96-12&#34;&gt;&lt;a href=&#34;#cb96-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Chain&lt;/code&gt; requires only that &lt;code&gt;f&lt;/code&gt; is a monoid in &lt;code&gt;t&lt;/code&gt;. Interpreting out of a &lt;code&gt;Chain1&lt;/code&gt; requires only that &lt;code&gt;f&lt;/code&gt; is a semigroup in &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, we have:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb97&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb97-1&#34;&gt;&lt;a href=&#34;#cb97-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt;  (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;) f&lt;/span&gt;
&lt;span id=&#34;cb97-2&#34;&gt;&lt;a href=&#34;#cb97-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;)      ) f&lt;/span&gt;
&lt;span id=&#34;cb97-3&#34;&gt;&lt;a href=&#34;#cb97-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb97-4&#34;&gt;&lt;a href=&#34;#cb97-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb97-5&#34;&gt;&lt;a href=&#34;#cb97-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Plus&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb97-6&#34;&gt;&lt;a href=&#34;#cb97-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb97-7&#34;&gt;&lt;a href=&#34;#cb97-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb97-8&#34;&gt;&lt;a href=&#34;#cb97-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb97-9&#34;&gt;&lt;a href=&#34;#cb97-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&#34;cb97-10&#34;&gt;&lt;a href=&#34;#cb97-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb97-11&#34;&gt;&lt;a href=&#34;#cb97-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb97-12&#34;&gt;&lt;a href=&#34;#cb97-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;:*:&lt;/span&gt;) f &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb97-13&#34;&gt;&lt;a href=&#34;#cb97-13&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb97-14&#34;&gt;&lt;a href=&#34;#cb97-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Applicative&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;) f&lt;/span&gt;
&lt;span id=&#34;cb97-15&#34;&gt;&lt;a href=&#34;#cb97-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Apply&lt;/span&gt;       f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;         ) f&lt;/span&gt;
&lt;span id=&#34;cb97-16&#34;&gt;&lt;a href=&#34;#cb97-16&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb97-17&#34;&gt;&lt;a href=&#34;#cb97-17&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monad&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain&lt;/span&gt;  &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Identity&lt;/span&gt;) f&lt;/span&gt;
&lt;span id=&#34;cb97-18&#34;&gt;&lt;a href=&#34;#cb97-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bind&lt;/span&gt;  f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Chain1&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Comp&lt;/span&gt;         ) f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;identityt&#34;&gt;IdentityT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/base/docs/Data-Functor-Identity.html&#34;&gt;Data.Functor.Identity&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: None whatsoever; it adds no extra structure to &lt;code&gt;f&lt;/code&gt;, and &lt;code&gt;IdentityT f&lt;/code&gt; is the same as &lt;code&gt;f&lt;/code&gt;; it’s the “free &lt;code&gt;Unconstrained&lt;/code&gt;”&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb98&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb98-1&#34;&gt;&lt;a href=&#34;#cb98-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IdentityT&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IdentityT&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; runIdentityT ::&lt;/span&gt; f a }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This isn’t too useful on its own, but it can be useful to give to the functor combinator combinators as a no-op functor combinator. It can also be used to signify “no structure”, or as a placeholder until you figure out what sort of structure you want to have.&lt;/p&gt;
&lt;p&gt;In that sense, it can be thought of as a “&lt;code&gt;ListF&lt;/code&gt; with always one item”, a “&lt;code&gt;MaybeF&lt;/code&gt; that’s always &lt;code&gt;Just&lt;/code&gt;”’, an “&lt;code&gt;Ap&lt;/code&gt; with always one sequenced item”, a “&lt;code&gt;Free&lt;/code&gt; with always exactly one layer of effects”, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Constraint&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb99&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb99-1&#34;&gt;&lt;a href=&#34;#cb99-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IdentityT&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb99-2&#34;&gt;&lt;a href=&#34;#cb99-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb99-3&#34;&gt;&lt;a href=&#34;#cb99-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;IdentityT&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb99-4&#34;&gt;&lt;a href=&#34;#cb99-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb99-5&#34;&gt;&lt;a href=&#34;#cb99-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;IdentityT&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of &lt;code&gt;IdentityT&lt;/code&gt; requires no constraints — it basically does nothing.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;proxyf-constf&#34;&gt;ProxyF / ConstF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor.html&#34;&gt;Data.HFunctor&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: “Black holes” — they completely forget all the structure of &lt;code&gt;f&lt;/code&gt;, and are impossible to &lt;code&gt;interpret&lt;/code&gt; out of. &lt;code&gt;Impossible&lt;/code&gt;&#34;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb100&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb100-1&#34;&gt;&lt;a href=&#34;#cb100-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ProxyF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ProxyF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb100-2&#34;&gt;&lt;a href=&#34;#cb100-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ConstF&lt;/span&gt; e f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ConstF&lt;/span&gt; e&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ProxyF&lt;/code&gt; is essentially &lt;code&gt;ConstF ()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These are both valid functor combinators in that you can inject into them, and &lt;code&gt;interpret id . inject == id&lt;/code&gt; is &lt;em&gt;technically&lt;/em&gt; true (the best kind of true).&lt;/p&gt;
&lt;p&gt;You can use them if you want your schema to be impossible to interpret, as a placeholder or to signify that one branch is uninterpretable. In this sense, this is like a “&lt;code&gt;ListF&lt;/code&gt; that is always empty” or a “&lt;code&gt;MaybeF&lt;/code&gt; that is always &lt;code&gt;Nothing&lt;/code&gt;”.&lt;/p&gt;
&lt;p&gt;Because of this, they aren’t too useful on their own — they’re more useful in the context of swapping out and combining or manipulating with other functor combinators or using with functor combinator combinators.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You’re not going to have any luck here — you cannot interpret out of these, unfortunately!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;contravariant-functor-combinators&#34;&gt;Contravariant Functor Combinators&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Addendum: Post functor-combinators-0.3.0.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Most of the above functor combinators have been “covariant” ones: an &lt;code&gt;t f a&lt;/code&gt; represents some “producer” or “generator” of &lt;code&gt;a&lt;/code&gt;s. Many of them require a &lt;code&gt;Functor&lt;/code&gt; constraint on &lt;code&gt;f&lt;/code&gt; interpret out of. However, there exist many useful &lt;em&gt;contravariant&lt;/em&gt; ones too, where &lt;code&gt;t f a&lt;/code&gt; represents a “consumer” of &lt;code&gt;a&lt;/code&gt;s; many of these require a &lt;code&gt;Contravariant&lt;/code&gt; constraint on &lt;code&gt;f&lt;/code&gt; to interpret out of. These can be useful as the building blocks of consumers like serializers.&lt;/p&gt;
&lt;p&gt;I’ve included them all in a separate section because you to either be looking for one or the other, and also because there are much less contravariant combinators than covariant ones in the Haskell ecosystem.&lt;/p&gt;
&lt;p&gt;Also note that many of the functor combinators in the previous sections are compatible with both covariant &lt;em&gt;and&lt;/em&gt; contravariant functors, like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:+:&lt;/code&gt;/&lt;code&gt;Sum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LeftF&lt;/code&gt;/&lt;code&gt;RightF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;EnvT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Step&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Flagged&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Final&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IdentityT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following functor combinators in the previous section are also compatible with both, but their instances in &lt;em&gt;functor-combinator&lt;/em&gt; are designed around covariant usage. However, some of them have contravariant twins that are otherwise identical except for the fact that their instances are instead designed around contravariant usage.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:*:&lt;/code&gt;/&lt;code&gt;Product&lt;/code&gt; (contravariant version: the contravariant &lt;code&gt;Day&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;These1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ListF&lt;/code&gt;/&lt;code&gt;NonEmptyF&lt;/code&gt; (contravariant versions: &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Div1&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MaybeF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This section was added following the release of &lt;em&gt;functor-combinators-0.3.0.0&lt;/em&gt;, which added in support for contravariant and invariant functor combinators.&lt;/p&gt;
&lt;h3 id=&#34;contravariant-day&#34;&gt;Contravariant Day&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Day.html&#34;&gt;Data.Functor.Contravariant.Day&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “Both, together”: provide two consumers that are each meant to consume one part of the input.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb101&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb101-1&#34;&gt;&lt;a href=&#34;#cb101-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x y&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; (f x) (g y) (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (x, y))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This type is essentially equivalent to &lt;code&gt;:*:&lt;/code&gt;/&lt;code&gt;Product&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Contravariant&lt;/code&gt;, so it is useful in every situation where &lt;code&gt;:*:&lt;/code&gt; would be useful. It can be thought of as simply a version of &lt;code&gt;:*:&lt;/code&gt; that signals to the reader that it is meant to be used contravariantly (as a consumer) and not covariantly (as a producer).&lt;/p&gt;
&lt;p&gt;Like for &lt;code&gt;:*:&lt;/code&gt;, it has the distinguishing property (if &lt;code&gt;f&lt;/code&gt; is &lt;code&gt;Contravariant&lt;/code&gt;) of allowing you to use either the &lt;code&gt;f&lt;/code&gt; or the &lt;code&gt;g&lt;/code&gt;, as you please.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb102&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb102-1&#34;&gt;&lt;a href=&#34;#cb102-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;dayOutL ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb102-2&#34;&gt;&lt;a href=&#34;#cb102-2&#34;&gt;&lt;/a&gt;dayOutL (&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; x _ f) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; contramap (&lt;span class=&#34;fu&#34;&gt;fst&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f) x&lt;/span&gt;
&lt;span id=&#34;cb102-3&#34;&gt;&lt;a href=&#34;#cb102-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb102-4&#34;&gt;&lt;a href=&#34;#cb102-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;dayOutR ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb102-5&#34;&gt;&lt;a href=&#34;#cb102-5&#34;&gt;&lt;/a&gt;dayOutR (&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; _ y f) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; contramap (&lt;span class=&#34;fu&#34;&gt;snd&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; f) y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In practice, however, I like to think of it as storing an &lt;code&gt;f&lt;/code&gt; and a &lt;code&gt;g&lt;/code&gt; that can each handle a separate “part” of an &lt;code&gt;a&lt;/code&gt;. For example, the illustrative helper function&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb103&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb103-1&#34;&gt;&lt;a href=&#34;#cb103-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;day ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g (a, b)&lt;/span&gt;
&lt;span id=&#34;cb103-2&#34;&gt;&lt;a href=&#34;#cb103-2&#34;&gt;&lt;/a&gt;day x y &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; x y &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;allows you to couple an &lt;code&gt;f a&lt;/code&gt; consumer of &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;g b&lt;/code&gt; consumer of &lt;code&gt;b&lt;/code&gt; to produce a consumer of &lt;code&gt;(a, b)&lt;/code&gt; that does its job by handing the &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, and the &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb104&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb104-1&#34;&gt;&lt;a href=&#34;#cb104-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Since this type is essentially &lt;code&gt;(:*:)&lt;/code&gt;, it has the same identity.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb105&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb105-1&#34;&gt;&lt;a href=&#34;#cb105-1&#34;&gt;&lt;/a&gt;day &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; g b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; g (a, b)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is the &lt;code&gt;Day&lt;/code&gt; that would “ignore” the &lt;code&gt;a&lt;/code&gt; part and simply pass the &lt;code&gt;b&lt;/code&gt; to &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb106&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb106-1&#34;&gt;&lt;a href=&#34;#cb106-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divise&lt;/span&gt;    f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb106-2&#34;&gt;&lt;a href=&#34;#cb106-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb106-3&#34;&gt;&lt;a href=&#34;#cb106-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb106-4&#34;&gt;&lt;a href=&#34;#cb106-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb106-5&#34;&gt;&lt;a href=&#34;#cb106-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divise&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb106-6&#34;&gt;&lt;a href=&#34;#cb106-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb106-7&#34;&gt;&lt;a href=&#34;#cb106-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb106-8&#34;&gt;&lt;a href=&#34;#cb106-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb106-9&#34;&gt;&lt;a href=&#34;#cb106-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb106-10&#34;&gt;&lt;a href=&#34;#cb106-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:*:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f     &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb106-11&#34;&gt;&lt;a href=&#34;#cb106-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:*:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g     &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb106-12&#34;&gt;&lt;a href=&#34;#cb106-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;(:*:) ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; h &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Proxy&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Divise&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Divise.html&#34;&gt;Data.Functor.Contravariant.Divise&lt;/a&gt;&lt;/em&gt; can be thought of some version the “contravariant &lt;code&gt;Alt&lt;/code&gt;”: it gives you a way to merge two &lt;code&gt;f a&lt;/code&gt;s into a single one in a way that represents having both the items consume the input as they choose. The usual way of doing this is by providing a splitting function to choose to give some part of the input to one argument, and some part to another:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb107&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb107-1&#34;&gt;&lt;a href=&#34;#cb107-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divise&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb107-2&#34;&gt;&lt;a href=&#34;#cb107-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    divise ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (b, c)) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb107-3&#34;&gt;&lt;a href=&#34;#cb107-3&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;co&#34;&gt;-- ^ what to give to the &amp;#39;f b&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb107-4&#34;&gt;&lt;a href=&#34;#cb107-4&#34;&gt;&lt;/a&gt;                     &lt;span class=&#34;co&#34;&gt;-- ^ what to give to the &amp;#39;f c&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Divisible&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant-Divisible.html&#34;&gt;Data.Functor.Contravariant.Divisible&lt;/a&gt;&lt;/em&gt;, adds an identity that will ignore anything it is given: &lt;code&gt;conquer.&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb108&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb108-1&#34;&gt;&lt;a href=&#34;#cb108-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divise&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb108-2&#34;&gt;&lt;a href=&#34;#cb108-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    conquer ::&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(note: like with &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Apply&lt;/code&gt;, the actual version requires only &lt;code&gt;Contravariant f&lt;/code&gt;; &lt;code&gt;Divise&lt;/code&gt; isn’t an actual superclass, even though it should be.)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Basically,&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb109&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb109-1&#34;&gt;&lt;a href=&#34;#cb109-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyF&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb109-2&#34;&gt;&lt;a href=&#34;#cb109-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt;     &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListF&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the contravariant &lt;code&gt;Day&lt;/code&gt; is equivalent to &lt;code&gt;:*:&lt;/code&gt; for contravariant inputs, they have the exact same “list type”. However, in the &lt;em&gt;functor-combinators&lt;/em&gt; library, each list type can only have a single &lt;code&gt;Interpret&lt;/code&gt; instance, so instead the list types are defined to be a separate (identical) type with a different name:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb110&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb110-1&#34;&gt;&lt;a href=&#34;#cb110-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb110-2&#34;&gt;&lt;a href=&#34;#cb110-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt;     &lt;span class=&#34;dt&#34;&gt;Day&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like for &lt;code&gt;Day&lt;/code&gt;, it’s something that can be used instead of &lt;code&gt;:*:&lt;/code&gt; to mentally signify how the type is meant to be used. You can think of &lt;code&gt;Div f a&lt;/code&gt; as a chain of &lt;code&gt;f&lt;/code&gt;s, where the &lt;code&gt;a&lt;/code&gt; is distributed over each &lt;code&gt;f&lt;/code&gt;, but the intent of its usage is that each &lt;code&gt;f&lt;/code&gt; is meant to consume a different part of that &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the information later on &lt;code&gt;Div&lt;/code&gt; alone for more information on usage and utility.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Div&lt;/code&gt; is the possibly-empty version, and &lt;code&gt;Div1&lt;/code&gt; is the nonempty version.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;night&#34;&gt;Night&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Night.html&#34;&gt;Data.Functor.Contravariant.Night&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Mixing Strategy&lt;/strong&gt;: “One or the other, but chosen at consumption-time”: provide two consumers to handle input, but the choice of which consumer to use is made at consumption time.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb111&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb111-1&#34;&gt;&lt;a href=&#34;#cb111-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; f g a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; x y&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; (f x) (g y) (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; x y)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This one represents &lt;em&gt;delegation&lt;/em&gt;: &lt;code&gt;Night f g a&lt;/code&gt; contains &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt; that could process some form of the &lt;code&gt;a&lt;/code&gt;, but which of the two is chosen to depends on the value of &lt;code&gt;a&lt;/code&gt; itself.&lt;/p&gt;
&lt;p&gt;This can be thought of as representing &lt;a href=&#34;https://en.wikipedia.org/wiki/Shard_(database_architecture)&#34;&gt;sharding&lt;/a&gt; between &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;g&lt;/code&gt;. Some discriminator determins which of &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;g&lt;/code&gt; is better suited to consume the input, and picks which single one to use based on that.&lt;/p&gt;
&lt;p&gt;The illustrative helper function can make this clear:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb112&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb112-1&#34;&gt;&lt;a href=&#34;#cb112-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;night ::&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; f g (&lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; a b)&lt;/span&gt;
&lt;span id=&#34;cb112-2&#34;&gt;&lt;a href=&#34;#cb112-2&#34;&gt;&lt;/a&gt;night x y &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; x y &lt;span class=&#34;fu&#34;&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;allows you to couple an &lt;code&gt;f a&lt;/code&gt; consumer of &lt;code&gt;a&lt;/code&gt; with a &lt;code&gt;g b&lt;/code&gt; consumer of &lt;code&gt;b&lt;/code&gt; to produce a consumer of &lt;code&gt;Either a b&lt;/code&gt; that does its job by using the &lt;code&gt;f&lt;/code&gt; if given a &lt;code&gt;Left&lt;/code&gt; input, and using the &lt;code&gt;g&lt;/code&gt; if given a &lt;code&gt;b&lt;/code&gt; input.&lt;/p&gt;
&lt;p&gt;This is technically still a day convolution (mathematically), but it uses &lt;code&gt;Either&lt;/code&gt; instead of the typical &lt;code&gt;(,)&lt;/code&gt; we use in Haskell. So it’s like the opposite of a usual Haskell &lt;code&gt;Day&lt;/code&gt; — it’s &lt;code&gt;Night&lt;/code&gt; :)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Identity&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb113&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb113-1&#34;&gt;&lt;a href=&#34;#cb113-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Tensor&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Not&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb113-2&#34;&gt;&lt;a href=&#34;#cb113-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb113-3&#34;&gt;&lt;a href=&#34;#cb113-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Data type that proves @a@ cannot exist&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb113-4&#34;&gt;&lt;a href=&#34;#cb113-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Not&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Not&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; refute ::&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Void&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If &lt;code&gt;Night f g&lt;/code&gt; assigns input to either &lt;code&gt;f&lt;/code&gt; or &lt;code&gt;g&lt;/code&gt;, then a functor that “cannot be chosen”/“cannot be used” would force the choice to the other side.&lt;/p&gt;
&lt;p&gt;That is, &lt;code&gt;Night f Not&lt;/code&gt; must necessarily pass its input to &lt;code&gt;f&lt;/code&gt;, as you cannot pass anything to a &lt;code&gt;Not&lt;/code&gt;, since it only accepts passing in uninhabited types.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Monoids&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb114&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb114-1&#34;&gt;&lt;a href=&#34;#cb114-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Decide&lt;/span&gt;   f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;SemigroupIn&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb114-2&#34;&gt;&lt;a href=&#34;#cb114-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MonoidIn&lt;/span&gt;    &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Not&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb114-3&#34;&gt;&lt;a href=&#34;#cb114-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb114-4&#34;&gt;&lt;a href=&#34;#cb114-4&#34;&gt;&lt;/a&gt;binterpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb114-5&#34;&gt;&lt;a href=&#34;#cb114-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Decide&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb114-6&#34;&gt;&lt;a href=&#34;#cb114-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb114-7&#34;&gt;&lt;a href=&#34;#cb114-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb114-8&#34;&gt;&lt;a href=&#34;#cb114-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; g h &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb114-9&#34;&gt;&lt;a href=&#34;#cb114-9&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb114-10&#34;&gt;&lt;a href=&#34;#cb114-10&#34;&gt;&lt;/a&gt;inL   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; g &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; f   &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb114-11&#34;&gt;&lt;a href=&#34;#cb114-11&#34;&gt;&lt;/a&gt;inR   &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g   &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; f g&lt;/span&gt;
&lt;span id=&#34;cb114-12&#34;&gt;&lt;a href=&#34;#cb114-12&#34;&gt;&lt;/a&gt;pureT &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; h &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Not&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Decide&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant-Decide.html&#34;&gt;Data.Functor.Contravariant.Decide&lt;/a&gt;&lt;/em&gt; can be thought of as a deterministic sharding typeclass: You can combine two consumers along with a decision function on which consumer to use.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb115&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb115-1&#34;&gt;&lt;a href=&#34;#cb115-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Decide&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb115-2&#34;&gt;&lt;a href=&#34;#cb115-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    decide ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; b c) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f c &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb115-3&#34;&gt;&lt;a href=&#34;#cb115-3&#34;&gt;&lt;/a&gt;                        &lt;span class=&#34;co&#34;&gt;-- ^ use the f b&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb115-4&#34;&gt;&lt;a href=&#34;#cb115-4&#34;&gt;&lt;/a&gt;                          &lt;span class=&#34;co&#34;&gt;-- ^ use the f c&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Conclude&lt;/code&gt; from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Contravariant-Conclude.html&#34;&gt;Data.Functor.Contravariant.Conclude&lt;/a&gt;&lt;/em&gt;, adds support for specifying an &lt;code&gt;f&lt;/code&gt; that cannot be chosen by the decision function when used with &lt;code&gt;decide&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb116&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb116-1&#34;&gt;&lt;a href=&#34;#cb116-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Decide&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb116-2&#34;&gt;&lt;a href=&#34;#cb116-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    conclude ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Void&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;List type&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb117&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb117-1&#34;&gt;&lt;a href=&#34;#cb117-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmptyBy&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb117-2&#34;&gt;&lt;a href=&#34;#cb117-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ListBy&lt;/span&gt;     &lt;span class=&#34;dt&#34;&gt;Night&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Dec f&lt;/code&gt; and &lt;code&gt;Dec1 f&lt;/code&gt; represent a bunch of &lt;code&gt;f&lt;/code&gt;s &lt;code&gt;Night&lt;/code&gt;’d with each other — you can think of &lt;code&gt;Dec f&lt;/code&gt; was the sharding over many different &lt;code&gt;f&lt;/code&gt;s (or even none), and &lt;code&gt;Dec1 f&lt;/code&gt; as the sharding over at least one &lt;code&gt;f&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See the later section on &lt;code&gt;Dec&lt;/code&gt; for more information.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;contravariant-coyoneda&#34;&gt;Contravariant Coyoneda&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/kan-extensions/docs/Data-Functor-Contravariant-Coyoneda.html&#34;&gt;Data.Functor.Contravariant.Coyoneda&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to contravariantly map over the parameter; it’s the free &lt;code&gt;Contravariant&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Can be useful if &lt;code&gt;f&lt;/code&gt; is created using a &lt;code&gt;GADT&lt;/code&gt; that cannot be given a &lt;code&gt;Contravariant&lt;/code&gt; instance.&lt;/p&gt;
&lt;p&gt;For example, here is an indexed type that represents the type of a “prettyprinter”, where the type parameter represents the type that is being pretty-printed output result of the form element.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb118&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb118-1&#34;&gt;&lt;a href=&#34;#cb118-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PrettyPrim&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb118-2&#34;&gt;&lt;a href=&#34;#cb118-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;PPString&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;  ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PrettyPrim&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb118-3&#34;&gt;&lt;a href=&#34;#cb118-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;PPInt&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;     ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PrettyPrim&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb118-4&#34;&gt;&lt;a href=&#34;#cb118-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;PPBool&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;PrettyPrim&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then &lt;code&gt;Coyoneda PrettyPrim&lt;/code&gt; has a &lt;code&gt;Contravariant&lt;/code&gt; instance. We can now contramap over the input type of the pretty-printer; for example, &lt;code&gt;contramap :: (a -&amp;gt; b) -&amp;gt; Coyoneda PrettyPrim b -&amp;gt; Coyoneda PrettyPrim a&lt;/code&gt; takes a prettyprinter of &lt;code&gt;b&lt;/code&gt;s and turns it into a prettyprinter of &lt;code&gt;a&lt;/code&gt;s.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb119&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb119-1&#34;&gt;&lt;a href=&#34;#cb119-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb119-2&#34;&gt;&lt;a href=&#34;#cb119-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb119-3&#34;&gt;&lt;a href=&#34;#cb119-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb119-4&#34;&gt;&lt;a href=&#34;#cb119-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Contravariant&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb119-5&#34;&gt;&lt;a href=&#34;#cb119-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb119-6&#34;&gt;&lt;a href=&#34;#cb119-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of a &lt;code&gt;Coyoneda f&lt;/code&gt; requires the target context to itself be &lt;code&gt;Contravariant&lt;/code&gt;. For example, if we want to “run” a &lt;code&gt;Coyoneda PrettyPrim&lt;/code&gt; in &lt;code&gt;Op String&lt;/code&gt; (&lt;code&gt;Op String a&lt;/code&gt; is a function from &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;String&lt;/code&gt;), this would be &lt;code&gt;interpret :: (forall x. PrettyPrim x -&amp;gt; Op String x) -&amp;gt; Coyoneda PrettyPrim a -&amp;gt; Op String a&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;div-div1&#34;&gt;Div / Div1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators-0.3.2.0/docs/Data-Functor-Contravariant-Divisible-Free.html&#34;&gt;Data.Functor.Contravariant.Divisible.Free&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s to each consume a part of the overall input.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;f x&lt;/code&gt; is a consumer of &lt;code&gt;x&lt;/code&gt;s, then &lt;code&gt;Div f a&lt;/code&gt; is a consumer of &lt;code&gt;a&lt;/code&gt;s that does its job by splitting &lt;code&gt;a&lt;/code&gt; across /all/ &lt;code&gt;f&lt;/code&gt;s, forking them out in parallel. Often times, in practice, this will utilized by giving each &lt;code&gt;f&lt;/code&gt; a separate part of the &lt;code&gt;a&lt;/code&gt; to consume.&lt;/p&gt;
&lt;p&gt;For example, let’s say you had a type &lt;code&gt;Socket a&lt;/code&gt; which represents some IO channel or socket that is expecting to receive &lt;code&gt;a&lt;/code&gt;s. A &lt;code&gt;Div Socket b&lt;/code&gt; would be a collection of sockets that expects a single &lt;code&gt;b&lt;/code&gt; overall, but each individual &lt;code&gt;Socket&lt;/code&gt; inside that &lt;code&gt;Div&lt;/code&gt; is given some part of the overall &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another common usage is to combine serializers by assigning each serializer &lt;code&gt;f&lt;/code&gt; to one part of an overall input.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Structurally&lt;/em&gt;, &lt;code&gt;Div&lt;/code&gt; and &lt;code&gt;Div1&lt;/code&gt; are basically lists of contravariant coyonedas:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb120&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb120-1&#34;&gt;&lt;a href=&#34;#cb120-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt;  f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt;  {&lt;span class=&#34;ot&#34;&gt; unDiv  ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt; f a]          }&lt;/span&gt;
&lt;span id=&#34;cb120-2&#34;&gt;&lt;a href=&#34;#cb120-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div1&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div1&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; unDiv1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NonEmpty&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Coyoneda&lt;/span&gt; f a) }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This could be implemented as simply a normal &lt;code&gt;[f a]&lt;/code&gt; and &lt;code&gt;NonEmpty (f a)&lt;/code&gt; (and so making them identical to &lt;code&gt;ListF&lt;/code&gt;). For the most part, you could use the two interchangely, except in the case where you need to &lt;code&gt;Interpret&lt;/code&gt; out of them: &lt;code&gt;ListF&lt;/code&gt; requires a &lt;code&gt;Plus&lt;/code&gt; constraint, and &lt;code&gt;Div&lt;/code&gt; requires a &lt;code&gt;Divisible&lt;/code&gt; constraint. The &lt;code&gt;Coyoneda&lt;/code&gt; is also necessary for compatibility with the version of the contravariant &lt;code&gt;Day&lt;/code&gt; convolution provided by &lt;em&gt;kan-extensions&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Div1&lt;/code&gt; is a variety of &lt;code&gt;Div&lt;/code&gt; where you always have to have “at least one &lt;code&gt;f&lt;/code&gt;”. Can be useful if you want to ensure, for example, that &lt;em&gt;at least one socket&lt;/em&gt; will be handling the input (and it won’t be lost into the air).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb121&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb121-1&#34;&gt;&lt;a href=&#34;#cb121-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt;  f&lt;/span&gt;
&lt;span id=&#34;cb121-2&#34;&gt;&lt;a href=&#34;#cb121-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divise&lt;/span&gt;    f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb121-3&#34;&gt;&lt;a href=&#34;#cb121-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb121-4&#34;&gt;&lt;a href=&#34;#cb121-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb121-5&#34;&gt;&lt;a href=&#34;#cb121-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divisible&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb121-6&#34;&gt;&lt;a href=&#34;#cb121-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb121-7&#34;&gt;&lt;a href=&#34;#cb121-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb121-8&#34;&gt;&lt;a href=&#34;#cb121-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb121-9&#34;&gt;&lt;a href=&#34;#cb121-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Div1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb121-10&#34;&gt;&lt;a href=&#34;#cb121-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Divise&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb121-11&#34;&gt;&lt;a href=&#34;#cb121-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb121-12&#34;&gt;&lt;a href=&#34;#cb121-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Div1&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of an &lt;code&gt;Div f&lt;/code&gt; requires the target context to be &lt;code&gt;Divisible&lt;/code&gt;, and interpreting out of a &lt;code&gt;Div1 f&lt;/code&gt; requires &lt;code&gt;Divise&lt;/code&gt; (because you will never need the empty case).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dec-dec1&#34;&gt;Dec / Dec1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators-0.3.2.0/docs/Data-Functor-Contravariant-Divisible-Free.html&#34;&gt;Data.Functor.Contravariant.Divisible.Free&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: The ability to provide multiple &lt;code&gt;f&lt;/code&gt;s, one of which will be chosen to consume the overall input.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;f x&lt;/code&gt; is a consumer of &lt;code&gt;x&lt;/code&gt;s, then &lt;code&gt;Dec f a&lt;/code&gt; is a consumer of &lt;code&gt;a&lt;/code&gt;s that does its job by choosing a single one of those &lt;code&gt;f&lt;/code&gt;s to handle that consumption, based on what &lt;code&gt;a&lt;/code&gt; is received.&lt;/p&gt;
&lt;p&gt;Contrast this with &lt;code&gt;Div&lt;/code&gt;, where the multiple &lt;code&gt;f&lt;/code&gt; actions are &lt;em&gt;all&lt;/em&gt; used to consume the input. &lt;code&gt;Dec&lt;/code&gt; only uses &lt;em&gt;one single&lt;/em&gt; &lt;code&gt;f&lt;/code&gt; action to consume the input, chosen at consumption time.&lt;/p&gt;
&lt;p&gt;For example, let’s say you had a type &lt;code&gt;Socket a&lt;/code&gt; which represents some IO channel or socket that is expecting to receive &lt;code&gt;a&lt;/code&gt;s. A &lt;code&gt;Dec Socket b&lt;/code&gt; would be a collection of sockets that expects a single &lt;code&gt;b&lt;/code&gt; overall, and will pick exactly one of those &lt;code&gt;Socket&lt;/code&gt;s to handle that &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this sense, you can sort of think of &lt;code&gt;Dec&lt;/code&gt; as a “sharding” of &lt;code&gt;f&lt;/code&gt;s: each &lt;code&gt;f&lt;/code&gt; handles a different possible categorization of the input.&lt;/p&gt;
&lt;p&gt;Another common usage is to combine serializers by assigning each serializer &lt;code&gt;f&lt;/code&gt; to one possible form of possible input.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Structurally&lt;/em&gt;, &lt;code&gt;Dec&lt;/code&gt; is built like a linked list of &lt;code&gt;f x&lt;/code&gt;s, which each link being existentially bound together:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb122&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb122-1&#34;&gt;&lt;a href=&#34;#cb122-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Type&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb122-2&#34;&gt;&lt;a href=&#34;#cb122-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Lose&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;   ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Void&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a&lt;/span&gt;
&lt;span id=&#34;cb122-3&#34;&gt;&lt;a href=&#34;#cb122-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Choose&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; f x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f y &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Either&lt;/span&gt; x y) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is more or less the same construction as for &lt;code&gt;Ap&lt;/code&gt;: see information on &lt;code&gt;Ap&lt;/code&gt; for a deeper explanation on how or why this works.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dec1&lt;/code&gt; is a variety of &lt;code&gt;Dec&lt;/code&gt; where you always have to have “at least one &lt;code&gt;f&lt;/code&gt;”. Can be useful if you want to ensure, for example, that there always exists at least one &lt;code&gt;f&lt;/code&gt; that can handle the job.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb123&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb123-1&#34;&gt;&lt;a href=&#34;#cb123-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt;  f&lt;/span&gt;
&lt;span id=&#34;cb123-2&#34;&gt;&lt;a href=&#34;#cb123-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Decide&lt;/span&gt;   f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec1&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb123-3&#34;&gt;&lt;a href=&#34;#cb123-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb123-4&#34;&gt;&lt;a href=&#34;#cb123-4&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb123-5&#34;&gt;&lt;a href=&#34;#cb123-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Conclude&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb123-6&#34;&gt;&lt;a href=&#34;#cb123-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb123-7&#34;&gt;&lt;a href=&#34;#cb123-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb123-8&#34;&gt;&lt;a href=&#34;#cb123-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb123-9&#34;&gt;&lt;a href=&#34;#cb123-9&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Dec1&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb123-10&#34;&gt;&lt;a href=&#34;#cb123-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Decide&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb123-11&#34;&gt;&lt;a href=&#34;#cb123-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb123-12&#34;&gt;&lt;a href=&#34;#cb123-12&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Dec1&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of an &lt;code&gt;Dec f&lt;/code&gt; requires the target context to be &lt;code&gt;Conclude&lt;/code&gt;, and interpreting out of a &lt;code&gt;Dec1 f&lt;/code&gt; requires &lt;code&gt;Decide&lt;/code&gt; (because you will never need the rejecting case).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;combinator-combinators&#34;&gt;Combinator Combinators&lt;/h2&gt;
&lt;p&gt;There exist higher-order functor combinator combinators that take functor combinators and return new ones, too. We can talk about a uniform interface for them, but they aren’t very common, so it is probably not worth the extra abstraction.&lt;/p&gt;
&lt;h3 id=&#34;composet&#34;&gt;ComposeT&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/mmorph/docs/Control-Monad-Trans-Compose.html&#34;&gt;Control.Monad.Trans.Compose&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: Compose enhancements from two different functor combinators&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb124&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb124-1&#34;&gt;&lt;a href=&#34;#cb124-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ComposeT&lt;/span&gt; s t f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ComposeT&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; getComposeT ::&lt;/span&gt; s (t f) a }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can be useful if you want to layer or nest functor combinators to get both enhancements as a &lt;em&gt;single&lt;/em&gt; functor combinator*.&lt;/p&gt;
&lt;p&gt;Usually really only useful in the context of other abstractions that expect functor combinators, since this is the best way to turn two functor combinators into a third one.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb125&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb125-1&#34;&gt;&lt;a href=&#34;#cb125-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; s f, &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f) &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;ComposeT&lt;/span&gt; s t) f&lt;/span&gt;
&lt;span id=&#34;cb125-2&#34;&gt;&lt;a href=&#34;#cb125-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb125-3&#34;&gt;&lt;a href=&#34;#cb125-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;ComposeT&lt;/span&gt; s t)&lt;/span&gt;
&lt;span id=&#34;cb125-4&#34;&gt;&lt;a href=&#34;#cb125-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; s f, &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f)&lt;/span&gt;
&lt;span id=&#34;cb125-5&#34;&gt;&lt;a href=&#34;#cb125-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb125-6&#34;&gt;&lt;a href=&#34;#cb125-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;ComposeT&lt;/span&gt; s t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of these requires the constraints on &lt;em&gt;both&lt;/em&gt; layers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hlift&#34;&gt;HLift&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor.html&#34;&gt;Data.HFunctor&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: &lt;code&gt;HLift t f&lt;/code&gt; lets &lt;code&gt;f&lt;/code&gt; exist either unchanged, or with the structure of &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb126&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb126-1&#34;&gt;&lt;a href=&#34;#cb126-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HLift&lt;/span&gt; t f a&lt;/span&gt;
&lt;span id=&#34;cb126-2&#34;&gt;&lt;a href=&#34;#cb126-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HPure&lt;/span&gt;  (f a)&lt;/span&gt;
&lt;span id=&#34;cb126-3&#34;&gt;&lt;a href=&#34;#cb126-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HOther&lt;/span&gt; (t f a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Can be useful if you want to “conditionally enhance” &lt;code&gt;f&lt;/code&gt;. Either &lt;code&gt;f&lt;/code&gt; can be enhanced by &lt;code&gt;t&lt;/code&gt;, or it can exist in its pure “newly-injected” form.&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;t&lt;/code&gt; is &lt;code&gt;Identity&lt;/code&gt;, we get &lt;code&gt;EnvT Any&lt;/code&gt;, or &lt;code&gt;f :+: f&lt;/code&gt;: the “pure or impure” combinator.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb127&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb127-1&#34;&gt;&lt;a href=&#34;#cb127-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;HLift&lt;/span&gt; t) f&lt;/span&gt;
&lt;span id=&#34;cb127-2&#34;&gt;&lt;a href=&#34;#cb127-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb127-3&#34;&gt;&lt;a href=&#34;#cb127-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;HLift&lt;/span&gt; t)&lt;/span&gt;
&lt;span id=&#34;cb127-4&#34;&gt;&lt;a href=&#34;#cb127-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f&lt;/span&gt;
&lt;span id=&#34;cb127-5&#34;&gt;&lt;a href=&#34;#cb127-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb127-6&#34;&gt;&lt;a href=&#34;#cb127-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HLift&lt;/span&gt; t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of these requires the constraint on &lt;code&gt;t&lt;/code&gt;, to handle the &lt;code&gt;HOther&lt;/code&gt; case.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;hfree&#34;&gt;HFree&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Origin&lt;/strong&gt;: &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor.html&#34;&gt;Data.HFunctor&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Enhancement&lt;/strong&gt;: &lt;code&gt;HFree t f&lt;/code&gt; lets &lt;code&gt;f&lt;/code&gt; exist either unchanged, or with multiple nested enhancements by &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb128&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb128-1&#34;&gt;&lt;a href=&#34;#cb128-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; t f a&lt;/span&gt;
&lt;span id=&#34;cb128-2&#34;&gt;&lt;a href=&#34;#cb128-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HReturn&lt;/span&gt; (f a)&lt;/span&gt;
&lt;span id=&#34;cb128-3&#34;&gt;&lt;a href=&#34;#cb128-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HJoin&lt;/span&gt;   (t (&lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; t f) a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is related to &lt;code&gt;HLift&lt;/code&gt;, but lets you lift over arbitrary many compositions of &lt;code&gt;t&lt;/code&gt;, enhancing &lt;code&gt;f&lt;/code&gt; multiple times. This essentially creates a “tree” of &lt;code&gt;t&lt;/code&gt; branches.&lt;/p&gt;
&lt;p&gt;One particularly useful functor combinator to use is &lt;code&gt;MapF&lt;/code&gt;. In our earlier examples, if we have&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb129&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb129-1&#34;&gt;&lt;a href=&#34;#cb129-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to represent the structure of a single command line argument parser, we can use&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb130&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb130-1&#34;&gt;&lt;a href=&#34;#cb130-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Commands&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to represent &lt;em&gt;multiple&lt;/em&gt; potential named commands, each under a different &lt;code&gt;String&lt;/code&gt; argument. With &lt;code&gt;HFree&lt;/code&gt;, we can also use:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb131&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb131-1&#34;&gt;&lt;a href=&#34;#cb131-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CommandTree&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to represent &lt;em&gt;nested&lt;/em&gt; named commands, where each nested sub-command is descended on by a &lt;code&gt;String&lt;/code&gt; key.&lt;/p&gt;
&lt;p&gt;For another example, &lt;code&gt;HFree IdentityT&lt;/code&gt; is essentially &lt;code&gt;Step&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Interpret&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb132&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb132-1&#34;&gt;&lt;a href=&#34;#cb132-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; t f &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpret&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; t) f&lt;/span&gt;
&lt;span id=&#34;cb132-2&#34;&gt;&lt;a href=&#34;#cb132-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb132-3&#34;&gt;&lt;a href=&#34;#cb132-3&#34;&gt;&lt;/a&gt;interpret &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; t)&lt;/span&gt;
&lt;span id=&#34;cb132-4&#34;&gt;&lt;a href=&#34;#cb132-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Interpre&lt;/span&gt; t f&lt;/span&gt;
&lt;span id=&#34;cb132-5&#34;&gt;&lt;a href=&#34;#cb132-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb132-6&#34;&gt;&lt;a href=&#34;#cb132-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting out of these requires the constraint on &lt;code&gt;t&lt;/code&gt;, to handle the &lt;code&gt;HJoin&lt;/code&gt; case.&lt;/p&gt;
&lt;p&gt;However, it is probably usually more useful to directly pattern match on &lt;code&gt;HReturn&lt;/code&gt; and &lt;code&gt;HJoin&lt;/code&gt; and handle the recursion explicitly.&lt;/p&gt;
&lt;p&gt;Alternatively, we can also define a recursive folding function (provided in &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-HFunctor.html&#34;&gt;Data.HFunctor&lt;/a&gt;&lt;/em&gt;) to recursively fold down each branch:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb133&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb133-1&#34;&gt;&lt;a href=&#34;#cb133-1&#34;&gt;&lt;/a&gt;foldHFree&lt;/span&gt;
&lt;span id=&#34;cb133-2&#34;&gt;&lt;a href=&#34;#cb133-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFunctor&lt;/span&gt; t&lt;/span&gt;
&lt;span id=&#34;cb133-3&#34;&gt;&lt;a href=&#34;#cb133-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb133-4&#34;&gt;&lt;a href=&#34;#cb133-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f)&lt;/span&gt;
&lt;span id=&#34;cb133-5&#34;&gt;&lt;a href=&#34;#cb133-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HFree&lt;/span&gt; t g &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can be useful because it allows you to distinguish between the different branches, and also requires no constraint on &lt;code&gt;g&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Applied to the &lt;code&gt;CommandTree&lt;/code&gt; example, this becomes:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb134&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb134-1&#34;&gt;&lt;a href=&#34;#cb134-1&#34;&gt;&lt;/a&gt;foldHFree &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;(&lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb134-2&#34;&gt;&lt;a href=&#34;#cb134-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Command&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb134-3&#34;&gt;&lt;a href=&#34;#cb134-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MapF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb134-4&#34;&gt;&lt;a href=&#34;#cb134-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;CommandTree&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;~&amp;gt;&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;closing-comments&#34;&gt;Closing Comments&lt;/h2&gt;
&lt;p&gt;As I discover more interesting or useful functor combinators (or as the abstractions in &lt;em&gt;functor-combinators&lt;/em&gt; change), I will continue to update this post. And, in the upcoming weeks and months I plan to present specific programs I have written (and simple examples of usage) that will help show this design pattern in use within a real program.&lt;/p&gt;
&lt;p&gt;For now, I hope you can appreciate this as a reference to help guide your exploration of unique “a la carte” (yet not fixed-point-centric) approach to building your programs! You can jump right into using these tools to build your program &lt;em&gt;today&lt;/em&gt; by importing &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/functor-combinators/docs/Data-Functor-Combinator.html&#34;&gt;Data.Functor.Combinator&lt;/a&gt;&lt;/em&gt; or wherever they can be found.&lt;/p&gt;
&lt;p&gt;I’d be excited to hear about what programs you are able to write, so please do let me know! You can leave a comment, find me on &lt;span class=&#34;citation&#34; data-cites=&#34;mstk&#34;&gt;[twitter at @mstk]&lt;/span&gt;&lt;a href=&#34;https://twitter.com/mstk&#34; title=&#34;Twitter&#34;&gt;twitter&lt;/a&gt;, or find me on freenode irc idling on &lt;em&gt;#haskell&lt;/em&gt; as &lt;em&gt;jle`&lt;/em&gt; if you want to share, or have any questions.&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporter at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Josh Vera! :)&lt;/p&gt;
&lt;p&gt;Also a special thanks to &lt;a href=&#34;https://twitter.com/KozRoss&#34;&gt;Koz Ross&lt;/a&gt;, who helped proofread this post as a draft.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;On the surface, this functor combinator design pattern might look like it fills a similar space to effects systems and libraries like &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/mtl&#34;&gt;mtl&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/polysemy&#34;&gt;polysemy&lt;/a&gt;&lt;/em&gt;, &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/freer-simple&#34;&gt;freer-simple&lt;/a&gt;&lt;/em&gt;, or &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/fused-effects&#34;&gt;fused-effects&lt;/a&gt;&lt;/em&gt;. However, this design pattern actually exists on a different level.&lt;/p&gt;
&lt;p&gt;Functor combinator design patterns can be used to help build the &lt;em&gt;structure&lt;/em&gt; of the &lt;em&gt;data types&lt;/em&gt; and schemas that define your program/DSL. Once you build these nice structures, you then &lt;em&gt;interpret&lt;/em&gt; them into some target context. This “target context” is the realm that libraries like &lt;em&gt;mtl&lt;/em&gt; and &lt;em&gt;polysemy&lt;/em&gt; can fill; functor combinators serve to help you define a structure for your program &lt;em&gt;before&lt;/em&gt; you interpret it into whatever Applicative or Monad or effects system you end up using.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><guid isPermaLink="true">https://blog.jle.im/entry/functor-combinatorpedia.html</guid><pubDate>Wed, 19 Jun 2019 18:41:46 UTC</pubDate><creator>Justin Le</creator><subject>Haskell</subject><date>2019-06-19</date></item><item><title>Applicative Regular Expressions using the Free Alternative</title><link>https://blog.jle.im/entry/free-alternative-regexp.html</link><description>&lt;p&gt;Today, we’re going to implement applicative regular expressions and parsers (in the style of the &lt;a href=&#34;https://hackage.haskell.org/package/regex-applicative&#34;&gt;regex-applicative&lt;/a&gt; library) using free structures!&lt;/p&gt;
&lt;p&gt;Free structures are some of my favorite tools in Haskell, and I’ve actually written a few posts about them before, including &lt;a href=&#34;https://blog.jle.im/entry/alchemical-groups.html&#34;&gt;this one using free groups&lt;/a&gt;, &lt;a href=&#34;https://blog.jle.im/entry/interpreters-a-la-carte-duet.html&#34;&gt;this one on a free monad variation&lt;/a&gt;, and &lt;a href=&#34;https://blog.jle.im/entry/const-applicative-and-monoids.html&#34;&gt;this one on a “free” applicative on a monoid&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Regular expressions (and parsers) are ubiquitous in computer science and programming, and I hope that demonstrating that they are pretty straightforward to implement using free structures will help you see the value in free structures without getting too bogged down in the details!&lt;/p&gt;
&lt;p&gt;All of the code in this post is &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs&#34;&gt;available online&lt;/a&gt; as a “stack executable”. When you run it (&lt;code&gt;./regexp.hs&lt;/code&gt;), you’ll load up a &lt;em&gt;ghci&lt;/em&gt; session with all of the definitions in scope, so you can play around with the functions and types :)&lt;/p&gt;
&lt;p&gt;This post should be accessible to late beginner or early intermediate Haskell users, and requires some basic familiarity with pattern matching, algebraic data types, and abstractions like &lt;code&gt;Monoid&lt;/code&gt; and &lt;code&gt;Functor&lt;/code&gt;, and do notation.&lt;/p&gt;
&lt;h2 id=&#34;regular-languages&#34;&gt;Regular Languages&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;regular expression&lt;/em&gt; is something that defines a &lt;em&gt;regular language&lt;/em&gt;. &lt;a href=&#34;https://en.wikipedia.org/wiki/Regular_expression#Formal_language_theory&#34;&gt;Formally&lt;/a&gt;, it consists of the following base elements:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;The empty set, which always fails to match.&lt;/li&gt;
&lt;li&gt;The empty string, which always succeeds matching the empty string.&lt;/li&gt;
&lt;li&gt;The literal character, denoting a single matching character&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And the following operations:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Concatenation: &lt;code&gt;RS&lt;/code&gt;, sequence one after the other. A set product.&lt;/li&gt;
&lt;li&gt;Alternation: &lt;code&gt;R|S&lt;/code&gt;, one or the other. A set union.&lt;/li&gt;
&lt;li&gt;Kleene Star: &lt;code&gt;R*&lt;/code&gt;, the repetition of &lt;code&gt;R&lt;/code&gt; zero or more times.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And that’s &lt;em&gt;all&lt;/em&gt; that’s in a regular expression. Nothing more, nothing less. From these basic tools, you can derive the rest of the regexp operations — for example, &lt;code&gt;a+&lt;/code&gt; can be expressed as &lt;code&gt;aa*&lt;/code&gt;, and categories like &lt;code&gt;\w&lt;/code&gt; can be expressed as alternations of valid characters.&lt;/p&gt;
&lt;h3 id=&#34;alternative&#34;&gt;Alternative&lt;/h3&gt;
&lt;p&gt;Looking at this, does this look a little familiar? It reminds me a lot of the &lt;code&gt;Alternative&lt;/code&gt; typeclass. If a functor &lt;code&gt;f&lt;/code&gt; has an &lt;code&gt;Alternative&lt;/code&gt; instance, it means that it has:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;code&gt;empty&lt;/code&gt;, the failing operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pure x&lt;/code&gt;, the always-succeeding operation (from the &lt;code&gt;Applicative&lt;/code&gt; class)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, the sequencing operation (from the &lt;code&gt;Applicative&lt;/code&gt; class)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, the alternating operation&lt;/li&gt;
&lt;li&gt;&lt;code&gt;many&lt;/code&gt;, the “zero or more” operation.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This…looks a lot like the construction of a regular language, doesn’t it? It’s almost as if &lt;code&gt;Alternative&lt;/code&gt; has almost &lt;em&gt;exactly&lt;/em&gt; what we need. The only thing missing is the literal character primitive.&lt;/p&gt;
&lt;p&gt;If you’re unfamiliar with &lt;code&gt;Alternative&lt;/code&gt;, the &lt;a href=&#34;https://wiki.haskell.org/Typeclassopedia&#34;&gt;typeclassopedia&lt;/a&gt; has a good step-by-step introduction. But for the purposes of this article, it’s basically just a “double monoid”, with two “combining” actions &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, which roughly correspond to &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; in the integers. It’s basically pretty much nothing more than 1-5 in the list above, and some distributivity laws.&lt;/p&gt;
&lt;p&gt;So, one way we can look at regular expressions is “The entire &lt;code&gt;Alternative&lt;/code&gt; interface, plus a character primitive”. &lt;em&gt;But!&lt;/em&gt; There’s another way of looking at this, that leads us directly to free structures.&lt;/p&gt;
&lt;p&gt;Instead of seeing things as “&lt;code&gt;Alternative&lt;/code&gt; with a character primitive”, we can look at it as &lt;em&gt;a character primitive enriched with a Alternative instance&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&#34;free&#34;&gt;Free&lt;/h2&gt;
&lt;p&gt;Let’s write this out. Our character primitive will be:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L17-L18&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that because we’re working with functors, applicatives, alternatives, etc., all of our regular expressions can have an associated “result”. This is because our regexp values will have a type parameter (which is required for &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Applicative&lt;/code&gt;, and &lt;code&gt;Alternative&lt;/code&gt;). We can choose to ignore this type parameter, but we can also have some fun by using it to represent a “result” that a regexp match will be interpreted as. This is similar to the idea of “capturing” in industrial regexp applications.&lt;/p&gt;
&lt;p&gt;Here, the value &lt;code&gt;Prim &#39;a&#39; 1 :: Prim Int&lt;/code&gt; will represent a primitive that matches on the character &lt;code&gt;a&lt;/code&gt;, interpreting it with a result of &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And now…we give it &lt;code&gt;Alternative&lt;/code&gt; structure using the &lt;em&gt;Free Alternative&lt;/em&gt;, from the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/free&#34;&gt;free&lt;/a&gt;&lt;/em&gt; package:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Control.Alternative.Free&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L20-L20&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it! That’s our entire regular expression type! By giving a &lt;code&gt;Alt&lt;/code&gt; a &lt;code&gt;Functor&lt;/code&gt;, we get all of the operations of &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Alternative&lt;/code&gt; over our base. That’s because we have &lt;code&gt;instance Applicative (Alt f)&lt;/code&gt; and &lt;code&gt;instance Alternative (Alt f)&lt;/code&gt;. We now have:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;The empty set, coming from &lt;code&gt;empty&lt;/code&gt; from &lt;code&gt;Alternative&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The empty string, coming from &lt;code&gt;pure&lt;/code&gt; from &lt;code&gt;Applicative&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;The character primitive, coming from the underlying functor &lt;code&gt;Prim&lt;/code&gt; that we are enhancing&lt;/li&gt;
&lt;li&gt;The concatenation operation, from &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, from &lt;code&gt;Applicative&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The alternating operation, from &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, from &lt;code&gt;Alternative&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The kleene star, from &lt;code&gt;many&lt;/code&gt;, from &lt;code&gt;Alternative&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;All of these additions to our primitive come “for free”!&lt;/p&gt;
&lt;p&gt;Essentially, what a free structure gives us is the structure of the abstraction (&lt;code&gt;Alternative&lt;/code&gt;, here) automatically for our base type, and &lt;em&gt;nothing else&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Remember that regular expressions have these operations, &lt;em&gt;and nothing else&lt;/em&gt; — no more, no less. That’s exactly what the free Alternative gives us: these operations and the primitive. No more, no less.&lt;/p&gt;
&lt;p&gt;After adding some convenient wrappers…we’re done here!&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L22-L33&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | charAs: Parse a given character as a given constant result.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;charAs ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;charAs c x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; liftAlt (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; c x)     &lt;span class=&#34;co&#34;&gt;-- liftAlt lets us use the underlying&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;                                    &lt;span class=&#34;co&#34;&gt;-- functor Prim in RegExp&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | char: Parse a given character as itself.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;char ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;char c &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; charAs c c&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | string: Parse a given string as itself.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;string ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;string &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;traverse&lt;/span&gt; char              &lt;span class=&#34;co&#34;&gt;-- neat, huh&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;
&lt;p&gt;Let’s try it out! Let’s match on &lt;code&gt;(a|b)(cd)*e&lt;/code&gt; and return &lt;code&gt;()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L35-L38&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;testRegExp_ ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;testRegExp_ &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; void &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; (char &lt;span class=&#34;ch&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;*&amp;gt;&lt;/span&gt; many (string &lt;span class=&#34;st&#34;&gt;&amp;quot;cd&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb4-6&#34;&gt;&lt;a href=&#34;#cb4-6&#34;&gt;&lt;/a&gt;                  &lt;span class=&#34;op&#34;&gt;*&amp;gt;&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;void&lt;/code&gt; from &lt;em&gt;Data.Functor&lt;/em&gt; discards the results, since we only care if it matches or not. But we use &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; and &lt;code&gt;*&amp;gt;&lt;/code&gt; and &lt;code&gt;many&lt;/code&gt; exactly how we’d expect to concatenate and alternate things with &lt;code&gt;Applicative&lt;/code&gt; and &lt;code&gt;Alternative&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Or maybe more interesting (but slightly more complicated), let’s match on the same pattern and return how many &lt;code&gt;cd&lt;/code&gt;s are repeated&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L40-L43&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;testRegExp ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;testRegExp &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (char &lt;span class=&#34;ch&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb5-5&#34;&gt;&lt;a href=&#34;#cb5-5&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;*&amp;gt;&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; many (string &lt;span class=&#34;st&#34;&gt;&amp;quot;cd&amp;quot;&lt;/span&gt;))&lt;/span&gt;
&lt;span id=&#34;cb5-6&#34;&gt;&lt;a href=&#34;#cb5-6&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;op&#34;&gt;&amp;lt;*&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This one does require a little more finesse with &lt;code&gt;*&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;*&lt;/code&gt;: the arrows point towards which result to “keep”. And since &lt;code&gt;many (string &#34;cd&#34;) :: RegExp [String]&lt;/code&gt; (it returns a list, with an item for each repetition), we can &lt;code&gt;fmap length&lt;/code&gt; to get the &lt;code&gt;Int&lt;/code&gt; result of “how many repetitions”.&lt;/p&gt;
&lt;p&gt;However, we can also turn on &lt;em&gt;-XApplicativeDo&lt;/em&gt; and write it using do notation, which requires a little less thought:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L45-L50&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-2&#34;&gt;&lt;a href=&#34;#cb6-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-3&#34;&gt;&lt;a href=&#34;#cb6-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;testRegExpDo ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-4&#34;&gt;&lt;a href=&#34;#cb6-4&#34;&gt;&lt;/a&gt;testRegExpDo &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-5&#34;&gt;&lt;a href=&#34;#cb6-5&#34;&gt;&lt;/a&gt;    char &lt;span class=&#34;ch&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;|&amp;gt;&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-6&#34;&gt;&lt;a href=&#34;#cb6-6&#34;&gt;&lt;/a&gt;    cds &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; many (string &lt;span class=&#34;st&#34;&gt;&amp;quot;cd&amp;quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb6-7&#34;&gt;&lt;a href=&#34;#cb6-7&#34;&gt;&lt;/a&gt;    char &lt;span class=&#34;ch&#34;&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb6-8&#34;&gt;&lt;a href=&#34;#cb6-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;length&lt;/span&gt; cds)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s all a little bit like how we often use “captures” in regular expressions to access a &lt;em&gt;specific part&lt;/em&gt; of a match. Here’s an example in ruby:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode ruby&#34;&gt;&lt;code class=&#34;sourceCode ruby&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;irb&amp;gt; &lt;span class=&#34;ot&#34;&gt;/(a|b)((cd)*)e/&lt;/span&gt;.match(&lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcdcde&amp;quot;&lt;/span&gt;)[&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb7-2&#34;&gt;&lt;a href=&#34;#cb7-2&#34;&gt;&lt;/a&gt;=&amp;gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;cdcdcdcd&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;except we also include a “post-processing” process to get the length of the number of repetitions.&lt;/p&gt;
&lt;p&gt;Here’s another handy regexp that matches on a digit between 0 to 9, and the result is the digit &lt;code&gt;Int&lt;/code&gt; itself:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L52-L53&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-2&#34;&gt;&lt;a href=&#34;#cb8-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-3&#34;&gt;&lt;a href=&#34;#cb8-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;digit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb8-4&#34;&gt;&lt;a href=&#34;#cb8-4&#34;&gt;&lt;/a&gt;digit &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; asum [ charAs (&lt;span class=&#34;fu&#34;&gt;intToDigit&lt;/span&gt; i) i &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; i &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; [&lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;] ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code&gt;asum [x,y,z] = x &amp;lt;|&amp;gt; y &amp;lt;|&amp;gt; z&lt;/code&gt;: it represents a choice between the items in a list.&lt;/p&gt;
&lt;p&gt;We can again do some fancy things with it, like make a regexp &lt;code&gt;\[\d\]&lt;/code&gt; that matches on a digit inside &lt;code&gt;[&lt;/code&gt; / &lt;code&gt;]&lt;/code&gt; brackets:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L55-L56&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;bracketDigit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;bracketDigit &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&amp;gt;&lt;/span&gt; digit &lt;span class=&#34;op&#34;&gt;&amp;lt;*&lt;/span&gt; char &lt;span class=&#34;ch&#34;&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;parsing&#34;&gt;Parsing&lt;/h2&gt;
&lt;p&gt;Okay, so all we did was define a data structure that supports character matching, concatenation, alternation, and starring. Big whoop. What we really want to do is use it to parse things, right? How does the Free Alternative help us with &lt;em&gt;that&lt;/em&gt;?&lt;/p&gt;
&lt;p&gt;Well, it does a lot, actually. Let’s look at two ways of doing this!&lt;/p&gt;
&lt;h3 id=&#34;offloading-alternative&#34;&gt;Offloading Alternative&lt;/h3&gt;
&lt;h4 id=&#34;what-is-freeness&#34;&gt;What is Freeness?&lt;/h4&gt;
&lt;p&gt;The “canonical” way of using a free structure is by using its “folding” operation into a concrete structure with the proper instances. For example, &lt;code&gt;foldMap&lt;/code&gt; will turn a free monoid into a value of any monoid instance:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;foldMap&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt; ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Monoid&lt;/span&gt; m &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([a] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; m)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;foldMap&lt;/code&gt; lifts an &lt;code&gt;a -&amp;gt; m&lt;/code&gt; into a &lt;code&gt;[a] -&amp;gt; m&lt;/code&gt; (or, &lt;code&gt;FreeMonoid a -&amp;gt; m&lt;/code&gt;), with a concrete monoid &lt;code&gt;m&lt;/code&gt;. The general idea is that using a free structure can “defer” the concretization from between the time of construction to the time of use.&lt;/p&gt;
&lt;p&gt;For example, we can construct value in the free monoid made from integers:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Lift the &amp;quot;primitive&amp;quot; `Int` into a value in the free monoid on `Int`.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-3&#34;&gt;&lt;a href=&#34;#cb11-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- Analogous to `liftAlt` from earlier.&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-4&#34;&gt;&lt;a href=&#34;#cb11-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;liftFM ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb11-5&#34;&gt;&lt;a href=&#34;#cb11-5&#34;&gt;&lt;/a&gt;liftFM x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; [x]&lt;/span&gt;
&lt;span id=&#34;cb11-6&#34;&gt;&lt;a href=&#34;#cb11-6&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb11-7&#34;&gt;&lt;a href=&#34;#cb11-7&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;myMon ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb11-8&#34;&gt;&lt;a href=&#34;#cb11-8&#34;&gt;&lt;/a&gt;myMon &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; liftFM &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; liftFM &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; liftFM &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; liftFM &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we can decide how we want to interpret &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; — should it be &lt;code&gt;+&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;foldMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Sum&lt;/span&gt; myMon&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Sum&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;10&lt;/span&gt;              &lt;span class=&#34;co&#34;&gt;-- 1 + 2 + 3 + 4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or should it be &lt;code&gt;*&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;foldMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Product&lt;/span&gt; myMon&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Product&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;24&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- 1 * 2 * 3 * 4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or maybe even &lt;code&gt;max&lt;/code&gt;?&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;foldMap&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Max&lt;/span&gt; myMon&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Max&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;          &lt;span class=&#34;co&#34;&gt;-- 1 `max` 2 `max` 3 `max` 4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that we can “defer” the choice of concrete &lt;code&gt;Monoid&lt;/code&gt; that &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is interpreted under by first pushing 1, 2, 3, and 4 into a free monoid value. The free monoid on &lt;code&gt;Int&lt;/code&gt; gives &lt;em&gt;exactly enough structure&lt;/em&gt; to &lt;code&gt;Int&lt;/code&gt; to do this job: no more, no less.&lt;/p&gt;
&lt;p&gt;To use &lt;code&gt;foldMap&lt;/code&gt;, we say “how to handle the base type”, and it lets us handle the free structure in its entirety by offloading the behavior of &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; to the concrete monoid.&lt;/p&gt;
&lt;h4 id=&#34;interpreting-in-state&#34;&gt;Interpreting in State&lt;/h4&gt;
&lt;p&gt;In practice, getting a result from a free structure is often about finding (or creating) the right concrete &lt;code&gt;Alternative&lt;/code&gt; that gives us the behavior we want. In this case, we’re in luck. There’s a concrete &lt;code&gt;Alternative&lt;/code&gt; instance that works just the way we want: &lt;code&gt;StateT String Maybe&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Its &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; works by sequencing changes in state; in this case, we’ll consider the state as “characters yet to be parsed”, so sequential parsing fits perfectly with &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;. That’s because combining regexps sequentially can be thought of as statefully chomping down on a string.&lt;/li&gt;
&lt;li&gt;Its &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt; works by backtracking and trying again if it runs into a failure. It saves the state of the last successful point and resets to it on failure. This is exactly how we want regexp alternation &lt;code&gt;R|S&lt;/code&gt; to behave.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The “folding” operation of the free alternative is called &lt;code&gt;runAlt&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runAlt ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alternative&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;       &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; b&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; p b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b)&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; p a&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And in the case of &lt;code&gt;RegExp&lt;/code&gt;, we have:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;runAlt ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alternative&lt;/span&gt; f&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;       &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; b&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f b)&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;       &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; f a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you’re unfamiliar with the RankN type (the &lt;code&gt;forall b.&lt;/code&gt; stuff), there’s a &lt;a href=&#34;https://ocharles.org.uk/guest-posts/2014-12-18-rank-n-types.html&#34;&gt;nice introduction here&lt;/a&gt;. But basically, you just need to provide &lt;code&gt;runAlt&lt;/code&gt; with a function that can handle a &lt;code&gt;Prim b&lt;/code&gt; for &lt;em&gt;any&lt;/em&gt; &lt;code&gt;b&lt;/code&gt; (and not just a specific one like &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Bool&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;So, like &lt;code&gt;foldMap&lt;/code&gt;, we need to say “how to handle our base type”. Here, we have to answer “How do we handle &lt;code&gt;Prim&lt;/code&gt;?”&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L58-L63&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;processPrim ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;StateT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;processPrim (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; c x) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;    d&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;ds &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; get&lt;/span&gt;
&lt;span id=&#34;cb17-6&#34;&gt;&lt;a href=&#34;#cb17-6&#34;&gt;&lt;/a&gt;    guard (c &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; d)&lt;/span&gt;
&lt;span id=&#34;cb17-7&#34;&gt;&lt;a href=&#34;#cb17-7&#34;&gt;&lt;/a&gt;    put ds&lt;/span&gt;
&lt;span id=&#34;cb17-8&#34;&gt;&lt;a href=&#34;#cb17-8&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This lets us interpret a &lt;code&gt;Prim&lt;/code&gt; as a &lt;code&gt;StateT String Maybe&lt;/code&gt; action where the state is the “string left to be be processed”. Remember, a &lt;code&gt;Prim a&lt;/code&gt; contains the character we want to match on, and the &lt;code&gt;a&lt;/code&gt; value we want it to be interpreted as. To process a &lt;code&gt;Prim&lt;/code&gt;, we:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Get the state’s (the string left to be parsed) head and tail, using &lt;code&gt;get&lt;/code&gt;. If this match fails, backtrack.&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;guard&lt;/code&gt;, backtrack unless the head matches what the &lt;code&gt;Prim&lt;/code&gt; expects.&lt;/li&gt;
&lt;li&gt;Set the state to be the original tail, using &lt;code&gt;put&lt;/code&gt;. This is because we parsed the head already, so now the “string left to be parsed” is just the original tail.&lt;/li&gt;
&lt;li&gt;The result is what the &lt;code&gt;Prim&lt;/code&gt; says it should be.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can use this to write a function that matches the &lt;code&gt;RegExp&lt;/code&gt; on a prefix. We need to run the state action (using &lt;code&gt;evalStateT&lt;/code&gt;) on the string we want to parse:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L65-L66&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;matchPrefix ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;matchPrefix re &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; evalStateT (runAlt processPrim re)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And that’s it! Our first solution:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix testRegexp_ &lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcde&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-2&#34;&gt;&lt;a href=&#34;#cb19-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb19-3&#34;&gt;&lt;a href=&#34;#cb19-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix testRegexp_ &lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcdx&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-4&#34;&gt;&lt;a href=&#34;#cb19-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-5&#34;&gt;&lt;a href=&#34;#cb19-5&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix testRegexp &lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcde&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-6&#34;&gt;&lt;a href=&#34;#cb19-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-7&#34;&gt;&lt;a href=&#34;#cb19-7&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix testRegexp &lt;span class=&#34;st&#34;&gt;&amp;quot;bcdcdcdcdcdcdcde&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-8&#34;&gt;&lt;a href=&#34;#cb19-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;7&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-9&#34;&gt;&lt;a href=&#34;#cb19-9&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix digit &lt;span class=&#34;st&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-10&#34;&gt;&lt;a href=&#34;#cb19-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-11&#34;&gt;&lt;a href=&#34;#cb19-11&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix bracketDigit &lt;span class=&#34;st&#34;&gt;&amp;quot;[2]&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-12&#34;&gt;&lt;a href=&#34;#cb19-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-13&#34;&gt;&lt;a href=&#34;#cb19-13&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix (many bracketDigit) &lt;span class=&#34;st&#34;&gt;&amp;quot;[2][3][4][5]&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-14&#34;&gt;&lt;a href=&#34;#cb19-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; [&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb19-15&#34;&gt;&lt;a href=&#34;#cb19-15&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchPrefix (&lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; many bracketDigit) &lt;span class=&#34;st&#34;&gt;&amp;quot;[2][3][4][5]&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-16&#34;&gt;&lt;a href=&#34;#cb19-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;14&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;wait-what-just-happened&#34;&gt;Wait, what just happened?&lt;/h4&gt;
&lt;p&gt;Okay, so that might have happened a little quicker than you expected. One minute we were writing our primitive, and the next we had already finished. Here’s the entirety of the code, in a few lines of Haskell:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-3&#34;&gt;&lt;a href=&#34;#cb20-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;matchPrefix ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb20-4&#34;&gt;&lt;a href=&#34;#cb20-4&#34;&gt;&lt;/a&gt;matchPrefix re &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; evalStateT (runAlt processPrim re)&lt;/span&gt;
&lt;span id=&#34;cb20-5&#34;&gt;&lt;a href=&#34;#cb20-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-6&#34;&gt;&lt;a href=&#34;#cb20-6&#34;&gt;&lt;/a&gt;    processPrim (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; c x) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-7&#34;&gt;&lt;a href=&#34;#cb20-7&#34;&gt;&lt;/a&gt;      d&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;ds &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; get&lt;/span&gt;
&lt;span id=&#34;cb20-8&#34;&gt;&lt;a href=&#34;#cb20-8&#34;&gt;&lt;/a&gt;      guard (c &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; d)&lt;/span&gt;
&lt;span id=&#34;cb20-9&#34;&gt;&lt;a href=&#34;#cb20-9&#34;&gt;&lt;/a&gt;      put ds&lt;/span&gt;
&lt;span id=&#34;cb20-10&#34;&gt;&lt;a href=&#34;#cb20-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And now we have a fully functioning regexp parser? What happened?&lt;/p&gt;
&lt;p&gt;From a high-level view, remember that &lt;code&gt;Alt Prim&lt;/code&gt; has, in its structure, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;Prim&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, and &lt;code&gt;many&lt;/code&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Essentially, what &lt;code&gt;runAlt&lt;/code&gt; does is that it uses a given concrete &lt;code&gt;Alternative&lt;/code&gt; (here, &lt;code&gt;StateT String Maybe&lt;/code&gt;) to get the behavior of &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, and &lt;code&gt;many&lt;/code&gt;. But! As we can see from that list, &lt;code&gt;StateT&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; have a built-in behavior for &lt;code&gt;Prim&lt;/code&gt;. And so, that’s where &lt;code&gt;processPrim&lt;/code&gt; comes in.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For &lt;code&gt;Prim&lt;/code&gt;, &lt;code&gt;runAlt&lt;/code&gt; uses &lt;code&gt;processPrim&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;empty&lt;/code&gt;, &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;, and &lt;code&gt;many&lt;/code&gt;, &lt;code&gt;runAlt&lt;/code&gt; uses &lt;code&gt;StateT String Maybe&lt;/code&gt;’s &lt;code&gt;Alternative&lt;/code&gt; instance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, really, 83% of the work was done for us by &lt;code&gt;StateT&lt;/code&gt;’s &lt;code&gt;Alternative&lt;/code&gt; instance, and the other 17% is in &lt;code&gt;processPrim&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Admittedly, this &lt;em&gt;does&lt;/em&gt; feel a little disappointing, or at least anticlimactic. This makes us wonder: why even use &lt;code&gt;Alt&lt;/code&gt; in the first place? Why not just have &lt;code&gt;type RegExp = StateT String Maybe&lt;/code&gt; and write an appropriate &lt;code&gt;char :: Char -&amp;gt; StateT String Maybe Char&lt;/code&gt;? If &lt;code&gt;StateT&lt;/code&gt; does all of the work anyway, why even bother with &lt;code&gt;Alt&lt;/code&gt;, the free Alternative?&lt;/p&gt;
&lt;p&gt;One major advantage we get from using &lt;code&gt;Alt&lt;/code&gt; is that &lt;code&gt;StateT&lt;/code&gt; is…pretty powerful. It’s actually &lt;em&gt;stupid&lt;/em&gt; powerful. It can represent a lot of things…most troubling, it can represent things that &lt;em&gt;are not regular expressions&lt;/em&gt;. For example, something as simple as &lt;code&gt;put &#34;hello&#34; :: StateT String Maybe ()&lt;/code&gt; does not correspond to &lt;em&gt;any&lt;/em&gt; regular expression.&lt;/p&gt;
&lt;p&gt;So, while we can say that &lt;code&gt;Alt Prim&lt;/code&gt; corresponds to “regular expressions, nothing less and nothing more”, we &lt;em&gt;cannot&lt;/em&gt; say the same about &lt;code&gt;StateT String Maybe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt Prim&lt;/code&gt; contains a “perfect fit” representation of a regular expression data type. Everything it can express is a regular expression, and there is nothing it can express that &lt;em&gt;isn’t&lt;/em&gt; a regular expression.&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here, we can think of &lt;code&gt;StateT&lt;/code&gt; as the context that we use to &lt;em&gt;interpret&lt;/em&gt; a &lt;code&gt;RegExp&lt;/code&gt; as a &lt;em&gt;parser&lt;/em&gt;. But, there might be &lt;em&gt;other&lt;/em&gt; ways we want to work with a &lt;code&gt;RegExp&lt;/code&gt;. For example, we might want to inspect it and “print” it out for inspection. This is something we can’t do with &lt;code&gt;StateT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can’t say that &lt;code&gt;StateT String Maybe&lt;/code&gt; “is” a regular expression — only that it can represent a parser based on a regular expression. But we &lt;em&gt;can&lt;/em&gt; say that about &lt;code&gt;Alt Prim&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;using-the-free-structure-directly&#34;&gt;Using the Free structure directly&lt;/h3&gt;
&lt;p&gt;Alright, that’s great and all. But what if we didn’t want to offload 83% of the behavior to a type that has already been written for us. Is there a way we can directly use the structure of &lt;code&gt;Alt&lt;/code&gt; itself to write our parser?&lt;/p&gt;
&lt;p&gt;This is analogous to asking, what if we wanted to actually write a function on a list (by pattern matching on &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;) instead of always using &lt;code&gt;foldMap&lt;/code&gt;? Can we directly operate on the structure of the list instead of using &lt;code&gt;foldMap&lt;/code&gt; with some concrete monoid?&lt;/p&gt;
&lt;p&gt;I’m glad you asked! Let’s look at the definition of the free alternative:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; {&lt;span class=&#34;ot&#34;&gt; alternatives ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;AltF&lt;/span&gt; f a] }&lt;/span&gt;
&lt;span id=&#34;cb21-2&#34;&gt;&lt;a href=&#34;#cb21-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb21-3&#34;&gt;&lt;a href=&#34;#cb21-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;AltF&lt;/span&gt; f a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; r&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (f r) (&lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; f (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a))&lt;/span&gt;
&lt;span id=&#34;cb21-4&#34;&gt;&lt;a href=&#34;#cb21-4&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt;           &lt;span class=&#34;dt&#34;&gt;Pure&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s a mutually recursive (and &lt;a href=&#34;https://twanvl.nl/blog/haskell/non-regular1&#34;&gt;non-regular&lt;/a&gt;) type, so it might be a little confusing. One way to understand &lt;code&gt;Alt&lt;/code&gt; is that &lt;code&gt;Alt xs&lt;/code&gt; contains a &lt;em&gt;list of alternatives&lt;/em&gt;, or a list of &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;s. And each of those alternatives is an &lt;code&gt;AltF&lt;/code&gt;, which is a &lt;em&gt;sequence of &lt;code&gt;f a&lt;/code&gt;s&lt;/em&gt; chained by &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; (as a chain of function applications).&lt;/p&gt;
&lt;p&gt;You can essentially think of &lt;code&gt;AltF f a&lt;/code&gt; as a linked list &lt;code&gt;[f r]&lt;/code&gt;, except with a different &lt;code&gt;r&lt;/code&gt; for each item. &lt;code&gt;Ap&lt;/code&gt; is cons (&lt;code&gt;:&lt;/code&gt;), containing the &lt;code&gt;f r&lt;/code&gt;, and &lt;code&gt;Pure&lt;/code&gt; is nil (&lt;code&gt;[]&lt;/code&gt;). The &lt;code&gt;forall r.&lt;/code&gt; here is &lt;em&gt;-XExistentialQuantification&lt;/em&gt;, and is what lets us have a different intermediate type for each item in our chain.&lt;/p&gt;
&lt;p&gt;All in all, &lt;code&gt;Alt f&lt;/code&gt; is like a list (&lt;code&gt;Alt&lt;/code&gt; list) of lists (&lt;code&gt;AltF&lt;/code&gt; chains), which take turn alternating between alternative lists and application sequences. A list of chains of lists of chains of lists of chains …&lt;/p&gt;
&lt;p&gt;In the big picture, you can think of &lt;code&gt;Alt f&lt;/code&gt; as a “normalized” form of successive or nested &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;s, similar to how &lt;code&gt;[a]&lt;/code&gt; is a “normalized” form of successive &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;Ultimately we want to write a &lt;code&gt;RegExp a -&amp;gt; String -&amp;gt; Maybe a&lt;/code&gt;, which parses a string based on a &lt;code&gt;RegExp&lt;/code&gt;. We can do this using the most basic of all Haskell function-writing techniques: pattern matching on each case, and handling each case.&lt;/p&gt;
&lt;p&gt;First, the top-level &lt;code&gt;Alt&lt;/code&gt; case. When faced with a list of chains, we can try to parse each one. The result is the first success.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L68-L69&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-2&#34;&gt;&lt;a href=&#34;#cb22-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb22-3&#34;&gt;&lt;a href=&#34;#cb22-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;matchAlts ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb22-4&#34;&gt;&lt;a href=&#34;#cb22-4&#34;&gt;&lt;/a&gt;matchAlts (&lt;span class=&#34;dt&#34;&gt;Alt&lt;/span&gt; res) xs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; asum [ matchChain re xs &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; re &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; res ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here, &lt;code&gt;asum :: [Maybe a] -&amp;gt; Maybe a&lt;/code&gt; finds the first &lt;code&gt;Just&lt;/code&gt; (success) in a list of attempts.&lt;/p&gt;
&lt;p&gt;Now, we need to handle the chain case. To do this, we can pattern match on each constructor, and handle each case.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;matchChain ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;AltF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;matchChain (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; c x) next) cs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; _&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;matchChain (&lt;span class=&#34;dt&#34;&gt;Pure&lt;/span&gt; x)             cs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; _&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From here, it’s mostly “type tetris”! We just continually ask GHC what goes in what holes (and what types need to change) until we get something that typechecks.&lt;/p&gt;
&lt;p&gt;In the end of the very mechanical process, we get:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L71-L76&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-3&#34;&gt;&lt;a href=&#34;#cb24-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;matchChain ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;AltF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb24-4&#34;&gt;&lt;a href=&#34;#cb24-4&#34;&gt;&lt;/a&gt;matchChain (&lt;span class=&#34;dt&#34;&gt;Ap&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; c x) next) cs &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; cs &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-5&#34;&gt;&lt;a href=&#34;#cb24-5&#34;&gt;&lt;/a&gt;    []  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-6&#34;&gt;&lt;a href=&#34;#cb24-6&#34;&gt;&lt;/a&gt;    d&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;ds &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; c &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; d    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; matchAlts ((&lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; x) &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; next) ds&lt;/span&gt;
&lt;span id=&#34;cb24-7&#34;&gt;&lt;a href=&#34;#cb24-7&#34;&gt;&lt;/a&gt;         &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;otherwise&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-8&#34;&gt;&lt;a href=&#34;#cb24-8&#34;&gt;&lt;/a&gt;matchChain (&lt;span class=&#34;dt&#34;&gt;Pure&lt;/span&gt; x)             _      &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;If it’s &lt;code&gt;Ap&lt;/code&gt; (analogous to cons, &lt;code&gt;:&lt;/code&gt;), it means we’re in the middle of the chain.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the input string is empty, then we fail to match.&lt;/li&gt;
&lt;li&gt;Otherwise, here’s the interesting thing. We have the &lt;code&gt;Prim r&lt;/code&gt; with the character we want to match, the first letter in the string, and &lt;code&gt;next :: RegExp (r -&amp;gt; a)&lt;/code&gt;, the next &lt;code&gt;RegExp&lt;/code&gt; in our sequential parsing chain.
&lt;ul&gt;
&lt;li&gt;If the match is a success, we continue down the chain, to &lt;code&gt;next&lt;/code&gt;. We just need to massage the types a bit to make it all work out.&lt;/li&gt;
&lt;li&gt;Otherwise, it’s a failure. We’re done here.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If it’s &lt;code&gt;Pure x&lt;/code&gt; (analogous to nil, &lt;code&gt;[]&lt;/code&gt;), it means we’re at the end of the chain. We return the result in &lt;code&gt;Just&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the end though, you don’t really need to understand any of this &lt;em&gt;too&lt;/em&gt; deeply in order to write this. Sure, it’s nice to understand what &lt;code&gt;Ap&lt;/code&gt;, &lt;code&gt;Pure&lt;/code&gt;, &lt;code&gt;AltF&lt;/code&gt;, etc. really “mean”. But, we don’t have to — the types take care of all of it for you :)&lt;/p&gt;
&lt;p&gt;That should be good enough to implement another prefix parser:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts testRegexp_ &lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcde&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; ()&lt;/span&gt;
&lt;span id=&#34;cb25-3&#34;&gt;&lt;a href=&#34;#cb25-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts testRegexp_ &lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcdx&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-4&#34;&gt;&lt;a href=&#34;#cb25-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-5&#34;&gt;&lt;a href=&#34;#cb25-5&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts testRegexp &lt;span class=&#34;st&#34;&gt;&amp;quot;acdcdcde&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-6&#34;&gt;&lt;a href=&#34;#cb25-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-7&#34;&gt;&lt;a href=&#34;#cb25-7&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts testRegexp &lt;span class=&#34;st&#34;&gt;&amp;quot;bcdcdcdcdcdcdcde&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-8&#34;&gt;&lt;a href=&#34;#cb25-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;7&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-9&#34;&gt;&lt;a href=&#34;#cb25-9&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts digit &lt;span class=&#34;st&#34;&gt;&amp;quot;9&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-10&#34;&gt;&lt;a href=&#34;#cb25-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-11&#34;&gt;&lt;a href=&#34;#cb25-11&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts bracketDigit &lt;span class=&#34;st&#34;&gt;&amp;quot;[2]&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-12&#34;&gt;&lt;a href=&#34;#cb25-12&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-13&#34;&gt;&lt;a href=&#34;#cb25-13&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts (many bracketDigit) &lt;span class=&#34;st&#34;&gt;&amp;quot;[2][3][4][5]&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-14&#34;&gt;&lt;a href=&#34;#cb25-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; [&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;4&lt;/span&gt;,&lt;span class=&#34;dv&#34;&gt;5&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb25-15&#34;&gt;&lt;a href=&#34;#cb25-15&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; matchAlts (&lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; many bracketDigit) &lt;span class=&#34;st&#34;&gt;&amp;quot;[2][3][4][5]&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-16&#34;&gt;&lt;a href=&#34;#cb25-16&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;14&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;what-did-we-do&#34;&gt;What did we do?&lt;/h3&gt;
&lt;p&gt;The two attempts here can be compared to using lists via &lt;code&gt;foldMap&lt;/code&gt; vs. using lists via pattern matching.&lt;/p&gt;
&lt;p&gt;Because lists act as a free monoid, &lt;em&gt;any list function&lt;/em&gt; can be written using &lt;code&gt;foldMap&lt;/code&gt; and not directly pattern matching. If this seems unbelievable to you, try finding a function that can’t — you might be surprised!&lt;/p&gt;
&lt;p&gt;However, because lists are an algebraic data type, &lt;em&gt;any list function&lt;/em&gt; can be written using straight up pattern matching on &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One nice thing about list is that, no matter how you assemble it, it always ends up as a series of conses and nil. We say that the free monoid is &lt;em&gt;normalizing&lt;/em&gt;. That is, &lt;code&gt;[1,2,3] &amp;lt;&amp;gt; [4]&lt;/code&gt; has the same representation as &lt;code&gt;[1] &amp;lt;&amp;gt; [2,3] &amp;lt;&amp;gt; [4].&lt;/code&gt; When we pattern match on &lt;code&gt;:&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;, we can’t distinguish between those two original methods of creation.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt&lt;/code&gt; is normalizing as well. An example of a possible variant that is &lt;em&gt;not&lt;/em&gt; normalizing is:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Empty&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb26-2&#34;&gt;&lt;a href=&#34;#cb26-2&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Pure&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb26-3&#34;&gt;&lt;a href=&#34;#cb26-3&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb26-4&#34;&gt;&lt;a href=&#34;#cb26-4&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; r&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Seq&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; r) (&lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; (r &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a))&lt;/span&gt;
&lt;span id=&#34;cb26-5&#34;&gt;&lt;a href=&#34;#cb26-5&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Union&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a) (&lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb26-6&#34;&gt;&lt;a href=&#34;#cb26-6&#34;&gt;&lt;/a&gt;              &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Many&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is how we &lt;em&gt;might&lt;/em&gt; have written &lt;code&gt;RegExp&lt;/code&gt;, if we didn’t know about the free alternative. However, this representation is not normalizing, because we have two &lt;code&gt;RegExp a&lt;/code&gt; values that represent the same regexp:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | a|(b|c)&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-2&#34;&gt;&lt;a href=&#34;#cb27-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;abc1 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-3&#34;&gt;&lt;a href=&#34;#cb27-3&#34;&gt;&lt;/a&gt;abc1 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;`Union`&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;`Union`&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb27-4&#34;&gt;&lt;a href=&#34;#cb27-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-5&#34;&gt;&lt;a href=&#34;#cb27-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | (a|b)|c&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-6&#34;&gt;&lt;a href=&#34;#cb27-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;abc2 ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-7&#34;&gt;&lt;a href=&#34;#cb27-7&#34;&gt;&lt;/a&gt;abc2 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;`Union`&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;) &lt;span class=&#34;ot&#34;&gt;`Union`&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;c&amp;#39;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These two match the same thing. But they have different representations. This representation &lt;em&gt;not&lt;/em&gt; normalizing, since the same regexp can be expressed in two different ways.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Alt Prim&lt;/code&gt; is better because if two regexps are the same…they will correspond to the same &lt;code&gt;Alt Prim&lt;/code&gt;. It forces each value to exist in a “canonical” normalized form.&lt;/p&gt;
&lt;p&gt;This means that when we eventually write our parsing function &lt;code&gt;matchAlts&lt;/code&gt;, &lt;em&gt;we aren’t allowed to care&lt;/em&gt; about “how” the regexps are made. We aren’t &lt;em&gt;allowed&lt;/em&gt; to distinguish between &lt;code&gt;(a|b)|c&lt;/code&gt; and &lt;code&gt;a|(b|c)&lt;/code&gt;. The normalizing property of &lt;code&gt;Alt&lt;/code&gt; means that we are forced to treat both of those the &lt;em&gt;exact&lt;/em&gt; same way. It &lt;em&gt;forces&lt;/em&gt; us to obey the laws about the structures of regular languages.&lt;/p&gt;
&lt;p&gt;It’s easy to imagine a bug that might occur if we accidentally treated &lt;code&gt;(a|b)|c&lt;/code&gt; differently than &lt;code&gt;a|(b|c)&lt;/code&gt; — and indeed it sounds like an easy bug to accidentally make if we are using the non-normalizing representation.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;Alt&lt;/code&gt; instead of rolling our own regexp expression not only enforces our integrity, but it also eliminates a huge class of potential bugs.&lt;/p&gt;
&lt;p&gt;However, it should be noted that, while &lt;code&gt;Alt f&lt;/code&gt; is strongly normalizing with respect to Alternative structure, &lt;code&gt;Alt Prim&lt;/code&gt; isn’t strongly normalizing with respect to &lt;em&gt;regular expressions&lt;/em&gt; structure in every single case. For example, &lt;code&gt;Alt Prim&lt;/code&gt; will still treat &lt;code&gt;a|a&lt;/code&gt; as different from &lt;code&gt;a&lt;/code&gt;. This is mostly because &lt;code&gt;Alt&lt;/code&gt; has to be “agnostic” to &lt;code&gt;f&lt;/code&gt;. But, like with all structural “type safety”, I always follow this rule of thumb: &lt;em&gt;A lot of safety is better than no safety&lt;/em&gt;. This method can’t eliminate &lt;em&gt;all&lt;/em&gt; bugs arising from this angle, but it can eliminate a whoooole lot.&lt;/p&gt;
&lt;h2 id=&#34;some-subtle-caveats&#34;&gt;Some subtle caveats&lt;/h2&gt;
&lt;p&gt;Before we conclude, let’s take some time to clarify a subtle point. Feel free to skip this whole section if you don’t care about the fact that these aren’t identical to the mathematical formalism of regular languages.&lt;/p&gt;
&lt;p&gt;While we can &lt;em&gt;use&lt;/em&gt; &lt;code&gt;RegExp&lt;/code&gt; just like a regular expression, the formal concept of regular expressions is actually slightly different, due to one pesky thing: &lt;strong&gt;laziness&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We really &lt;em&gt;shouldn’t&lt;/em&gt; be too surprised, since laziness actually throws a wrench into a &lt;em&gt;lot&lt;/em&gt; of Haskell abstractions that are based on math. For example, laziness is the reason that lists aren’t “true” mathematical free monoids.&lt;/p&gt;
&lt;p&gt;The reason is that because of laziness and unbounded recursion, we can create an “infinite” regular language: &lt;code&gt;a|aa|aaa|aaaa|aaaaa|aaaaaa|...&lt;/code&gt;, forever and ever. However, infinite regular expressions aren’t allowed in the mathematical version. In Haskell, unfortunately, there is no way to “turn off” recursion: we’re stuck with it.&lt;/p&gt;
&lt;p&gt;Even more unfortunately, this is actually how the &lt;code&gt;Alt&lt;/code&gt; encoding of the free alternative above implements &lt;code&gt;many&lt;/code&gt;. &lt;code&gt;a*&lt;/code&gt; is implemented as &lt;code&gt;|a|aa|aaa|aaaa|aaaaa|...&lt;/code&gt;, infinitely. So the representation actually &lt;em&gt;relies&lt;/em&gt; on laziness and infinite recursion to do its job. If you look at the contents of &lt;code&gt;many (char &#39;a&#39;)&lt;/code&gt;, you will see an infinite list.&lt;/p&gt;
&lt;p&gt;“Haskell without recursion” is fine with &lt;code&gt;Alt&lt;/code&gt; for a “&lt;a href=&#34;https://en.wikipedia.org/wiki/Star-free_language&#34;&gt;star-free language&lt;/a&gt;”, but it won’t cut it for a regular one.&lt;/p&gt;
&lt;p&gt;For the purposes we talked about in this post, this doesn’t matter. However, this does create serious issues if we want to write a &lt;a href=&#34;https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton&#34;&gt;non-deterministic finite automata based parser&lt;/a&gt; (NFA), which is the de facto standard for implementing fast regexp parsers. We can only really generate an NFA if we have a &lt;em&gt;finite&lt;/em&gt; value, which means anything using &lt;code&gt;many&lt;/code&gt; is out of the question.&lt;/p&gt;
&lt;p&gt;Not all hope is lost, however. We can actually use the “final encoding” of &lt;code&gt;Alt&lt;/code&gt;, from &lt;em&gt;Control.Alternative.Free.Final&lt;/em&gt;, to gain a &lt;code&gt;many&lt;/code&gt; that is non-recursive.&lt;/p&gt;
&lt;p&gt;Using the final encoding means we lose the “pattern match” method, and can only use the &lt;code&gt;runAlt&lt;/code&gt; method. However, we can off-load to &lt;code&gt;Alternative&lt;/code&gt; instances that have non-recursive &lt;code&gt;many&lt;/code&gt; (like the &lt;code&gt;RE&lt;/code&gt; type from &lt;em&gt;regex-applicative&lt;/em&gt;) that allows us to generate an NFA parser. While this still has issues because Haskell allows general recursion, at least &lt;code&gt;many&lt;/code&gt; in specific is no longer dependent on infinite structures.&lt;/p&gt;
&lt;p&gt;There’s another interesting point to be made, however, regarding compatibility with NFAs. Even though this recursive encoding doesn’t allow us to create an &lt;em&gt;explicit&lt;/em&gt; NFA (a full graph with nodes and transitions), it does allow us to make an &lt;em&gt;implicit&lt;/em&gt; one. We can’t ever make an &lt;em&gt;explicit&lt;/em&gt; NFA involving &lt;code&gt;many&lt;/code&gt; because the naive &lt;code&gt;many&lt;/code&gt; in the normal &lt;code&gt;Alt&lt;/code&gt; gives us an infinite data structure, so we get an infinite graph.&lt;/p&gt;
&lt;p&gt;However, our implementation of &lt;code&gt;matchPrefix&lt;/code&gt; is actually an &lt;em&gt;implicit&lt;/em&gt; NFA in the GHC runtime, where the ‘states’ can be considered function pointers on the heap. These pointers refer to other pointers, and the overall behavior works like an unoptimized NFA under the hood that’s assembled as we go. This circumvents the infinite data structure problem because GHC Haskell internally implements recursion by cycles in pointer structures.&lt;/p&gt;
&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;Let’s wrap things up! As a cherry on top, we can write our final function to find matches anywhere inside a string by using &lt;code&gt;tails&lt;/code&gt; (which gives us all prefixes in a string) and &lt;code&gt;mapMaybe&lt;/code&gt; (which maps &lt;code&gt;matchPrefix&lt;/code&gt; on every prefix and keeps the successes). It’s also useful to write a function to get the &lt;em&gt;first&lt;/em&gt; successful match, using &lt;code&gt;listToMaybe&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs#L78-L82&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-2&#34;&gt;&lt;a href=&#34;#cb28-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-3&#34;&gt;&lt;a href=&#34;#cb28-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;matches ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [a]&lt;/span&gt;
&lt;span id=&#34;cb28-4&#34;&gt;&lt;a href=&#34;#cb28-4&#34;&gt;&lt;/a&gt;matches re &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; mapMaybe (matchPrefix re) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; tails&lt;/span&gt;
&lt;span id=&#34;cb28-5&#34;&gt;&lt;a href=&#34;#cb28-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-6&#34;&gt;&lt;a href=&#34;#cb28-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;firstMatch ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;RegExp&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb28-7&#34;&gt;&lt;a href=&#34;#cb28-7&#34;&gt;&lt;/a&gt;firstMatch re &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; listToMaybe &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; matches re&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is pretty efficient, due to how &lt;code&gt;matchPrefix&lt;/code&gt; short-circuits with &lt;code&gt;Nothing&lt;/code&gt; as soon as it fails, and how &lt;code&gt;listToMaybe&lt;/code&gt; short-circuits as soon as it finds a &lt;code&gt;Just&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Hopefully from this, you can see the value of free structures :)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Given some base primitive, they give you exactly the structure you need — no more, no less.&lt;/li&gt;
&lt;li&gt;They let you work with your type safely, and then unsafely “run” it inside different useful contexts.&lt;/li&gt;
&lt;li&gt;They are normalizing, so you are not allowed to make “illegal” distinctions. This eliminates a class of bugs where you accidentally treat two cases differently when they are meant to be treated the same way.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our journey from going to regular languages to &lt;code&gt;Alt Prim&lt;/code&gt; was to recognize that the structures involved in regular expressions matched an &lt;code&gt;Alternative&lt;/code&gt; interface “plus” some extra primitives — and then shifting our perspective to enriching a primitive with &lt;code&gt;Alternative&lt;/code&gt; energy.&lt;/p&gt;
&lt;p&gt;Where can we go from here? First, try playing around with the &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs&#34;&gt;sample code&lt;/a&gt;. One easy addition would be to add other types of primitives:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Prim&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-2&#34;&gt;&lt;a href=&#34;#cb29-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;dt&#34;&gt;Only&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; a                 &lt;span class=&#34;co&#34;&gt;-- ^ match a char with a given result&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-3&#34;&gt;&lt;a href=&#34;#cb29-3&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Letter&lt;/span&gt; a                    &lt;span class=&#34;co&#34;&gt;-- ^ match any letter with the same result&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-4&#34;&gt;&lt;a href=&#34;#cb29-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Digit&lt;/span&gt;    (&lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;  &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)        &lt;span class=&#34;co&#34;&gt;-- ^ match any digit, with a result computed from it&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-5&#34;&gt;&lt;a href=&#34;#cb29-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Wildcard&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)        &lt;span class=&#34;co&#34;&gt;-- ^ match any char, with a computed result&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-6&#34;&gt;&lt;a href=&#34;#cb29-6&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Satisfy&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; a)   &lt;span class=&#34;co&#34;&gt;-- ^ match potentially any char, based on a function&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;so we can support a lot of the basic character classes that many implementations of regular expressions support. Try this out in the &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/misc/regexp.hs&#34;&gt;sample code&lt;/a&gt; as an exercise!&lt;/p&gt;
&lt;p&gt;One fun thing you can do also is to use our regexp type to generate a string that it would match on. Try doing this both in the &lt;code&gt;runAlt&lt;/code&gt;-based method and also the explicit pattern matching method!&lt;/p&gt;
&lt;p&gt;Another interesting direction we can take, along the lines of &lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/build-systems-la-carte/&#34;&gt;build systems a la carte&lt;/a&gt;, is experimenting with different free structures to give rise to different types of languages/expressions. For example, if we use the free &lt;em&gt;Applicative&lt;/em&gt;, we get a language that has only concatenation and empty strings and primitives, and no alternations. It’s like regular expressions with no &lt;code&gt;|&lt;/code&gt;, or basically only straight up matches. If we use the free &lt;em&gt;Monad&lt;/em&gt;, we get a context-sensitive language with no backtracking. If we use the free &lt;em&gt;MonadPlus&lt;/em&gt;, we get a context-sensitive language with backtracking. And if we use the (redundant) free &lt;em&gt;Functor&lt;/em&gt;…we get a language that can parse a string of one and only one character. It’s nice that we get this sort of “a la carte” scaling system by our choice of free structure.&lt;/p&gt;
&lt;p&gt;I hope that after working through this example, you will begin to start recognizing opportunities for using free structures everywhere you look! Once you start, it’s hard to stop :)&lt;/p&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporters at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Sam Stites and Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;A caveat exists here for &lt;code&gt;many&lt;/code&gt;. More on this later!&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Note that there are some caveats that should be noted here, due to laziness in Haskell. We will go deeper into this later.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Math</category><guid isPermaLink="true">https://blog.jle.im/entry/free-alternative-regexp.html</guid><pubDate>Mon,  8 Apr 2019 19:42:09 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Math</subject><date>2019-04-08</date></item><item><title>Visualizing Prequel Meme Prefix Tries with Recursion Schemes</title><link>https://blog.jle.im/entry/tries-with-recursion-schemes.html</link><description>&lt;p&gt;Not too long ago, I was browsing the &lt;a href=&#34;https://www.reddit.com/r/PrequelMemes&#34;&gt;prequel memes subreddit&lt;/a&gt; — a community built around creative ways of remixing and re-contextualizing quotes from the cinematic corpus of the three &lt;a href=&#34;https://en.wikipedia.org/wiki/Star_Wars_prequel_trilogy&#34;&gt;Star Wars “prequel” movies&lt;/a&gt; — when I noticed that a fad was in progress &lt;a href=&#34;https://www.reddit.com/r/PrequelMemes/comments/9w59t4/i_expanded_it/&#34;&gt;constructing tries based on quotes as keys&lt;/a&gt; indexing stills from the movie corresponding to those quotes.&lt;/p&gt;
&lt;p&gt;This inspired me to try playing around with some tries myself, and it gave me an excuse to play around with &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/recursion-schemes&#34;&gt;recursion-schemes&lt;/a&gt;&lt;/em&gt; (one of my favorite Haskell libraries). If you haven’t heard about it yet, &lt;em&gt;recursion-schemes&lt;/em&gt; (and the similar library &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/data-fix&#34;&gt;data-fix&lt;/a&gt;&lt;/em&gt;) abstracts over common recursive functions written on recursive data types. It exploits the fact that a lot of recursive functions for different recursive data types all really follow the same pattern and gives us powerful tools for writing cleaner and safer code, and also for seeing our data types in a different light. The library is a pathway to many viewpoints — some considered to be particularly natural.&lt;/p&gt;
&lt;p&gt;Recursion schemes is a perfect example of those amazing accidents that happen throughout the Haskell ecosystem: an extremely “theoretically beautiful” abstraction that also happens to be extremely useful for writing industrially rigorous code.&lt;/p&gt;
&lt;p&gt;Is it possible to learn this power? Yes! As a fun intermediate-level Haskell project, let’s build a trie data type in Haskell based on &lt;em&gt;recursion-schemes&lt;/em&gt; to see what it has to offer!&lt;/p&gt;
&lt;h2 id=&#34;its-trie-then&#34;&gt;It’s Trie, Then&lt;/h2&gt;
&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Trie&#34;&gt;trie&lt;/a&gt; (prefix tree) is a classic example of a simple yet powerful data type most people first encounter in college courses (I remember being introduced to it through a project implementing a boggle solver). The name comes from a pun on the word “re-&lt;em&gt;trie&lt;/em&gt;-val”.&lt;/p&gt;
&lt;p&gt;Wikipedia has a nice picture:&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;/img/entries/trie/wiki-trie.png&#34; title=&#34;An example Trie&#34; alt=&#34;&#34; /&gt;&lt;figcaption&gt;Sample Trie from Wikipedia, indexing lists of Char to Ints&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;API-wise, it is very similar to an &lt;em&gt;associative map&lt;/em&gt;, like the &lt;code&gt;Map&lt;/code&gt; type from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html&#34;&gt;containers&lt;/a&gt;&lt;/em&gt;. It stores “keys” to “values”, and you can insert a value at a given key, lookup or check for a value stored at a given key, or delete the value at a given key. However, it is designed to be easy to (iteratively) find keys matching a given &lt;em&gt;prefix&lt;/em&gt;. It’s also really fast to check if a given key is &lt;em&gt;not&lt;/em&gt; in the trie, since it can return &lt;code&gt;False&lt;/code&gt; as soon as a prefix is not found anywhere in the trie.&lt;/p&gt;
&lt;p&gt;The main difference is in implementation: the keys are &lt;em&gt;strings of tokens&lt;/em&gt;, and it is internally represented as a multi-level tree: if your keys are strings, then the first level branches on the first letter, the second level is the letter, etc. In the example above, the trie stores the keys &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;tea&lt;/code&gt;, &lt;code&gt;ted&lt;/code&gt;, &lt;code&gt;ten&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, and &lt;code&gt;inn&lt;/code&gt; to the values 7, 3, 4, 12, 15, 11, 5, and 9, respectively. As we see, it is possible for one key to completely overlap another (like &lt;code&gt;in&lt;/code&gt; storing 5, and &lt;code&gt;inn&lt;/code&gt; storing 9). We can also have &lt;em&gt;partial&lt;/em&gt; overlaps (like &lt;code&gt;tea&lt;/code&gt;, storing 3, and &lt;code&gt;ted&lt;/code&gt; storing 4), whose common prefix (&lt;code&gt;te&lt;/code&gt;) has no value stored under it.&lt;/p&gt;
&lt;h2 id=&#34;haskell-tries&#34;&gt;Haskell Tries&lt;/h2&gt;
&lt;p&gt;We can represent this in Haskell by representing each layer as a &lt;code&gt;Map&lt;/code&gt; of a token to the next layer of subtries.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb1-1&#34;&gt;&lt;a href=&#34;#cb1-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L32-L33&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-2&#34;&gt;&lt;a href=&#34;#cb1-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb1-3&#34;&gt;&lt;a href=&#34;#cb1-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt;  k v   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) (&lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; k (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v))&lt;/span&gt;
&lt;span id=&#34;cb1-4&#34;&gt;&lt;a href=&#34;#cb1-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;Trie k v&lt;/code&gt; will have keys of type &lt;code&gt;[k]&lt;/code&gt;, where &lt;code&gt;k&lt;/code&gt; is the key token type, and values of type &lt;code&gt;v&lt;/code&gt;. Each layer might have a value (&lt;code&gt;Maybe v&lt;/code&gt;), and branches out to each new layer.&lt;/p&gt;
&lt;p&gt;We could write the trie storing &lt;code&gt;(to, 9)&lt;/code&gt;, &lt;code&gt;(ton, 3)&lt;/code&gt;, and &lt;code&gt;(tax, 2)&lt;/code&gt; as:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb2-1&#34;&gt;&lt;a href=&#34;#cb2-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L48-L61&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-2&#34;&gt;&lt;a href=&#34;#cb2-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-3&#34;&gt;&lt;a href=&#34;#cb2-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;testTrie ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Char&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb2-4&#34;&gt;&lt;a href=&#34;#cb2-4&#34;&gt;&lt;/a&gt;testTrie &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb2-5&#34;&gt;&lt;a href=&#34;#cb2-5&#34;&gt;&lt;/a&gt;      (&lt;span class=&#34;ch&#34;&gt;&amp;#39;t&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb2-6&#34;&gt;&lt;a href=&#34;#cb2-6&#34;&gt;&lt;/a&gt;          (&lt;span class=&#34;ch&#34;&gt;&amp;#39;o&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb2-7&#34;&gt;&lt;a href=&#34;#cb2-7&#34;&gt;&lt;/a&gt;              ( &lt;span class=&#34;ch&#34;&gt;&amp;#39;n&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;) M.empty )&lt;/span&gt;
&lt;span id=&#34;cb2-8&#34;&gt;&lt;a href=&#34;#cb2-8&#34;&gt;&lt;/a&gt;            ]&lt;/span&gt;
&lt;span id=&#34;cb2-9&#34;&gt;&lt;a href=&#34;#cb2-9&#34;&gt;&lt;/a&gt;          )&lt;/span&gt;
&lt;span id=&#34;cb2-10&#34;&gt;&lt;a href=&#34;#cb2-10&#34;&gt;&lt;/a&gt;        , (&lt;span class=&#34;ch&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb2-11&#34;&gt;&lt;a href=&#34;#cb2-11&#34;&gt;&lt;/a&gt;              ( &lt;span class=&#34;ch&#34;&gt;&amp;#39;x&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;) M.empty )&lt;/span&gt;
&lt;span id=&#34;cb2-12&#34;&gt;&lt;a href=&#34;#cb2-12&#34;&gt;&lt;/a&gt;            ]&lt;/span&gt;
&lt;span id=&#34;cb2-13&#34;&gt;&lt;a href=&#34;#cb2-13&#34;&gt;&lt;/a&gt;          )&lt;/span&gt;
&lt;span id=&#34;cb2-14&#34;&gt;&lt;a href=&#34;#cb2-14&#34;&gt;&lt;/a&gt;        ]&lt;/span&gt;
&lt;span id=&#34;cb2-15&#34;&gt;&lt;a href=&#34;#cb2-15&#34;&gt;&lt;/a&gt;      )&lt;/span&gt;
&lt;span id=&#34;cb2-16&#34;&gt;&lt;a href=&#34;#cb2-16&#34;&gt;&lt;/a&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this construction isn’t particularly sound, since it’s possible to represent invalid keys that have branches that lead to nothing. This becomes troublesome mostly when we implement &lt;code&gt;delete&lt;/code&gt;, but we won’t be worrying about that for now. In Haskell, we have the choice to be as safe or unsafe as we want for a given situation. However, a “correct-by-construction” trie is in the next part of this series :)&lt;/p&gt;
&lt;h3 id=&#34;recursion-schemes-an-elegant-weapon&#34;&gt;Recursion Schemes: An Elegant Weapon&lt;/h3&gt;
&lt;p&gt;Now, &lt;code&gt;Trie&lt;/code&gt; as written up there is an &lt;em&gt;explicitly recursive&lt;/em&gt; data type. This might be common practice, but it’s not a particularly ideal situation. The problem with explicitly recursive data types is that to work with them, you often rely on explicitly recursive functions.&lt;/p&gt;
&lt;p&gt;Within the functional programming community, explicitly recursive functions are notoriously difficult to write, understand, and maintain. It’s extremely easy to accidentally write an infinite loop, and explicit recursion is often called “the GOTO of functional programming”.&lt;/p&gt;
&lt;p&gt;However, there’s a trick we can use to “factor out” the recursion in our data type. The trick is to replace the recursive occurrence of &lt;code&gt;Trie k v&lt;/code&gt; (in the &lt;code&gt;Map&lt;/code&gt; constructor) with a “placeholder” variable:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L32-L36&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt;  k v   &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt;  (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) (&lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; k (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v))&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v x &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) (&lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; k x         )&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Functor&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;TrieF&lt;/code&gt; represents, essentially, “one layer” of a &lt;code&gt;Trie&lt;/code&gt;. It contains all of the &lt;em&gt;structure&lt;/em&gt; of a &lt;em&gt;single&lt;/em&gt; layer of a &lt;code&gt;Trie&lt;/code&gt;: it contains all of the “guts” of what makes a trie a trie, &lt;em&gt;except the recursion&lt;/em&gt;. It allows us to work with a single layer of a trie, encapsulating the essential structure. Later on, we’ll see that this means we sometimes don’t even need the original (recursive) &lt;code&gt;Trie&lt;/code&gt; at all, if all we just care about is the structure.&lt;/p&gt;
&lt;p&gt;For the rest of our journey, we’ll use &lt;code&gt;TrieF&lt;/code&gt; as a non-recursive “view” into a single layer of a &lt;code&gt;Trie&lt;/code&gt;. We can do this because &lt;em&gt;recursion-schemes&lt;/em&gt; gives combinators (known as “recursion schemes”) to abstract over common explicit recursion patterns. The key to using &lt;em&gt;recursion-schemes&lt;/em&gt; is recognizing which combinators abstracts over the type of recursion you’re using. It’s all about becoming familiar with the “zoo” of (colorfully named) recursion schemes you can pick from, and identifying which one does the job in your situation.&lt;/p&gt;
&lt;p&gt;That’s the high-level view — let’s dive into writing out the API of our &lt;code&gt;Trie&lt;/code&gt;!&lt;/p&gt;
&lt;h3 id=&#34;coarse-boilerplate&#34;&gt;Coarse boilerplate&lt;/h3&gt;
&lt;p&gt;One thing we need to do before we can start: we need to tell &lt;em&gt;recursion-schemes&lt;/em&gt; to link &lt;code&gt;TrieF&lt;/code&gt; with &lt;code&gt;Trie&lt;/code&gt;. In the nomenclature of &lt;em&gt;recursion-schemes&lt;/em&gt;, &lt;code&gt;TrieF&lt;/code&gt; is known as the “base type”, and &lt;code&gt;Trie&lt;/code&gt; is called “the fixed-point”.&lt;/p&gt;
&lt;p&gt;Linking them requires some boilerplate, which is basically telling &lt;em&gt;recursion-schemes&lt;/em&gt; how to convert back and forth between &lt;code&gt;Trie&lt;/code&gt; and &lt;code&gt;TrieF&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb4-1&#34;&gt;&lt;a href=&#34;#cb4-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L38-L46&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-2&#34;&gt;&lt;a href=&#34;#cb4-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-3&#34;&gt;&lt;a href=&#34;#cb4-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Base&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb4-4&#34;&gt;&lt;a href=&#34;#cb4-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-5&#34;&gt;&lt;a href=&#34;#cb4-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Recursive&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-6&#34;&gt;&lt;a href=&#34;#cb4-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    project ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v)&lt;/span&gt;
&lt;span id=&#34;cb4-7&#34;&gt;&lt;a href=&#34;#cb4-7&#34;&gt;&lt;/a&gt;    project (&lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; v xs) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v xs&lt;/span&gt;
&lt;span id=&#34;cb4-8&#34;&gt;&lt;a href=&#34;#cb4-8&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-9&#34;&gt;&lt;a href=&#34;#cb4-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Corecursive&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v) &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb4-10&#34;&gt;&lt;a href=&#34;#cb4-10&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    embed ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb4-11&#34;&gt;&lt;a href=&#34;#cb4-11&#34;&gt;&lt;/a&gt;    embed (&lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v xs) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; v xs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically, we are linking the constructors and fields of &lt;code&gt;MkT&lt;/code&gt; and &lt;code&gt;MkTF&lt;/code&gt; together.&lt;/p&gt;
&lt;p&gt;Like the adolescent Anakin Skywalker, we usually don’t like boilerplate. It’s coarse and rough and irritating, and it gets everywhere. As with all boilerplate, it is sometimes useful to clean it up a bit using Template Haskell. The &lt;em&gt;recursion-schemes&lt;/em&gt; library offers such a splice:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb5-1&#34;&gt;&lt;a href=&#34;#cb5-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) (&lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; k (&lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v))&lt;/span&gt;
&lt;span id=&#34;cb5-2&#34;&gt;&lt;a href=&#34;#cb5-2&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;deriving&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Show&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-3&#34;&gt;&lt;a href=&#34;#cb5-3&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb5-4&#34;&gt;&lt;a href=&#34;#cb5-4&#34;&gt;&lt;/a&gt;makeBaseFunctor &amp;#39;&lt;span class=&#34;dt&#34;&gt;&amp;#39;Trie&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will define &lt;code&gt;TrieF&lt;/code&gt; with the &lt;code&gt;MkTF&lt;/code&gt; constructor, and not just the &lt;code&gt;Base&lt;/code&gt; type family, but the &lt;code&gt;Recursive&lt;/code&gt; and &lt;code&gt;Corecursive&lt;/code&gt; instances, too. It might even be more efficient than our hand-written way.&lt;/p&gt;
&lt;h2 id=&#34;humbly-making-our-way-across-the-universe&#34;&gt;Humbly making our way across the universe&lt;/h2&gt;
&lt;p&gt;Time to explore the “zoo” of recursion schemes a bit! This is where the fun begins.&lt;/p&gt;
&lt;p&gt;Whenever you get a new recursive type and base functor, a good first thing to try out is testing out &lt;code&gt;cata&lt;/code&gt; and &lt;code&gt;ana&lt;/code&gt; (catamorphisms and anamorphisms), the basic “folder” and “unfolder”.&lt;/p&gt;
&lt;h3 id=&#34;ill-try-folding-thats-a-good-trick&#34;&gt;I’ll try folding, that’s a good trick!&lt;/h3&gt;
&lt;p&gt;Catamorphisms are functions that “combine” or “fold” every layer of our recursive type into a single value. If we want to write a function of type &lt;code&gt;Trie k v -&amp;gt; A&lt;/code&gt;, we can reach first for a catamorphism.&lt;/p&gt;
&lt;p&gt;Catamorphisms work by folding layer-by-layer, from the bottom up. We can write one by defining “what to do with each layer”. This description comes in the form of an “algebra” in terms of the base functor:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb6-1&#34;&gt;&lt;a href=&#34;#cb6-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;myAlg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v &lt;span class=&#34;dt&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we think of &lt;code&gt;TrieF k v a&lt;/code&gt; as “one layer” of a &lt;code&gt;Trie k v&lt;/code&gt;, then &lt;code&gt;TrieF k v A -&amp;gt; A&lt;/code&gt; describes how to fold up one layer of our &lt;code&gt;Trie k v&lt;/code&gt; into our final result value (here, of type &lt;code&gt;A&lt;/code&gt;). Remember that a &lt;code&gt;TrieF k v A&lt;/code&gt; contains a &lt;code&gt;Maybe v&lt;/code&gt; and a &lt;code&gt;Map k A&lt;/code&gt;. The &lt;code&gt;A&lt;/code&gt; we are given (as the values of the given map) are the results of folding up all of the original subtries along each key; it’s the “results so far”. The values in the map become the very things we swore to create.&lt;/p&gt;
&lt;p&gt;Then, we use &lt;code&gt;cata&lt;/code&gt; to “fold” our value along the algebra:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb7-1&#34;&gt;&lt;a href=&#34;#cb7-1&#34;&gt;&lt;/a&gt;cata&lt;span class=&#34;ot&#34;&gt; myAlg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;cata&lt;/code&gt; starts from the bottom-most layer, runs &lt;code&gt;myAlg&lt;/code&gt; on that, then goes up a layer, running &lt;code&gt;myAlg&lt;/code&gt; on the results, then goes up another layer, running &lt;code&gt;myAlg&lt;/code&gt; on those results, etc., until it reaches the top layer and runs &lt;code&gt;myAlg&lt;/code&gt; again to produce the final result.&lt;/p&gt;
&lt;p&gt;For example, we’ll write a catamorphism that counts how many values/leaves we have in our trie as an &lt;code&gt;Int&lt;/code&gt;. Since our result is an &lt;code&gt;Int&lt;/code&gt;, we know we want an algebra returning an &lt;code&gt;Int&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb8-1&#34;&gt;&lt;a href=&#34;#cb8-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;countAlg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is the basic structure of an algebra: our final result type (&lt;code&gt;Int&lt;/code&gt;) becomes the parameter of &lt;code&gt;TrieF k v&lt;/code&gt; (as &lt;code&gt;TrieF k v Int&lt;/code&gt;), and also the result of our algebra.&lt;/p&gt;
&lt;p&gt;Remember that a &lt;code&gt;Trie k v&lt;/code&gt; contains a &lt;code&gt;Maybe v&lt;/code&gt; and a &lt;code&gt;Map k (Trie k v)&lt;/code&gt;, and a &lt;code&gt;TrieF k v Int&lt;/code&gt; contains a &lt;code&gt;Maybe v&lt;/code&gt; and a &lt;code&gt;Map k Int&lt;/code&gt;. In a &lt;code&gt;Trie k v&lt;/code&gt;, the &lt;code&gt;Map&lt;/code&gt; contains all of the subtries under each branch. For &lt;code&gt;countAlg&lt;/code&gt;, in our &lt;code&gt;TrieF k v Int&lt;/code&gt; we are given, the &lt;code&gt;Map&lt;/code&gt; contains the &lt;em&gt;counts&lt;/em&gt; of each of those original subtries under each branch.&lt;/p&gt;
&lt;p&gt;Basically, our task is “Given a map of sub-counts, how do we find the total count?”&lt;/p&gt;
&lt;p&gt;With this in mind, we can write &lt;code&gt;countAlg&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb9-1&#34;&gt;&lt;a href=&#34;#cb9-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L66-L71&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-2&#34;&gt;&lt;a href=&#34;#cb9-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-3&#34;&gt;&lt;a href=&#34;#cb9-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;countAlg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-4&#34;&gt;&lt;a href=&#34;#cb9-4&#34;&gt;&lt;/a&gt;countAlg (&lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v subtrieCounts)&lt;/span&gt;
&lt;span id=&#34;cb9-5&#34;&gt;&lt;a href=&#34;#cb9-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; isJust v  &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; subtrieTotal&lt;/span&gt;
&lt;span id=&#34;cb9-6&#34;&gt;&lt;a href=&#34;#cb9-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;otherwise&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; subtrieTotal&lt;/span&gt;
&lt;span id=&#34;cb9-7&#34;&gt;&lt;a href=&#34;#cb9-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb9-8&#34;&gt;&lt;a href=&#34;#cb9-8&#34;&gt;&lt;/a&gt;    subtrieTotal &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; subtrieCounts&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If &lt;code&gt;v&lt;/code&gt; is indeed a leaf (it’s &lt;code&gt;Just&lt;/code&gt;), then it’s one plus the total counts of all of the subtries (remember, the &lt;code&gt;Map k Int&lt;/code&gt; contains the counts of all of the original subtries, under each key). Otherwise, it’s just the total counts of all of the original subtries.&lt;/p&gt;
&lt;p&gt;Our final &lt;code&gt;count&lt;/code&gt; is, then:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb10-1&#34;&gt;&lt;a href=&#34;#cb10-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L63-L64&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-2&#34;&gt;&lt;a href=&#34;#cb10-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-3&#34;&gt;&lt;a href=&#34;#cb10-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;count ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb10-4&#34;&gt;&lt;a href=&#34;#cb10-4&#34;&gt;&lt;/a&gt;count &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; cata countAlg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb11-1&#34;&gt;&lt;a href=&#34;#cb11-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; count testTrie&lt;/span&gt;
&lt;span id=&#34;cb11-2&#34;&gt;&lt;a href=&#34;#cb11-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can do something similar by writing a summer, as well, to sum up all values inside a trie:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb12-1&#34;&gt;&lt;a href=&#34;#cb12-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L73-L77&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-2&#34;&gt;&lt;a href=&#34;#cb12-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-3&#34;&gt;&lt;a href=&#34;#cb12-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;trieSumAlg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Num&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k a a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb12-4&#34;&gt;&lt;a href=&#34;#cb12-4&#34;&gt;&lt;/a&gt;trieSumAlg (&lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v subtrieSums) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; fromMaybe &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; v &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; subtrieSums&lt;/span&gt;
&lt;span id=&#34;cb12-5&#34;&gt;&lt;a href=&#34;#cb12-5&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb12-6&#34;&gt;&lt;a href=&#34;#cb12-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;trieSum ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Num&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb12-7&#34;&gt;&lt;a href=&#34;#cb12-7&#34;&gt;&lt;/a&gt;trieSum &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; cata trieSumAlg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb13-1&#34;&gt;&lt;a href=&#34;#cb13-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; trieSum testTrie&lt;/span&gt;
&lt;span id=&#34;cb13-2&#34;&gt;&lt;a href=&#34;#cb13-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dv&#34;&gt;14&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the algebra, the &lt;code&gt;subtrieSums :: Map k a&lt;/code&gt; contains the sums of all of the subtries. Under key &lt;code&gt;k&lt;/code&gt;, we have the sum of the subtrie that was originally at kie &lt;code&gt;k&lt;/code&gt;. The algebra, therefore, just adds up all of the subtrie sums with the value at that layer. “Given a map of sub-sums, how do we find a total sum?”&lt;/p&gt;
&lt;h4 id=&#34;down-from-the-high-ground&#34;&gt;Down from the High Ground&lt;/h4&gt;
&lt;p&gt;Catamorphisms are naturally “inside-out”, or “bottom-up”. However, some operations are more naturally “outside-in”, or “top-down”. One immediate example is &lt;code&gt;lookup :: [k] -&amp;gt; Trie k v -&amp;gt; Maybe v&lt;/code&gt;, which is quintessentially “top-down”: it first descends down the first item in the &lt;code&gt;[k]&lt;/code&gt;, then the second, then the third, etc. until you reach the end, and return the &lt;code&gt;Maybe v&lt;/code&gt; at that layer.&lt;/p&gt;
&lt;p&gt;Is that…legal?&lt;/p&gt;
&lt;p&gt;In this case, we can make it legal by inverting control: instead of folding into a &lt;code&gt;Maybe v&lt;/code&gt; directly, fold into a “looker upper”, a &lt;code&gt;[k] -&amp;gt; Maybe v&lt;/code&gt;. We generate a “lookup function” from the bottom-up, and then run that all in the end on the key we want to look up.&lt;/p&gt;
&lt;p&gt;Our algebra will therefore have type:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb14-1&#34;&gt;&lt;a href=&#34;#cb14-1&#34;&gt;&lt;/a&gt;lookupperAlg&lt;/span&gt;
&lt;span id=&#34;cb14-2&#34;&gt;&lt;a href=&#34;#cb14-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb14-3&#34;&gt;&lt;a href=&#34;#cb14-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v ([k] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v)&lt;/span&gt;
&lt;span id=&#34;cb14-4&#34;&gt;&lt;a href=&#34;#cb14-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([k] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A &lt;code&gt;TrieF k v ([k] -&amp;gt; Maybe v)&lt;/code&gt; contains a &lt;code&gt;Maybe v&lt;/code&gt; and a &lt;code&gt;Map k ([k] -&amp;gt; Maybe v)&lt;/code&gt;, or a map of “lookuppers”. Indexed at each key is function of how to look up a given key in the original subtrie.&lt;/p&gt;
&lt;p&gt;So, we are tasked with “how to implement a lookupper, given a map of sub-lookuppers”.&lt;/p&gt;
&lt;p&gt;To do this, we can pattern match on the key we are looking up. If it’s &lt;code&gt;[]&lt;/code&gt;, then we just return the current leaf (if it exists). Otherwise, if it’s &lt;code&gt;k:ks&lt;/code&gt;, we can &lt;em&gt;run the lookupper of the subtrie at key &lt;code&gt;k&lt;/code&gt;&lt;/em&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb15-1&#34;&gt;&lt;a href=&#34;#cb15-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L87-L102&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-2&#34;&gt;&lt;a href=&#34;#cb15-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-3&#34;&gt;&lt;a href=&#34;#cb15-3&#34;&gt;&lt;/a&gt;lookupperAlg&lt;/span&gt;
&lt;span id=&#34;cb15-4&#34;&gt;&lt;a href=&#34;#cb15-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb15-5&#34;&gt;&lt;a href=&#34;#cb15-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v ([k] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v)&lt;/span&gt;
&lt;span id=&#34;cb15-6&#34;&gt;&lt;a href=&#34;#cb15-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([k] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v)&lt;/span&gt;
&lt;span id=&#34;cb15-7&#34;&gt;&lt;a href=&#34;#cb15-7&#34;&gt;&lt;/a&gt;lookupperAlg (&lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v lookuppers) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \&lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-8&#34;&gt;&lt;a href=&#34;#cb15-8&#34;&gt;&lt;/a&gt;    []   &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; v&lt;/span&gt;
&lt;span id=&#34;cb15-9&#34;&gt;&lt;a href=&#34;#cb15-9&#34;&gt;&lt;/a&gt;    k&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;ks &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; M.lookup k lookuppers &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-10&#34;&gt;&lt;a href=&#34;#cb15-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;        &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-11&#34;&gt;&lt;a href=&#34;#cb15-11&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; lookupper &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; lookupper ks&lt;/span&gt;
&lt;span id=&#34;cb15-12&#34;&gt;&lt;a href=&#34;#cb15-12&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-13&#34;&gt;&lt;a href=&#34;#cb15-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;lookup&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb15-14&#34;&gt;&lt;a href=&#34;#cb15-14&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb15-15&#34;&gt;&lt;a href=&#34;#cb15-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; [k]&lt;/span&gt;
&lt;span id=&#34;cb15-16&#34;&gt;&lt;a href=&#34;#cb15-16&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb15-17&#34;&gt;&lt;a href=&#34;#cb15-17&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v&lt;/span&gt;
&lt;span id=&#34;cb15-18&#34;&gt;&lt;a href=&#34;#cb15-18&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;lookup&lt;/span&gt; ks t &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; cata lookupperAlg t ks&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(written using the -XLambdaCase extension, allowing for &lt;code&gt;\case&lt;/code&gt; syntax)&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb16&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb16-1&#34;&gt;&lt;a href=&#34;#cb16-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;lookup&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;to&amp;quot;&lt;/span&gt; testTrie&lt;/span&gt;
&lt;span id=&#34;cb16-2&#34;&gt;&lt;a href=&#34;#cb16-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-3&#34;&gt;&lt;a href=&#34;#cb16-3&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;lookup&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;ton&amp;quot;&lt;/span&gt; testTrie&lt;/span&gt;
&lt;span id=&#34;cb16-4&#34;&gt;&lt;a href=&#34;#cb16-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb16-5&#34;&gt;&lt;a href=&#34;#cb16-5&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;lookup&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;tone&amp;quot;&lt;/span&gt; testTrie&lt;/span&gt;
&lt;span id=&#34;cb16-6&#34;&gt;&lt;a href=&#34;#cb16-6&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that because &lt;code&gt;Map&lt;/code&gt;s have lazy values by default, we only ever actually generate “lookuppers” for subtries under keys that we eventually descend on; any other subtries will be ignored (and no lookuppers are ever generated for them).&lt;/p&gt;
&lt;p&gt;In the end, this version has all of the same performance characteristics as the explicitly recursive one; we’re assembling a “lookupper” that stops as soon as it sees either a failed lookup (so it doesn’t cause any more evaluation later on), or stops when it reaches the end of its list.&lt;/p&gt;
&lt;h4 id=&#34;i-think-the-system-works&#34;&gt;I Think the System Works&lt;/h4&gt;
&lt;p&gt;We’ve now written a couple of non-recursive functions to “query” &lt;code&gt;Trie&lt;/code&gt;. But what was the point, again? What do we gain over writing explicit versions to query Trie? Why couldn’t we just write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb17&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb17-1&#34;&gt;&lt;a href=&#34;#cb17-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L79-L81&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-2&#34;&gt;&lt;a href=&#34;#cb17-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-3&#34;&gt;&lt;a href=&#34;#cb17-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;trieSumExplicit ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Num&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb17-4&#34;&gt;&lt;a href=&#34;#cb17-4&#34;&gt;&lt;/a&gt;trieSumExplicit (&lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; v subtries) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb17-5&#34;&gt;&lt;a href=&#34;#cb17-5&#34;&gt;&lt;/a&gt;    fromMaybe &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; v &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;fmap&lt;/span&gt; trieSumExplicit subtries)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;instead of&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb18&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb18-1&#34;&gt;&lt;a href=&#34;#cb18-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L83-L85&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-2&#34;&gt;&lt;a href=&#34;#cb18-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-3&#34;&gt;&lt;a href=&#34;#cb18-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;trieSumCata ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Num&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb18-4&#34;&gt;&lt;a href=&#34;#cb18-4&#34;&gt;&lt;/a&gt;trieSumCata &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; cata &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \(&lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v subtrieSums) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb18-5&#34;&gt;&lt;a href=&#34;#cb18-5&#34;&gt;&lt;/a&gt;    fromMaybe &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; v &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; subtrieSums&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One major reason, like I mentioned before, is to avoid using &lt;em&gt;explicit recursion&lt;/em&gt;. It’s extremely easy when using explicit recursion to accidentally write an infinite loop, or to mess up your control flow somehow. It’s basically like using &lt;code&gt;GOTO&lt;/code&gt; instead of &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;for&lt;/code&gt; loops in imperative languages. &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; loops are meant to abstract over a common type of looping control flow, and provide a disciplined structure for them. They also are often much easier to read, because as soon as you see “while” or “for”, it gives you a hint at programmer intent in ways that an explicit GOTO might not.&lt;/p&gt;
&lt;p&gt;Another major reason is to allow you to separate concerns. Writing &lt;code&gt;trieSumExplicit&lt;/code&gt; forces you to think “how to fold this entire trie”. Writing &lt;code&gt;trieSumAlg&lt;/code&gt; allows us to just focus on “how to fold &lt;em&gt;this immediate&lt;/em&gt; layer”. You only need to ever focus on the immediate layer you are trying to sum — and never the entire trie. &lt;code&gt;cata&lt;/code&gt; takes your “how to fold this immediate layer” function and turns it into a function that folds an entire trie, taking care of the recursive descent for you.&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Before we move on, I just wanted to mention that &lt;code&gt;cata&lt;/code&gt; is not a magic function. From the clues above, you might actually be able to implement it yourself. For our &lt;code&gt;Trie&lt;/code&gt;, it’s:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb19&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb19-1&#34;&gt;&lt;a href=&#34;#cb19-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L104-L105&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-2&#34;&gt;&lt;a href=&#34;#cb19-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb19-3&#34;&gt;&lt;a href=&#34;#cb19-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;cata&amp;#39; ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb19-4&#34;&gt;&lt;a href=&#34;#cb19-4&#34;&gt;&lt;/a&gt;cata&amp;#39; alg &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; alg &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fmap&lt;/span&gt; (cata&amp;#39; alg) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; project&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First we &lt;code&gt;project :: Trie k v -&amp;gt; TrieF k v (Trie k v)&lt;/code&gt;, to “de-recursive” our type. Then we fmap our entire &lt;code&gt;cata alg :: Trie k v -&amp;gt; a&lt;/code&gt;. Then we run the &lt;code&gt;alg :: TrieF k v a -&amp;gt; a&lt;/code&gt; on the result. Basically, it’s fmap-collapse-then-collapse.&lt;/p&gt;
&lt;p&gt;It might be interesting to note that the implementation of &lt;code&gt;cata&#39;&lt;/code&gt; here requires explicit recursion. One of the purposes of using recursion schemes like &lt;code&gt;cata&lt;/code&gt; is to avoid directly using recursion explicitly, and “off-loading” the recursion to one reusable function. So in a sense, it’s ironic: &lt;code&gt;cata&lt;/code&gt; can save other functions from explicit recursion, but not itself.&lt;/p&gt;
&lt;p&gt;Or, can it? The reason &lt;code&gt;cata&#39;&lt;/code&gt; is necessarily recursive here is that our &lt;code&gt;Trie&lt;/code&gt; data type is recursive. However, we can actually encode &lt;code&gt;Trie&lt;/code&gt; using an alternative representation (in terms of &lt;code&gt;TrieF&lt;/code&gt;), and it’s possible to write &lt;code&gt;cata&#39;&lt;/code&gt; in a non-recursive way:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb20&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb20-1&#34;&gt;&lt;a href=&#34;#cb20-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L107-L110&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-2&#34;&gt;&lt;a href=&#34;#cb20-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-3&#34;&gt;&lt;a href=&#34;#cb20-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;newtype&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MuTrie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkMT&lt;/span&gt; (&lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; a&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a)&lt;/span&gt;
&lt;span id=&#34;cb20-4&#34;&gt;&lt;a href=&#34;#cb20-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb20-5&#34;&gt;&lt;a href=&#34;#cb20-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;cataMuTrie ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MuTrie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb20-6&#34;&gt;&lt;a href=&#34;#cb20-6&#34;&gt;&lt;/a&gt;cataMuTrie alg (&lt;span class=&#34;dt&#34;&gt;MkMT&lt;/span&gt; f) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; f alg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Trie&#39;&lt;/code&gt; is actually isomorphic to &lt;code&gt;Trie&lt;/code&gt;, so they’re the same type (it’s actually &lt;code&gt;type MuTrie k v = Mu (TrieF k v)&lt;/code&gt;, using &lt;code&gt;Mu&lt;/code&gt; from &lt;em&gt;recursion-schemes&lt;/em&gt;). If you don’t believe me, &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L112-L116&#34;&gt;here’s the isomorphism&lt;/a&gt;. This is actually one way we can encode recursive types in a language that doesn’t have any, like &lt;a href=&#34;https://github.com/sellout/dada/blob/master/Mu/Type&#34;&gt;dhall&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&#34;generating-tries&#34;&gt;Generating Tries&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Anamorphisms&lt;/em&gt;, the dual of catamorphisms, will make another fine addition to our collection. They are functions that “generate” or “unfold” a value of a recursive type, layer-by-layer. If we want to write a function of type &lt;code&gt;A -&amp;gt; Trie k v&lt;/code&gt;, we can reach first for an anamorphism.&lt;/p&gt;
&lt;p&gt;Anamorphisms work by unfolding “layer-by-layer”, from the outside-in (top-down). We write one by defining “how to generate the next layer”. This description comes in the form of a “coalgebra” (pronounced like “co-algebra”, and not like coal energy “coal-gebra”), in terms of the base functor:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb21&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb21-1&#34;&gt;&lt;a href=&#34;#cb21-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;myCoalg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v &lt;span class=&#34;dt&#34;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we think of &lt;code&gt;TrieF k v a&lt;/code&gt; as “one layer” of a &lt;code&gt;Trie k v&lt;/code&gt;, then &lt;code&gt;A -&amp;gt; TrieF k v A&lt;/code&gt; describes how to generate a new nested layer of our &lt;code&gt;Trie k v&lt;/code&gt; from our initial “seed” (here, of type &lt;code&gt;A&lt;/code&gt;). It tells us how to generate the next immediate layer. Remember that a &lt;code&gt;TrieF k v A&lt;/code&gt; contains a &lt;code&gt;Maybe v&lt;/code&gt; and a &lt;code&gt;Map k A&lt;/code&gt;. The &lt;code&gt;A&lt;/code&gt; (the values of the map) are then used to seed the &lt;em&gt;new&lt;/em&gt; subtries. The &lt;code&gt;A&lt;/code&gt;s in the map are the “continue expanding with…” values.&lt;/p&gt;
&lt;p&gt;We can then use &lt;code&gt;ana&lt;/code&gt; to “unfold” our value along the coalgebra:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb22&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb22-1&#34;&gt;&lt;a href=&#34;#cb22-1&#34;&gt;&lt;/a&gt;ana&lt;span class=&#34;ot&#34;&gt; myCoalg ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ana&lt;/code&gt; starts from an initial seed &lt;code&gt;A&lt;/code&gt;, runs &lt;code&gt;myCoalg&lt;/code&gt; on that, and then goes down a layer, running &lt;code&gt;myCoalg&lt;/code&gt; on each value in the map to create new layers, etc., forever and ever. In practice, it usually stops when we return a &lt;code&gt;TrieF&lt;/code&gt; with an empty map, since there are no more seeds to expand down. However, it’s nice to remember we don’t have to special-case this behavior: it arises naturally from the structure of maps.&lt;/p&gt;
&lt;p&gt;While I don’t have a concrete “universal” example (like how we had &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;sum&lt;/code&gt; for &lt;code&gt;cata&lt;/code&gt;), the general idea is that if you want to create a value by repeatedly “expanding leaves”, an anamorphism is a perfect fit.&lt;/p&gt;
&lt;p&gt;An example here that fits well with the nature of a trie is to produce a “singleton trie”: a trie that has only a single value at a single token string key.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb23&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb23-1&#34;&gt;&lt;a href=&#34;#cb23-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L121-L125&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-2&#34;&gt;&lt;a href=&#34;#cb23-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-3&#34;&gt;&lt;a href=&#34;#cb23-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;mkSingletonCoalg ::&lt;/span&gt; v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([k] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v [k])&lt;/span&gt;
&lt;span id=&#34;cb23-4&#34;&gt;&lt;a href=&#34;#cb23-4&#34;&gt;&lt;/a&gt;mkSingletonCoalg v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; singletonCoalg&lt;/span&gt;
&lt;span id=&#34;cb23-5&#34;&gt;&lt;a href=&#34;#cb23-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb23-6&#34;&gt;&lt;a href=&#34;#cb23-6&#34;&gt;&lt;/a&gt;    singletonCoalg []     &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; v) M.empty&lt;/span&gt;
&lt;span id=&#34;cb23-7&#34;&gt;&lt;a href=&#34;#cb23-7&#34;&gt;&lt;/a&gt;    singletonCoalg (k&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;ks) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt;  (M.singleton k ks)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Given a &lt;code&gt;v&lt;/code&gt; value, we’ll make a coalgebra &lt;code&gt;[k] -&amp;gt; TrieF k v [k]&lt;/code&gt;. Our “seed” will be the &lt;code&gt;[k]&lt;/code&gt; key (token string) we want to insert, and we’ll generate our singleton key by making sub-maps with sub-keys.&lt;/p&gt;
&lt;p&gt;Our coalgebra (“layer generating function”) goes like this:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;If our key-to-insert is empty &lt;code&gt;[]&lt;/code&gt;, then we’re here! We’re at &lt;em&gt;the layer&lt;/em&gt; where we want to insert the value at, so &lt;code&gt;MkTF (Just v) M.empty&lt;/code&gt;. Returning &lt;code&gt;M.empty&lt;/code&gt; means that we don’t want to expand anymore, since there are no new seeds to expand into subtries.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;If our key-to-insert is &lt;em&gt;not&lt;/em&gt; empty, then we’re &lt;em&gt;not&lt;/em&gt; here! We return &lt;code&gt;MkTF Nothing&lt;/code&gt;…but we leave a singleton map &lt;code&gt;M.singleton k ks :: Map k [k]&lt;/code&gt; leaving a single seed. When we run our coalgebra with &lt;code&gt;ana&lt;/code&gt;, &lt;code&gt;ana&lt;/code&gt; will go down and expand out that single seed (with our coalgebra) into an entire new sub-trie, with &lt;code&gt;ks&lt;/code&gt; as its seed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, we have &lt;code&gt;singleton&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb24&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb24-1&#34;&gt;&lt;a href=&#34;#cb24-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L118-L119&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-2&#34;&gt;&lt;a href=&#34;#cb24-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb24-3&#34;&gt;&lt;a href=&#34;#cb24-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;singleton ::&lt;/span&gt; [k] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb24-4&#34;&gt;&lt;a href=&#34;#cb24-4&#34;&gt;&lt;/a&gt;singleton k v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; ana (mkSingletonCoalg v) k&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We run the coalgebra on our initial seed (the key), and ana will run &lt;code&gt;singletonCoalg&lt;/code&gt; repeatedly, expanding out all of the seeds we deposit, forever and ever (or at least until there are no more values of the seed type left, which happens if we return an empty map).&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb25&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb25-1&#34;&gt;&lt;a href=&#34;#cb25-1&#34;&gt;&lt;/a&gt;ghci&lt;span class=&#34;op&#34;&gt;&amp;gt;&lt;/span&gt; singleton &lt;span class=&#34;st&#34;&gt;&amp;quot;hi&amp;quot;&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;7&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb25-2&#34;&gt;&lt;a href=&#34;#cb25-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb25-3&#34;&gt;&lt;a href=&#34;#cb25-3&#34;&gt;&lt;/a&gt;    (&lt;span class=&#34;ch&#34;&gt;&amp;#39;h&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb25-4&#34;&gt;&lt;a href=&#34;#cb25-4&#34;&gt;&lt;/a&gt;        (&lt;span class=&#34;ch&#34;&gt;&amp;#39;i&amp;#39;&lt;/span&gt;, &lt;span class=&#34;dt&#34;&gt;MkT&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;7&lt;/span&gt;) M.empty )&lt;/span&gt;
&lt;span id=&#34;cb25-5&#34;&gt;&lt;a href=&#34;#cb25-5&#34;&gt;&lt;/a&gt;      ]&lt;/span&gt;
&lt;span id=&#34;cb25-6&#34;&gt;&lt;a href=&#34;#cb25-6&#34;&gt;&lt;/a&gt;    )&lt;/span&gt;
&lt;span id=&#34;cb25-7&#34;&gt;&lt;a href=&#34;#cb25-7&#34;&gt;&lt;/a&gt;  ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;a-pathway-to-many-subtries&#34;&gt;A pathway to many subtries&lt;/h3&gt;
&lt;p&gt;Now that we’ve got the basics, let’s look at a more interesting anamorphism, where we leave multiple “seeds” along many different keys in the map, to generate many different subtries from our root. Twice the seeds, double the subtries.&lt;/p&gt;
&lt;p&gt;Let’s write a function to generate a &lt;code&gt;Trie k v&lt;/code&gt; from a &lt;code&gt;Map [k] v&lt;/code&gt;: Given a map of keys (as token strings), generate a prefix trie containing every key-value pair in the map.&lt;/p&gt;
&lt;p&gt;This might sound complicated, but let’s remember the philosophy and approach of writing an anamorphism: “How do I generate &lt;em&gt;one layer&lt;/em&gt;”?&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;fromMapCoalg&lt;/code&gt; will take a &lt;code&gt;Map [k] v&lt;/code&gt; and generate &lt;code&gt;TrieF k v (Map [k] v)&lt;/code&gt;: &lt;em&gt;one single layer&lt;/em&gt; of our new Trie (in particular, the &lt;em&gt;top layer&lt;/em&gt;). The values in each of the resultant maps will be later then watered and expanded into their own fully mature subtries.&lt;/p&gt;
&lt;p&gt;So, how do we generate the &lt;em&gt;top layer&lt;/em&gt; of a prefix trie from a map? Well, remember, to make a &lt;code&gt;TrieF k v (Map [k] v)&lt;/code&gt;, we need a &lt;code&gt;Maybe v&lt;/code&gt; (the value at this layer) and a &lt;code&gt;Map k (Map [k] v)&lt;/code&gt; (the map of seeds that will each expand into full subtries).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the map contains &lt;code&gt;[]&lt;/code&gt; (the empty string), then there &lt;em&gt;is a value&lt;/em&gt; at this layer. We will return &lt;code&gt;Just&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;Map k (Map [k] v)&lt;/code&gt;, the value at key &lt;code&gt;k&lt;/code&gt; is a &lt;code&gt;Map&lt;/code&gt; containing all of the key-value pairs in the original map that &lt;em&gt;start with k&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For a concrete example, if we start with &lt;code&gt;M.fromList [(&#34;to&#34;, 9), (&#34;ton&#34;, 3), (&#34;tax&#34;, 2)]&lt;/code&gt;, then we want &lt;code&gt;fromMapCoalg&lt;/code&gt; to produce:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb26&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb26-1&#34;&gt;&lt;a href=&#34;#cb26-1&#34;&gt;&lt;/a&gt;fromMap (M.fromList [(&lt;span class=&#34;st&#34;&gt;&amp;quot;to&amp;quot;&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;), (&lt;span class=&#34;st&#34;&gt;&amp;quot;ton&amp;quot;&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;), (&lt;span class=&#34;st&#34;&gt;&amp;quot;tax&amp;quot;&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)])&lt;/span&gt;
&lt;span id=&#34;cb26-2&#34;&gt;&lt;a href=&#34;#cb26-2&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; (&lt;/span&gt;
&lt;span id=&#34;cb26-3&#34;&gt;&lt;a href=&#34;#cb26-3&#34;&gt;&lt;/a&gt;          M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb26-4&#34;&gt;&lt;a href=&#34;#cb26-4&#34;&gt;&lt;/a&gt;            (&lt;span class=&#34;ch&#34;&gt;&amp;#39;t&amp;#39;&lt;/span&gt;, M.fromList [&lt;/span&gt;
&lt;span id=&#34;cb26-5&#34;&gt;&lt;a href=&#34;#cb26-5&#34;&gt;&lt;/a&gt;                (&lt;span class=&#34;st&#34;&gt;&amp;quot;o&amp;quot;&lt;/span&gt; , &lt;span class=&#34;dv&#34;&gt;9&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb26-6&#34;&gt;&lt;a href=&#34;#cb26-6&#34;&gt;&lt;/a&gt;              , (&lt;span class=&#34;st&#34;&gt;&amp;quot;on&amp;quot;&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;3&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb26-7&#34;&gt;&lt;a href=&#34;#cb26-7&#34;&gt;&lt;/a&gt;              , (&lt;span class=&#34;st&#34;&gt;&amp;quot;ax&amp;quot;&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;)&lt;/span&gt;
&lt;span id=&#34;cb26-8&#34;&gt;&lt;a href=&#34;#cb26-8&#34;&gt;&lt;/a&gt;              ]&lt;/span&gt;
&lt;span id=&#34;cb26-9&#34;&gt;&lt;a href=&#34;#cb26-9&#34;&gt;&lt;/a&gt;            )&lt;/span&gt;
&lt;span id=&#34;cb26-10&#34;&gt;&lt;a href=&#34;#cb26-10&#34;&gt;&lt;/a&gt;          ]&lt;/span&gt;
&lt;span id=&#34;cb26-11&#34;&gt;&lt;a href=&#34;#cb26-11&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The value is &lt;code&gt;Nothing&lt;/code&gt; because we don’t have the empty string (so there is no to-level value), and the map at &lt;code&gt;t&lt;/code&gt; contains all of the original key-value pairs that began with &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now that we have the concept, we can implement it using &lt;code&gt;Data.Map&lt;/code&gt; combinators like &lt;code&gt;M.lookup&lt;/code&gt;, &lt;code&gt;M.toList&lt;/code&gt;, &lt;code&gt;M.fromListWith&lt;/code&gt;, and &lt;code&gt;M.union&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb27&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb27-1&#34;&gt;&lt;a href=&#34;#cb27-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L127-L142&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-2&#34;&gt;&lt;a href=&#34;#cb27-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-3&#34;&gt;&lt;a href=&#34;#cb27-3&#34;&gt;&lt;/a&gt;fromMapCoalg&lt;/span&gt;
&lt;span id=&#34;cb27-4&#34;&gt;&lt;a href=&#34;#cb27-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb27-5&#34;&gt;&lt;a href=&#34;#cb27-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; [k] v&lt;/span&gt;
&lt;span id=&#34;cb27-6&#34;&gt;&lt;a href=&#34;#cb27-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v (&lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; [k] v)&lt;/span&gt;
&lt;span id=&#34;cb27-7&#34;&gt;&lt;a href=&#34;#cb27-7&#34;&gt;&lt;/a&gt;fromMapCoalg mp &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; (M.lookup [] mp)&lt;/span&gt;
&lt;span id=&#34;cb27-8&#34;&gt;&lt;a href=&#34;#cb27-8&#34;&gt;&lt;/a&gt;                       (M.fromListWith M.union&lt;/span&gt;
&lt;span id=&#34;cb27-9&#34;&gt;&lt;a href=&#34;#cb27-9&#34;&gt;&lt;/a&gt;                          [ (k   , M.singleton ks v)&lt;/span&gt;
&lt;span id=&#34;cb27-10&#34;&gt;&lt;a href=&#34;#cb27-10&#34;&gt;&lt;/a&gt;                          &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; (k&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;ks, v) &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; M.toList mp&lt;/span&gt;
&lt;span id=&#34;cb27-11&#34;&gt;&lt;a href=&#34;#cb27-11&#34;&gt;&lt;/a&gt;                          ]&lt;/span&gt;
&lt;span id=&#34;cb27-12&#34;&gt;&lt;a href=&#34;#cb27-12&#34;&gt;&lt;/a&gt;                       )&lt;/span&gt;
&lt;span id=&#34;cb27-13&#34;&gt;&lt;a href=&#34;#cb27-13&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb27-14&#34;&gt;&lt;a href=&#34;#cb27-14&#34;&gt;&lt;/a&gt;fromMap&lt;/span&gt;
&lt;span id=&#34;cb27-15&#34;&gt;&lt;a href=&#34;#cb27-15&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb27-16&#34;&gt;&lt;a href=&#34;#cb27-16&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; [k] v&lt;/span&gt;
&lt;span id=&#34;cb27-17&#34;&gt;&lt;a href=&#34;#cb27-17&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb27-18&#34;&gt;&lt;a href=&#34;#cb27-18&#34;&gt;&lt;/a&gt;fromMap &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; ana fromMapCoalg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And just like that, we have a way to turn a &lt;code&gt;Map [k]&lt;/code&gt; into a &lt;code&gt;Trie k&lt;/code&gt;…all just from describing how to make &lt;em&gt;the top-most layer&lt;/em&gt;. &lt;code&gt;ana&lt;/code&gt; extrapolates the rest!&lt;/p&gt;
&lt;p&gt;Again, we can ask what the point of this is: why couldn’t we just write it directly recursively? The answers are the same as before: first, to avoid potential bugs from explicit recursion. Second, to separate concerns: instead of thinking about how to generate an entire trie, we only need to be think about how to generate a single layer. &lt;code&gt;ana&lt;/code&gt; reads our mind here, and extrapolates out the entire trie.&lt;/p&gt;
&lt;div class=&#34;note&#34;&gt;
&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Again, let’s take some time to reassure ourselves that &lt;code&gt;ana&lt;/code&gt; is not a magic function. You might have been able to guess how it’s implemented: it runs the coalgebra, and then fmaps re-expansion recursively.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb28&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb28-1&#34;&gt;&lt;a href=&#34;#cb28-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L144-L145&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-2&#34;&gt;&lt;a href=&#34;#cb28-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb28-3&#34;&gt;&lt;a href=&#34;#cb28-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;ana&amp;#39; ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb28-4&#34;&gt;&lt;a href=&#34;#cb28-4&#34;&gt;&lt;/a&gt;ana&amp;#39; coalg &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; embed &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fmap&lt;/span&gt; (ana&amp;#39; coalg) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; coalg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;First, we run the &lt;code&gt;coalg :: a -&amp;gt; TrieF k v a&lt;/code&gt;, then we fmap our entire &lt;code&gt;ana coalg :: a -&amp;gt; Trie k v&lt;/code&gt;, then we &lt;code&gt;embed :: TrieF k v (Trie k v) -&amp;gt; Trie k v&lt;/code&gt; back into our recursive type.&lt;/p&gt;
&lt;p&gt;And again, because &lt;code&gt;Trie&lt;/code&gt; is a recursive data type, &lt;code&gt;ana&lt;/code&gt; is also necessarily one. However, like for &lt;code&gt;cata&lt;/code&gt;, we can represent &lt;code&gt;Trie&lt;/code&gt; in a way (in terms of &lt;code&gt;TrieF&lt;/code&gt;) that allows us to write &lt;code&gt;ana&lt;/code&gt; in a non-recursive way:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb29&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb29-1&#34;&gt;&lt;a href=&#34;#cb29-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L147-L150&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-2&#34;&gt;&lt;a href=&#34;#cb29-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-3&#34;&gt;&lt;a href=&#34;#cb29-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;kw&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NuTrie&lt;/span&gt; k v &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;forall&lt;/span&gt; a&lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkNT&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a) a&lt;/span&gt;
&lt;span id=&#34;cb29-4&#34;&gt;&lt;a href=&#34;#cb29-4&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb29-5&#34;&gt;&lt;a href=&#34;#cb29-5&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;anaNuTrie ::&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;NuTrie&lt;/span&gt; k v &lt;/span&gt;
&lt;span id=&#34;cb29-6&#34;&gt;&lt;a href=&#34;#cb29-6&#34;&gt;&lt;/a&gt;anaNuTrie &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;MkNT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;NuTrie k v&lt;/code&gt; here is &lt;code&gt;Nu (TrieF k v)&lt;/code&gt;, from &lt;em&gt;recursion-schemes&lt;/em&gt;. &lt;code&gt;NuTrie&lt;/code&gt; is also isomorphic to &lt;code&gt;Trie&lt;/code&gt; (as seen by &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L152-L156&#34;&gt;this isomorphism&lt;/a&gt;), so they are the same type. We can also use it to represent recursive data types in a non-recursive language (like &lt;a href=&#34;https://github.com/sellout/dada/blob/master/Nu/Type&#34;&gt;dhall&lt;/a&gt;).&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&#34;ive-been-looking-forward-to-this&#34;&gt;I’ve been looking forward to this&lt;/h2&gt;
&lt;p&gt;So those are some examples to get our feet wet; now it’s time to build our prequel meme trie! Yipee!&lt;/p&gt;
&lt;p&gt;We’re going to try to re-create this reference trie: (&lt;a href=&#34;/img/entries/trie/reference-trie.png&#34;&gt;full size here&lt;/a&gt;)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;/img/entries/trie/reference-trie.png&#34; title=&#34;Reference trie&#34; alt=&#34;&#34; /&gt;&lt;figcaption&gt;Reference trie (credit to &lt;a href=&#34;https://www.reddit.com/r/PrequelMemes/comments/9w59t4/i_expanded_it/&#34;&gt;u/Uninventive_Username&lt;/a&gt;)&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;To render our tree, we’re going to be using the &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/graphviz&#34;&gt;graphviz&lt;/a&gt;&lt;/em&gt; library, which generates a &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/DOT_(graph_description_language)&#34;&gt;DOT file&lt;/a&gt;&lt;/em&gt; which the &lt;a href=&#34;https://www.graphviz.org/&#34;&gt;graphviz application&lt;/a&gt; can render. The &lt;em&gt;graphviz&lt;/em&gt; library directly renders a value of the graph data type from &lt;em&gt;&lt;a href=&#34;https://hackage.haskell.org/package/fgl&#34;&gt;fgl&lt;/a&gt;&lt;/em&gt;, the functional graph library that is the de-facto fleshed-out graph manipulation library of the Haskell ecosystem.&lt;/p&gt;
&lt;p&gt;The roadmap seems straightforward:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Load our prequel memes into a &lt;code&gt;Map String Label&lt;/code&gt;, a map of quotes to their associated macro images (as a &lt;code&gt;Label&lt;/code&gt;, which the &lt;em&gt;graphviz&lt;/em&gt; library can render)&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;ana&lt;/code&gt; to turn a &lt;code&gt;Map String Label&lt;/code&gt; into a &lt;code&gt;Trie Char Label&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;cata&lt;/code&gt; to turn a &lt;code&gt;Trie Char Label&lt;/code&gt; into a &lt;code&gt;Gr (Maybe Label) Char&lt;/code&gt; graph of nodes linked by letters, with prequel meme leaves&lt;/li&gt;
&lt;li&gt;Use the &lt;em&gt;graphviz&lt;/em&gt; library to turn that graph into a DOT file, to be rendered by the external graphviz application.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1 and 4 are mainly fumbling around with IO, parsing, and interfacing with libraries, so 2 and 3 are the interesting steps in our case. We actually already wrote 2 (in the previous section — surprise!), so that just leaves 3 to investigate.&lt;/p&gt;
&lt;h3 id=&#34;monadic-catamorphisms-and-fgl&#34;&gt;Monadic catamorphisms and fgl&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;fgl&lt;/em&gt; provides a two (interchangeable) graph types; for the sake of this article, we’re going to be using &lt;code&gt;Gr&lt;/code&gt; from the &lt;em&gt;Data.Graph.Inductive.PatriciaTree&lt;/em&gt; module&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34; role=&#34;doc-noteref&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The type &lt;code&gt;Gr a b&lt;/code&gt; represents a graph of vertices with labels of type &lt;code&gt;a&lt;/code&gt;, and edges with labels of type &lt;code&gt;b&lt;/code&gt;. In our case, for a &lt;code&gt;Trie k v&lt;/code&gt;, we’ll have a graph with nodes of type &lt;code&gt;Maybe v&lt;/code&gt; (the leaves, if they exist) and edges of type &lt;code&gt;k&lt;/code&gt; (the token linking one node to the next).&lt;/p&gt;
&lt;p&gt;Our end goal, then, is to write a function &lt;code&gt;Trie k v -&amp;gt; Gr (Maybe v) k&lt;/code&gt;. Knowing this, we can jump directly into writing an algebra:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb30&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb30-1&#34;&gt;&lt;a href=&#34;#cb30-1&#34;&gt;&lt;/a&gt;trieGraphAlg&lt;/span&gt;
&lt;span id=&#34;cb30-2&#34;&gt;&lt;a href=&#34;#cb30-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k)&lt;/span&gt;
&lt;span id=&#34;cb30-3&#34;&gt;&lt;a href=&#34;#cb30-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then using &lt;code&gt;cata trieGraphAlg :: Trie k v -&amp;gt; Gr (Maybe v) k&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This isn’t a particularly bad way to go about it, and you won’t have &lt;em&gt;too&lt;/em&gt; many problems. However, this might be a good learning opportunity to practice writing “monadic” catamorphisms.&lt;/p&gt;
&lt;p&gt;That’s because to create a graph using &lt;em&gt;fgl&lt;/em&gt;, you need to manage Node ID’s, which are represented as &lt;code&gt;Int&lt;/code&gt;s. To add a node, you need to generate a fresh Node ID. &lt;em&gt;fgl&lt;/em&gt; has some nice tools for managing this, but we can have some fun by taking care of it ourselves using the so-called “state monad”, &lt;code&gt;State Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;State Int&lt;/code&gt; as a way to generate “fresh” node ID’s on-demand, with the action &lt;code&gt;fresh&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb31&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb31-1&#34;&gt;&lt;a href=&#34;#cb31-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L158-L159&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-2&#34;&gt;&lt;a href=&#34;#cb31-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-3&#34;&gt;&lt;a href=&#34;#cb31-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;fresh ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb31-4&#34;&gt;&lt;a href=&#34;#cb31-4&#34;&gt;&lt;/a&gt;fresh &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; state &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; \i &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (i, i&lt;span class=&#34;op&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;fresh&lt;/code&gt; will return the current counter state to produce a new node ID, and then increment the counter so that the next invocation will return a new node ID.&lt;/p&gt;
&lt;p&gt;In this light, we can frame our big picture as writing a &lt;code&gt;Trie k v -&amp;gt; State Int (Gr (Maybe v) k)&lt;/code&gt;: turn a &lt;code&gt;Trie k v&lt;/code&gt; into a state action to generate a graph.&lt;/p&gt;
&lt;p&gt;To write this, we lay out our algebra:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb32&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb32-1&#34;&gt;&lt;a href=&#34;#cb32-1&#34;&gt;&lt;/a&gt;trieGraphAlg&lt;/span&gt;
&lt;span id=&#34;cb32-2&#34;&gt;&lt;a href=&#34;#cb32-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v (&lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k))&lt;/span&gt;
&lt;span id=&#34;cb32-3&#34;&gt;&lt;a href=&#34;#cb32-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have to write a function “how to make a state action creating a graph, given a map of state actions creating sub-graphs”.&lt;/p&gt;
&lt;p&gt;One interesting thing to note is that we have a lot to gain from using “first-class effects”: &lt;code&gt;State Int (Gr (Maybe v) k)&lt;/code&gt; is just a normal, inert Haskell value that we can manipulate and sequence however we want. State is not only explicit, but the sequencing of actions (as first-class values) is also explicit.&lt;/p&gt;
&lt;p&gt;We can write this using &lt;em&gt;fgl&lt;/em&gt; combinators:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb33&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb33-1&#34;&gt;&lt;a href=&#34;#cb33-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L166-L177&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-2&#34;&gt;&lt;a href=&#34;#cb33-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-3&#34;&gt;&lt;a href=&#34;#cb33-3&#34;&gt;&lt;/a&gt;trieGraphAlg&lt;/span&gt;
&lt;span id=&#34;cb33-4&#34;&gt;&lt;a href=&#34;#cb33-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v (&lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k))&lt;/span&gt;
&lt;span id=&#34;cb33-5&#34;&gt;&lt;a href=&#34;#cb33-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k)&lt;/span&gt;
&lt;span id=&#34;cb33-6&#34;&gt;&lt;a href=&#34;#cb33-6&#34;&gt;&lt;/a&gt;trieGraphAlg (&lt;span class=&#34;dt&#34;&gt;MkTF&lt;/span&gt; v xs) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-7&#34;&gt;&lt;a href=&#34;#cb33-7&#34;&gt;&lt;/a&gt;    n         &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; fresh&lt;/span&gt;
&lt;span id=&#34;cb33-8&#34;&gt;&lt;a href=&#34;#cb33-8&#34;&gt;&lt;/a&gt;    subgraphs &lt;span class=&#34;ot&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sequence&lt;/span&gt; xs&lt;/span&gt;
&lt;span id=&#34;cb33-9&#34;&gt;&lt;a href=&#34;#cb33-9&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;co&#34;&gt;--  subbroots :: [(k, Int)]&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-10&#34;&gt;&lt;a href=&#34;#cb33-10&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;kw&#34;&gt;let&lt;/span&gt; subroots &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; M.toList &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fmap&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;fst&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; G.nodeRange) &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; subgraphs&lt;/span&gt;
&lt;span id=&#34;cb33-11&#34;&gt;&lt;a href=&#34;#cb33-11&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;fu&#34;&gt;pure&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; G.insEdges ((\(k,i) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (n,i,k)) &lt;span class=&#34;op&#34;&gt;&amp;lt;$&amp;gt;&lt;/span&gt; subroots)   &lt;span class=&#34;co&#34;&gt;-- insert root-to-subroots&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-12&#34;&gt;&lt;a href=&#34;#cb33-12&#34;&gt;&lt;/a&gt;         &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; G.insNode (n, v)                     &lt;span class=&#34;co&#34;&gt;-- insert new root&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-13&#34;&gt;&lt;a href=&#34;#cb33-13&#34;&gt;&lt;/a&gt;         &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; M.foldr (G.ufold (&lt;span class=&#34;op&#34;&gt;G.&amp;amp;&lt;/span&gt;)) G.empty      &lt;span class=&#34;co&#34;&gt;-- merge all subgraphs&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb33-14&#34;&gt;&lt;a href=&#34;#cb33-14&#34;&gt;&lt;/a&gt;         &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; subgraphs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;&lt;p&gt;First, generate and reserve a fresh node label&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Then, sequence all of the state actions inside the map of sub-graph generators. Remember, a &lt;code&gt;TrieF k v (State Int (Gr (Maybe v) k))&lt;/code&gt; contains a &lt;code&gt;Maybe v&lt;/code&gt; and a &lt;code&gt;Map k (State Int (Gr (Maybe v) k))&lt;/code&gt;. The map contains State actions to create the sub-graphs, and we use:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb34&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb34-1&#34;&gt;&lt;a href=&#34;#cb34-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;fu&#34;&gt;sequence&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb34-2&#34;&gt;&lt;a href=&#34;#cb34-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; k (&lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k))&lt;/span&gt;
&lt;span id=&#34;cb34-3&#34;&gt;&lt;a href=&#34;#cb34-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;State&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Int&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; k (&lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to turn a map of subgraph-producing actions into an action producing a map of subgraphs.&lt;/p&gt;
&lt;p&gt;Note that this is made much simpler because of explicit state sequencing, since it gives us the opportunity to choose what “order” we want to perform our actions. Putting this after &lt;code&gt;fresh&lt;/code&gt; ensures that the nodes in the subtries all have larger ID’s than the root node. If we swap the order of the actions, we can actually invert the node ordering.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Next, it’s useful to collect all of the subroots, &lt;code&gt;subroots :: [(k, Int)]&lt;/code&gt;. These are all of the node id’s of the roots of each of the subtries, paired with the token leading to that subtrie.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Now to produce our result:&lt;/p&gt;
&lt;ol type=&#34;a&#34;&gt;
&lt;li&gt;First we merge all subgraphs (using &lt;code&gt;G.ufold (G.&amp;amp;)&lt;/code&gt; to merge together two graphs)&lt;/li&gt;
&lt;li&gt;Then, we insert the new root, with our fresh node ID and the new &lt;code&gt;Maybe v&lt;/code&gt; label.&lt;/li&gt;
&lt;li&gt;Then, we insert all of the edges connecting our new root to the root of all our subgraphs (in &lt;code&gt;subroots&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can then write our graph generating function using this algebra, and then running the resulting &lt;code&gt;State Int (Gr (Maybe v) k)&lt;/code&gt; action:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb35&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb35-1&#34;&gt;&lt;a href=&#34;#cb35-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L161-L164&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-2&#34;&gt;&lt;a href=&#34;#cb35-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb35-3&#34;&gt;&lt;a href=&#34;#cb35-3&#34;&gt;&lt;/a&gt;trieGraph&lt;/span&gt;
&lt;span id=&#34;cb35-4&#34;&gt;&lt;a href=&#34;#cb35-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Trie&lt;/span&gt; k v&lt;/span&gt;
&lt;span id=&#34;cb35-5&#34;&gt;&lt;a href=&#34;#cb35-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k&lt;/span&gt;
&lt;span id=&#34;cb35-6&#34;&gt;&lt;a href=&#34;#cb35-6&#34;&gt;&lt;/a&gt;trieGraph &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;flip&lt;/span&gt; evalState &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; cata trieGraphAlg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, we can write our &lt;code&gt;mapToGraph&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb36&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb36-1&#34;&gt;&lt;a href=&#34;#cb36-1&#34;&gt;&lt;/a&gt;mapToGraph&lt;/span&gt;
&lt;span id=&#34;cb36-2&#34;&gt;&lt;a href=&#34;#cb36-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb36-3&#34;&gt;&lt;a href=&#34;#cb36-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; [k] v&lt;/span&gt;
&lt;span id=&#34;cb36-4&#34;&gt;&lt;a href=&#34;#cb36-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k&lt;/span&gt;
&lt;span id=&#34;cb36-5&#34;&gt;&lt;a href=&#34;#cb36-5&#34;&gt;&lt;/a&gt;mapToGraph &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;flip&lt;/span&gt; evalState &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb36-6&#34;&gt;&lt;a href=&#34;#cb36-6&#34;&gt;&lt;/a&gt;           &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; cata trieGraphAlg&lt;/span&gt;
&lt;span id=&#34;cb36-7&#34;&gt;&lt;a href=&#34;#cb36-7&#34;&gt;&lt;/a&gt;           &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; ana fromGraphCoalg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;hylomorphisms&#34;&gt;Hylomorphisms&lt;/h3&gt;
&lt;p&gt;Actually, writing things out as &lt;code&gt;mapToGraph&lt;/code&gt; gives us some interesting insight: our function takes a &lt;code&gt;Map [k] v&lt;/code&gt;, and returns a &lt;code&gt;Gr (Maybe v) k&lt;/code&gt;. Notice that &lt;code&gt;Trie k v&lt;/code&gt; isn’t anywhere in the type signature. This means that, to the external user, &lt;code&gt;Trie&lt;/code&gt;’s role is completely internal.&lt;/p&gt;
&lt;p&gt;In other words, &lt;code&gt;Trie&lt;/code&gt; &lt;em&gt;itself&lt;/em&gt; doesn’t seem to matter at all. We really want a &lt;code&gt;Map [k] v -&amp;gt; Gr (Maybe v) k&lt;/code&gt;, and we’re just using &lt;code&gt;Trie&lt;/code&gt; as an &lt;em&gt;intermediate data structure&lt;/em&gt;. We are exploiting its internal structure to write our full function, and we don’t care about it outside of that. We build it up with &lt;code&gt;ana&lt;/code&gt; and then immediately tear it down with &lt;code&gt;cata&lt;/code&gt;, and it is completely invisible to the outside world.&lt;/p&gt;
&lt;p&gt;One neat thing about &lt;em&gt;recursion-schemes&lt;/em&gt; is that it lets us capture this “the actual fixed-point is only intermediate and is not directly consequential to the outside world” pattern. First, we walk ourselves through the following reasoning steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We don’t care about &lt;code&gt;Trie&lt;/code&gt; itself as a result or input. We only care about it because we exploit its internal structure.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TrieF&lt;/code&gt; &lt;em&gt;already&lt;/em&gt; expresses the internal structure of &lt;code&gt;Trie&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Therefore, if we only want to take advantage of the structure, we really only ever need &lt;code&gt;TrieF&lt;/code&gt;. We can completely bypass &lt;code&gt;Trie&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This should make sense in our case, because the only reason we use &lt;code&gt;Trie&lt;/code&gt; is for its internal structure. But &lt;code&gt;TrieF&lt;/code&gt; &lt;em&gt;already&lt;/em&gt; captures the internal structure — thus, we really only need to ever worry about &lt;code&gt;TrieF&lt;/code&gt;. We don’t actually care about the recursive data type — we never did!&lt;/p&gt;
&lt;p&gt;In this spirit, &lt;em&gt;recursion-schemes&lt;/em&gt; offers the &lt;em&gt;hylomorphism&lt;/em&gt; recursion scheme:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb37&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb37-1&#34;&gt;&lt;a href=&#34;#cb37-1&#34;&gt;&lt;/a&gt;hylo&lt;/span&gt;
&lt;span id=&#34;cb37-2&#34;&gt;&lt;a href=&#34;#cb37-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)   &lt;span class=&#34;co&#34;&gt;-- ^ an algebra&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb37-3&#34;&gt;&lt;a href=&#34;#cb37-3&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a)   &lt;span class=&#34;co&#34;&gt;-- ^ a coalgebra&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb37-4&#34;&gt;&lt;a href=&#34;#cb37-4&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb37-5&#34;&gt;&lt;a href=&#34;#cb37-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we see the coalgebra &lt;code&gt;a -&amp;gt; TrieF k v a&lt;/code&gt; as a “building” function, and the algebra &lt;code&gt;TrieF k v b -&amp;gt; b&lt;/code&gt; as a “consuming” function, then &lt;code&gt;hylo&lt;/code&gt; will &lt;em&gt;build, then immediately consume&lt;/em&gt;. It’ll build with the coalgebra on &lt;code&gt;TrieF&lt;/code&gt;, then immediately consume with the algebra on &lt;code&gt;TrieF&lt;/code&gt;. No &lt;code&gt;Trie&lt;/code&gt; is ever generated, because it’s never necessary: we’re literally just building and immediately consuming &lt;code&gt;TrieF&lt;/code&gt; values.&lt;/p&gt;
&lt;p&gt;We could even implement &lt;code&gt;hylo&lt;/code&gt; ourselves, to illustrate the “build and immediately consume” property:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb38&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb38-1&#34;&gt;&lt;a href=&#34;#cb38-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L185-L192&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-2&#34;&gt;&lt;a href=&#34;#cb38-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-3&#34;&gt;&lt;a href=&#34;#cb38-3&#34;&gt;&lt;/a&gt;hylo&amp;#39;&lt;/span&gt;
&lt;span id=&#34;cb38-4&#34;&gt;&lt;a href=&#34;#cb38-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v b &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b)   &lt;span class=&#34;co&#34;&gt;-- ^ an algebra&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-5&#34;&gt;&lt;a href=&#34;#cb38-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; (a &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;TrieF&lt;/span&gt; k v a)   &lt;span class=&#34;co&#34;&gt;-- ^ a coalgebra&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb38-6&#34;&gt;&lt;a href=&#34;#cb38-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id=&#34;cb38-7&#34;&gt;&lt;a href=&#34;#cb38-7&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id=&#34;cb38-8&#34;&gt;&lt;a href=&#34;#cb38-8&#34;&gt;&lt;/a&gt;hylo&amp;#39; consume build &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; consume&lt;/span&gt;
&lt;span id=&#34;cb38-9&#34;&gt;&lt;a href=&#34;#cb38-9&#34;&gt;&lt;/a&gt;                    &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fmap&lt;/span&gt; (hylo&amp;#39; consume build)&lt;/span&gt;
&lt;span id=&#34;cb38-10&#34;&gt;&lt;a href=&#34;#cb38-10&#34;&gt;&lt;/a&gt;                    &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; build&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the implementation of &lt;code&gt;hylo&lt;/code&gt; given above works for any &lt;code&gt;Functor&lt;/code&gt; instance: we build and consume along &lt;em&gt;any&lt;/em&gt; &lt;code&gt;Functor&lt;/code&gt;, taking advantage of the specific functor’s structure. The fixed-point never comes into the picture.&lt;/p&gt;
&lt;p&gt;To me, being able to implement a function in terms of &lt;code&gt;hylo&lt;/code&gt; (or any other refolder, like its cousin &lt;code&gt;chrono&lt;/code&gt;, the chronomorphism) represents the ultimate “victory” in using &lt;em&gt;recursion-schemes&lt;/em&gt; to refactor out your functions. That’s because it helps us realize that we never really cared about having a recursive data type in the first place. &lt;code&gt;Trie&lt;/code&gt; was never the actual thing we wanted: we really just wanted its layer-by-layer structure. This whole time, we just cared about the structure of &lt;code&gt;TrieF&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; &lt;code&gt;Trie&lt;/code&gt;. Being able to use &lt;code&gt;hylo&lt;/code&gt; lets us see that the original recursive data type was nothing more than a distraction. Through it, we see the light.&lt;/p&gt;
&lt;p&gt;I call the experiencing of making this revelation “achieving hylomorphism”.&lt;/p&gt;
&lt;p&gt;Our final map-to-graph function can therefore be expressed as:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb39&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb39-1&#34;&gt;&lt;a href=&#34;#cb39-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L179-L183&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-2&#34;&gt;&lt;a href=&#34;#cb39-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb39-3&#34;&gt;&lt;a href=&#34;#cb39-3&#34;&gt;&lt;/a&gt;mapToGraph&lt;/span&gt;
&lt;span id=&#34;cb39-4&#34;&gt;&lt;a href=&#34;#cb39-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Ord&lt;/span&gt; k&lt;/span&gt;
&lt;span id=&#34;cb39-5&#34;&gt;&lt;a href=&#34;#cb39-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; [k] v&lt;/span&gt;
&lt;span id=&#34;cb39-6&#34;&gt;&lt;a href=&#34;#cb39-6&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k&lt;/span&gt;
&lt;span id=&#34;cb39-7&#34;&gt;&lt;a href=&#34;#cb39-7&#34;&gt;&lt;/a&gt;mapToGraph &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;flip&lt;/span&gt; evalState &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; hylo trieGraphAlg fromMapCoalg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;pack-your-things&#34;&gt;Pack your things&lt;/h3&gt;
&lt;p&gt;To wrap things up, I made a text file storing all of the prequel quotes in the original reference trie along with images stored on my drive: (you can find a them &lt;a href=&#34;https://github.com/mstksg/inCode/tree/master/code-samples/trie/img&#34;&gt;online here&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;I DON&amp;#39;T THINK SO,img/idts.jpg
I DON&amp;#39;T THINK THE SYSTEM WORKS,img/idttsw.jpg
I HAVE BEEN LOOKING FORWARD TO THIS,img/iblftt.jpg
I HAVE A BAD FEELING ABOUT THIS,img/ihabfat.jpg
IT&amp;#39;S TREASON THEN,img/itt.jpg
IT&amp;#39;S OUTRAGEOUS IT&amp;#39;S UNFAIR,img/tioiu.jpg&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can write a quick parser and aggregator into a &lt;code&gt;Map [Char] HTML.Label&lt;/code&gt;, where &lt;code&gt;HTML.Label&lt;/code&gt; is from the &lt;em&gt;graphviz&lt;/em&gt; library, a renderable object to display on the final image.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb41&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb41-1&#34;&gt;&lt;a href=&#34;#cb41-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L194-L203&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-2&#34;&gt;&lt;a href=&#34;#cb41-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-3&#34;&gt;&lt;a href=&#34;#cb41-3&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;memeMap ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Map&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HTML.Label&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-4&#34;&gt;&lt;a href=&#34;#cb41-4&#34;&gt;&lt;/a&gt;memeMap &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; M.fromList &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;uncurry&lt;/span&gt; processLine &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;span&lt;/span&gt; (&lt;span class=&#34;op&#34;&gt;/=&lt;/span&gt; &lt;span class=&#34;ch&#34;&gt;&amp;#39;,&amp;#39;&lt;/span&gt;)) &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;lines&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-5&#34;&gt;&lt;a href=&#34;#cb41-5&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-6&#34;&gt;&lt;a href=&#34;#cb41-6&#34;&gt;&lt;/a&gt;    processLine qt (&lt;span class=&#34;fu&#34;&gt;drop&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;img) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (&lt;/span&gt;
&lt;span id=&#34;cb41-7&#34;&gt;&lt;a href=&#34;#cb41-7&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;fu&#34;&gt;filter&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;isSpace&lt;/span&gt;) qt&lt;/span&gt;
&lt;span id=&#34;cb41-8&#34;&gt;&lt;a href=&#34;#cb41-8&#34;&gt;&lt;/a&gt;        , &lt;span class=&#34;dt&#34;&gt;HTML.Table&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;HTML.HTable&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; [] [r1,r2])&lt;/span&gt;
&lt;span id=&#34;cb41-9&#34;&gt;&lt;a href=&#34;#cb41-9&#34;&gt;&lt;/a&gt;        )&lt;/span&gt;
&lt;span id=&#34;cb41-10&#34;&gt;&lt;a href=&#34;#cb41-10&#34;&gt;&lt;/a&gt;      &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb41-11&#34;&gt;&lt;a href=&#34;#cb41-11&#34;&gt;&lt;/a&gt;        r1 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HTML.Cells&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;HTML.LabelCell&lt;/span&gt; [] (&lt;span class=&#34;dt&#34;&gt;HTML.Text&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;HTML.Str&lt;/span&gt; (T.pack qt)])]&lt;/span&gt;
&lt;span id=&#34;cb41-12&#34;&gt;&lt;a href=&#34;#cb41-12&#34;&gt;&lt;/a&gt;        r2 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HTML.Cells&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;HTML.ImgCell&lt;/span&gt;   [] (&lt;span class=&#34;dt&#34;&gt;HTML.Img&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;HTML.Src&lt;/span&gt; img])]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can also write a small utility function to clean up our final graph; it deletes nodes that only have one child and compacts them into the node above. It’s just to “compress” together strings of nodes that don’t have any forks.&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb42&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb42-1&#34;&gt;&lt;a href=&#34;#cb42-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L226-L236&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-2&#34;&gt;&lt;a href=&#34;#cb42-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-3&#34;&gt;&lt;a href=&#34;#cb42-3&#34;&gt;&lt;/a&gt;compactify&lt;/span&gt;
&lt;span id=&#34;cb42-4&#34;&gt;&lt;a href=&#34;#cb42-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) k&lt;/span&gt;
&lt;span id=&#34;cb42-5&#34;&gt;&lt;a href=&#34;#cb42-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; v) [k]&lt;/span&gt;
&lt;span id=&#34;cb42-6&#34;&gt;&lt;a href=&#34;#cb42-6&#34;&gt;&lt;/a&gt;compactify g0 &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; foldl&amp;#39; go (G.emap (&lt;span class=&#34;op&#34;&gt;:&lt;/span&gt;[]) g0) (G.labNodes g0)&lt;/span&gt;
&lt;span id=&#34;cb42-7&#34;&gt;&lt;a href=&#34;#cb42-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-8&#34;&gt;&lt;a href=&#34;#cb42-8&#34;&gt;&lt;/a&gt;    go g (i, v) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; (G.inn g i, G.out g i) &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb42-9&#34;&gt;&lt;a href=&#34;#cb42-9&#34;&gt;&lt;/a&gt;      ([(j, _, lj)], [(_, k, lk)])&lt;/span&gt;
&lt;span id=&#34;cb42-10&#34;&gt;&lt;a href=&#34;#cb42-10&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;op&#34;&gt;|&lt;/span&gt; isNothing v &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; G.insEdge (j, k, lj &lt;span class=&#34;op&#34;&gt;++&lt;/span&gt; lk)&lt;/span&gt;
&lt;span id=&#34;cb42-11&#34;&gt;&lt;a href=&#34;#cb42-11&#34;&gt;&lt;/a&gt;                       &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; G.delNode i &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; G.delEdges [(j,i),(i,k)]&lt;/span&gt;
&lt;span id=&#34;cb42-12&#34;&gt;&lt;a href=&#34;#cb42-12&#34;&gt;&lt;/a&gt;                       &lt;span class=&#34;op&#34;&gt;$&lt;/span&gt; g&lt;/span&gt;
&lt;span id=&#34;cb42-13&#34;&gt;&lt;a href=&#34;#cb42-13&#34;&gt;&lt;/a&gt;      _               &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; g&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could have directly outputted a compacted graph from &lt;code&gt;trieGraphAlg&lt;/code&gt;, but for the sake of this post it’s a bit cleaner to separate out these concerns.&lt;/p&gt;
&lt;p&gt;We’ll write a function to turn a &lt;code&gt;Gr (Maybe HTML.Label) [Char]&lt;/code&gt; into a dot file, using &lt;em&gt;graphviz&lt;/em&gt; to do most of the work:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb43&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb43-1&#34;&gt;&lt;a href=&#34;#cb43-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L205-L215&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-2&#34;&gt;&lt;a href=&#34;#cb43-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-3&#34;&gt;&lt;a href=&#34;#cb43-3&#34;&gt;&lt;/a&gt;graphDot&lt;/span&gt;
&lt;span id=&#34;cb43-4&#34;&gt;&lt;a href=&#34;#cb43-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Gr&lt;/span&gt; (&lt;span class=&#34;dt&#34;&gt;Maybe&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;HTML.Label&lt;/span&gt;) &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-5&#34;&gt;&lt;a href=&#34;#cb43-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;T.Text&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-6&#34;&gt;&lt;a href=&#34;#cb43-6&#34;&gt;&lt;/a&gt;graphDot &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; GV.printIt &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; GV.graphToDot params&lt;/span&gt;
&lt;span id=&#34;cb43-7&#34;&gt;&lt;a href=&#34;#cb43-7&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-8&#34;&gt;&lt;a href=&#34;#cb43-8&#34;&gt;&lt;/a&gt;    params &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; GV.nonClusteredParams&lt;/span&gt;
&lt;span id=&#34;cb43-9&#34;&gt;&lt;a href=&#34;#cb43-9&#34;&gt;&lt;/a&gt;      { fmtNode &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \(_,  l) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;kw&#34;&gt;case&lt;/span&gt; l &lt;span class=&#34;kw&#34;&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb43-10&#34;&gt;&lt;a href=&#34;#cb43-10&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;dt&#34;&gt;Nothing&lt;/span&gt; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [GV.shape &lt;span class=&#34;dt&#34;&gt;GV.PointShape&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb43-11&#34;&gt;&lt;a href=&#34;#cb43-11&#34;&gt;&lt;/a&gt;          &lt;span class=&#34;dt&#34;&gt;Just&lt;/span&gt; l&amp;#39; &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [GV.toLabel l&amp;#39;, GV.shape &lt;span class=&#34;dt&#34;&gt;GV.PlainText&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb43-12&#34;&gt;&lt;a href=&#34;#cb43-12&#34;&gt;&lt;/a&gt;      , fmtEdge &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; \(_,_,l) &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [GV.toLabel (&lt;span class=&#34;fu&#34;&gt;concat&lt;/span&gt; [&lt;span class=&#34;st&#34;&gt;&amp;quot;[&amp;quot;&lt;/span&gt;, l, &lt;span class=&#34;st&#34;&gt;&amp;quot;]&amp;quot;&lt;/span&gt;])]&lt;/span&gt;
&lt;span id=&#34;cb43-13&#34;&gt;&lt;a href=&#34;#cb43-13&#34;&gt;&lt;/a&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, we can write the entire pipeline:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb44&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb44-1&#34;&gt;&lt;a href=&#34;#cb44-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- source: https://github.com/mstksg/inCode/tree/master/code-samples/trie/trie.hs#L217-L224&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb44-2&#34;&gt;&lt;a href=&#34;#cb44-2&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb44-3&#34;&gt;&lt;a href=&#34;#cb44-3&#34;&gt;&lt;/a&gt;memeDot&lt;/span&gt;
&lt;span id=&#34;cb44-4&#34;&gt;&lt;a href=&#34;#cb44-4&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb44-5&#34;&gt;&lt;a href=&#34;#cb44-5&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;T.Text&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb44-6&#34;&gt;&lt;a href=&#34;#cb44-6&#34;&gt;&lt;/a&gt;memeDot &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; graphDot&lt;/span&gt;
&lt;span id=&#34;cb44-7&#34;&gt;&lt;a href=&#34;#cb44-7&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; compactify&lt;/span&gt;
&lt;span id=&#34;cb44-8&#34;&gt;&lt;a href=&#34;#cb44-8&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;flip&lt;/span&gt; evalState &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb44-9&#34;&gt;&lt;a href=&#34;#cb44-9&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; hylo trieGraphAlg fromMapCoalg&lt;/span&gt;
&lt;span id=&#34;cb44-10&#34;&gt;&lt;a href=&#34;#cb44-10&#34;&gt;&lt;/a&gt;        &lt;span class=&#34;op&#34;&gt;.&lt;/span&gt; memeMap&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shorter than I expected!&lt;/p&gt;
&lt;p&gt;This gives us our final result: (&lt;a href=&#34;/img/entries/trie/meme-trie.png&#34;&gt;full size here&lt;/a&gt;)&lt;/p&gt;
&lt;figure&gt;
&lt;img src=&#34;/img/entries/trie/meme-trie.png&#34; title=&#34;Our final result&#34; alt=&#34;&#34; /&gt;&lt;figcaption&gt;Our rendered dotfile, using graphviz&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;There are definitely some things we can tweak with respect to formatting and position and font sizes and label layouts, but I think this is fairly faithful to the original structure!&lt;/p&gt;
&lt;h2 id=&#34;another-happy-landing&#34;&gt;Another happy landing&lt;/h2&gt;
&lt;p&gt;There’s a lot more we can do with tries, and fleshing out a full interface allows us to explore a lot of other useful recursion schemes and combinators.&lt;/p&gt;
&lt;p&gt;Now that we’ve familiarized ourselves with a simple tangible example, we’re now free to dive deep. Achieving hylomorphism helps us see past the recursive data type and directly into the underlying structure of what’s going on. And out of it, we got a pretty helpful meme trie we can show off to our friends.&lt;/p&gt;
&lt;p&gt;In the next parts of the series, we’ll find out what other viewpoints &lt;em&gt;recursion-schemes&lt;/em&gt; has to offer for us!&lt;/p&gt;
&lt;p&gt;In the mean time, why not check out these other nice recursion-schemes tutorials?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bartoszmilewski.com/2018/12/20/open-season-on-hylomorphisms/&#34;&gt;Bartosz Milewski&lt;/a&gt; also talks about using tries with &lt;em&gt;recursion-schemes&lt;/em&gt;, and achieves hylomorphism as well.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.sumtypeofway.com/an-introduction-to-recursion-schemes/&#34;&gt;This classic tutorial&lt;/a&gt; was how I originally learned recursion schemes.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/passy/awesome-recursion-schemes&#34;&gt;This github repo&lt;/a&gt; accumulates a lot of amazing articles, tutorials, and other resources.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;special-thanks&#34;&gt;Special Thanks&lt;/h2&gt;
&lt;p&gt;I am very humbled to be supported by an amazing community, who make it possible for me to devote time to researching and writing these posts. Very special thanks to my supporters at the “Amazing” level on &lt;a href=&#34;https://www.patreon.com/justinle/overview&#34;&gt;patreon&lt;/a&gt;, Sam Stites and Josh Vera! :)&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34; role=&#34;doc-endnote&#34;&gt;&lt;p&gt;Funny story, a &lt;a href=&#34;http://www.drdobbs.com/architecture-and-design/patricia-tries/208800854&#34;&gt;patricia tree&lt;/a&gt; is actually itself a trie variation. This means that we are essentially converting a trie representing a graph into a graph representation implemented using a trie.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34; role=&#34;doc-backlink&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description><author>Justin Le</author><category>Haskell</category><category>Tutorials</category><guid isPermaLink="true">https://blog.jle.im/entry/tries-with-recursion-schemes.html</guid><pubDate>Fri, 25 Jan 2019 21:34:18 UTC</pubDate><creator>Justin Le</creator><subject>Haskell, Tutorials</subject><date>2019-01-25</date></item><item><title>Shifting the Stars: Advent of Code with Galilean Optimization</title><link>https://blog.jle.im/entry/shifting-the-stars.html</link><description>&lt;p&gt;(TL;DR: scroll down to the very bottom for a summary and the closed form solution)&lt;/p&gt;
&lt;p&gt;Another short Advent of Code post! &lt;a href=&#34;https://adventofcode.com/2018&#34;&gt;Advent of Code 2018&lt;/a&gt; is in full swing; we’re 40% of the way through. Every once in a while, if I find a fun way to solve a problem, I’ll make a short post about it. You can check out my other ones &lt;a href=&#34;https://blog.jle.im/entries/series/+advent-of-code.html&#34;&gt;here on the series page&lt;/a&gt;, and you can also find my &lt;a href=&#34;https://github.com/mstksg/advent-of-code-2018/blob/master/reflections.md&#34;&gt;daily reflections&lt;/a&gt; here, as well. And, again, if you’re following along in Haskell, why not hop on &lt;a href=&#34;https://twitter.com/glguy&#34;&gt;glguy’s&lt;/a&gt; semi-official &lt;a href=&#34;https://adventofcode.com/2018/leaderboard/private&#34;&gt;Haskell Leaderboard&lt;/a&gt; (join code &lt;code&gt;43100-84040706&lt;/code&gt;)! There are also Haskellers on freenode ##adventofcode, and also #adventofcode on the Functional Programming slack. You might also find my &lt;a href=&#34;https://hackage.haskell.org/package/advent-of-code-api&#34;&gt;advent of code api&lt;/a&gt; haskell bindings helpful too!&lt;/p&gt;
&lt;p&gt;Today, we’re going to be using linear algebra, calculus, and galilian transformations to solve the &lt;em&gt;Day 10&lt;/em&gt; challenge. (That’s right, this isn’t just a Haskell blog, I do have &lt;a href=&#34;https://blog.jle.im/entries/category/@math.html&#34;&gt;math&lt;/a&gt; posts on occasion too :) )&lt;/p&gt;
&lt;h2 id=&#34;part-1&#34;&gt;Part 1&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s no use; your navigation system simply isn’t capable of providing walking directions in the arctic circle, and certainly not in 1018.&lt;/p&gt;
&lt;p&gt;The Elves suggest an alternative. In times like these, North Pole rescue operations will arrange points of light in the sky to guide missing Elves back to base. Unfortunately, the message is easy to miss: the points move slowly enough that it takes hours to align them, but have so much momentum that they only stay aligned for a second. If you blink at the wrong time, it might be hours before another message appears.&lt;/p&gt;
&lt;p&gt;You can see these points of light floating in the distance, and record their position in the sky and their velocity, the relative change in position per second (your puzzle input). The coordinates are all given from your perspective; given enough time, those positions and velocities will move the points into a cohesive message!&lt;/p&gt;
&lt;p&gt;Rather than wait, you decide to fast-forward the process and calculate what the points will eventually spell.&lt;/p&gt;
&lt;p&gt;For example, suppose you note the following points:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;position=&amp;lt; 9,  1&amp;gt; velocity=&amp;lt; 0,  2&amp;gt;
position=&amp;lt; 7,  0&amp;gt; velocity=&amp;lt;-1,  0&amp;gt;
position=&amp;lt; 3, -2&amp;gt; velocity=&amp;lt;-1,  1&amp;gt;
position=&amp;lt; 6, 10&amp;gt; velocity=&amp;lt;-2, -1&amp;gt;
position=&amp;lt; 2, -4&amp;gt; velocity=&amp;lt; 2,  2&amp;gt;
position=&amp;lt;-6, 10&amp;gt; velocity=&amp;lt; 2, -2&amp;gt;
position=&amp;lt; 1,  8&amp;gt; velocity=&amp;lt; 1, -1&amp;gt;
position=&amp;lt; 1,  7&amp;gt; velocity=&amp;lt; 1,  0&amp;gt;
position=&amp;lt;-3, 11&amp;gt; velocity=&amp;lt; 1, -2&amp;gt;
position=&amp;lt; 7,  6&amp;gt; velocity=&amp;lt;-1, -1&amp;gt;
position=&amp;lt;-2,  3&amp;gt; velocity=&amp;lt; 1,  0&amp;gt;
position=&amp;lt;-4,  3&amp;gt; velocity=&amp;lt; 2,  0&amp;gt;
position=&amp;lt;10, -3&amp;gt; velocity=&amp;lt;-1,  1&amp;gt;
position=&amp;lt; 5, 11&amp;gt; velocity=&amp;lt; 1, -2&amp;gt;
position=&amp;lt; 4,  7&amp;gt; velocity=&amp;lt; 0, -1&amp;gt;
position=&amp;lt; 8, -2&amp;gt; velocity=&amp;lt; 0,  1&amp;gt;
position=&amp;lt;15,  0&amp;gt; velocity=&amp;lt;-2,  0&amp;gt;
position=&amp;lt; 1,  6&amp;gt; velocity=&amp;lt; 1,  0&amp;gt;
position=&amp;lt; 8,  9&amp;gt; velocity=&amp;lt; 0, -1&amp;gt;
position=&amp;lt; 3,  3&amp;gt; velocity=&amp;lt;-1,  1&amp;gt;
position=&amp;lt; 0,  5&amp;gt; velocity=&amp;lt; 0, -1&amp;gt;
position=&amp;lt;-2,  2&amp;gt; velocity=&amp;lt; 2,  0&amp;gt;
position=&amp;lt; 5, -2&amp;gt; velocity=&amp;lt; 1,  2&amp;gt;
position=&amp;lt; 1,  4&amp;gt; velocity=&amp;lt; 2,  1&amp;gt;
position=&amp;lt;-2,  7&amp;gt; velocity=&amp;lt; 2, -2&amp;gt;
position=&amp;lt; 3,  6&amp;gt; velocity=&amp;lt;-1, -1&amp;gt;
position=&amp;lt; 5,  0&amp;gt; velocity=&amp;lt; 1,  0&amp;gt;
position=&amp;lt;-6,  0&amp;gt; velocity=&amp;lt; 2,  0&amp;gt;
position=&amp;lt; 5,  9&amp;gt; velocity=&amp;lt; 1, -2&amp;gt;
position=&amp;lt;14,  7&amp;gt; velocity=&amp;lt;-2,  0&amp;gt;
position=&amp;lt;-3,  6&amp;gt; velocity=&amp;lt; 2, -1&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each line represents one point. Positions are given as &lt;code&gt;&amp;lt;X, Y&amp;gt;&lt;/code&gt; pairs: X represents how far left (negative) or right (positive) the point appears, while Y represents how far up (negative) or down (positive) the point appears.&lt;/p&gt;
&lt;p&gt;At &lt;code&gt;0&lt;/code&gt; seconds, each point has the position given. Each second, each point’s velocity is added to its position. So, a point with velocity &lt;code&gt;&amp;lt;1, -2&amp;gt;&lt;/code&gt; is moving to the right, but is moving upward twice as quickly. If this point’s initial position were &lt;code&gt;&amp;lt;3, 9&amp;gt;&lt;/code&gt;, after &lt;code&gt;3&lt;/code&gt; seconds, its position would become &lt;code&gt;&amp;lt;6, 3&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Over time, the points listed above would move like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Initially:
........#.............
................#.....
.........#.#..#.......
......................
#..........#.#.......#
...............#......
....#.................
..#.#....#............
.......#..............
......#...............
...#...#.#...#........
....#..#..#.........#.
.......#..............
...........#..#.......
#...........#.........
...#.......#..........

After 1 second:
......................
......................
..........#....#......
........#.....#.......
..#.........#......#..
......................
......#...............
....##.........#......
......#.#.............
.....##.##..#.........
........#.#...........
........#...#.....#...
..#...........#.......
....#.....#.#.........
......................
......................

After 2 seconds:
......................
......................
......................
..............#.......
....#..#...####..#....
......................
........#....#........
......#.#.............
.......#...#..........
.......#..#..#.#......
....#....#.#..........
.....#...#...##.#.....
........#.............
......................
......................
......................

After 3 seconds:
......................
......................
......................
......................
......#...#..###......
......#...#...#.......
......#...#...#.......
......#####...#.......
......#...#...#.......
......#...#...#.......
......#...#...#.......
......#...#..###......
......................
......................
......................
......................

After 4 seconds:
......................
......................
......................
............#.........
........##...#.#......
......#.....#..#......
.....#..##.##.#.......
.......##.#....#......
...........#....#.....
..............#.......
....#......#...#......
.....#.....##.........
...............#......
...............#......
......................
......................&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After 3 seconds, the message appeared briefly: &lt;code&gt;HI&lt;/code&gt;. Of course, your message will be much longer and will take many more seconds to appear.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What message will eventually appear in the sky?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The problem tells us to talk about a system of N particles, each moving at constant velocity. From this, we can see that the position of particle &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?i&#34; alt=&#34;i&#34; title=&#34;i&#34; /&gt; at time &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t&#34; alt=&#34;t&#34; title=&#34;t&#34; /&gt; is &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Cmathbf%7Br%7D_i%20%2B%20%5Cmathbf%7Bv%7D_i%20t&#34; alt=&#34;\mathbf{r}_i + \mathbf{v}_i t&#34; title=&#34;\mathbf{r}_i + \mathbf{v}_i t&#34; /&gt;, where &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Cmathbf%7Br%7D_i&#34; alt=&#34;\mathbf{r}_i&#34; title=&#34;\mathbf{r}_i&#34; /&gt; is the &lt;em&gt;initial position&lt;/em&gt; vector, and &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Cmathbf%7Bv%7D_i&#34; alt=&#34;\mathbf{v}_i&#34; title=&#34;\mathbf{v}_i&#34; /&gt; is the &lt;em&gt;velocity&lt;/em&gt; vector.&lt;/p&gt;
&lt;p&gt;More generally, we can express this in terms of matrices. If we talk talk about &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?R&#34; alt=&#34;R&#34; title=&#34;R&#34; /&gt; as the &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?N%20%5Ctimes%202&#34; alt=&#34;N \times 2&#34; title=&#34;N \times 2&#34; /&gt; matrix of initial positions, and &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?V&#34; alt=&#34;V&#34; title=&#34;V&#34; /&gt; as the &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?N%20%5Ctimes%202&#34; alt=&#34;N \times 2&#34; title=&#34;N \times 2&#34; /&gt; matrix of initial velocities:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0AR%20%3D%0A%5Cbegin%7Bbmatrix%7D%0Ax_1%20%26%20y_1%20%5C%5C%0Ax_2%20%26%20y_2%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%5C%5C%0Ax_N%20%26%20y_N%0A%5Cend%7Bbmatrix%7D%0A&#34; alt=&#34;
R =
\begin{bmatrix}
x_1 &amp;amp; y_1 \\
x_2 &amp;amp; y_2 \\
\vdots &amp;amp; \vdots \\
x_N &amp;amp; y_N
\end{bmatrix}
&#34; title=&#34;
R =
\begin{bmatrix}
x_1 &amp;amp; y_1 \\
x_2 &amp;amp; y_2 \\
\vdots &amp;amp; \vdots \\
x_N &amp;amp; y_N
\end{bmatrix}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0AV%20%3D%0A%5Cbegin%7Bbmatrix%7D%0Av_%7Bx1%7D%20%26%20v_%7By1%7D%20%5C%5C%0Av_%7Bx2%7D%20%26%20v_%7By2%7D%20%5C%5C%0A%5Cvdots%20%26%20%5Cvdots%20%5C%5C%0Av_%7BxN%7D%20%26%20v_%7ByN%7D%0A%5Cend%7Bbmatrix%7D%0A&#34; alt=&#34;
V =
\begin{bmatrix}
v_{x1} &amp;amp; v_{y1} \\
v_{x2} &amp;amp; v_{y2} \\
\vdots &amp;amp; \vdots \\
v_{xN} &amp;amp; v_{yN}
\end{bmatrix}
&#34; title=&#34;
V =
\begin{bmatrix}
v_{x1} &amp;amp; v_{y1} \\
v_{x2} &amp;amp; v_{y2} \\
\vdots &amp;amp; \vdots \\
v_{xN} &amp;amp; v_{yN}
\end{bmatrix}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Then we can say that the state of the total system at time &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t&#34; alt=&#34;t&#34; title=&#34;t&#34; /&gt; is given by &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?R%20%2B%20V%20t&#34; alt=&#34;R + V t&#34; title=&#34;R + V t&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now, how can we find the time when all of the letters are aligned?&lt;/p&gt;
&lt;p&gt;For this, we can make a &lt;em&gt;somewhat justified guess&lt;/em&gt;: looking at the input data, we see that things start out as “scattered”, and end up in a clean clustered arrangement. We know that the ending arrangement must be clustered fairly close together because we only have a few hundred points in the input data set, whereas the start times are all in the thousands or higher. And, once things get clustered, they will also get un-clustered right away, because of the randomness of the directions of motion.&lt;/p&gt;
&lt;p&gt;This gives us a clue: if we can find the &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t&#34; alt=&#34;t&#34; title=&#34;t&#34; /&gt; that will give us the &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?R%20%2B%20V%20t&#34; alt=&#34;R + V t&#34; title=&#34;R + V t&#34; /&gt; with the &lt;em&gt;least variance&lt;/em&gt;, we are good to go! All of a sudden, this is now an &lt;a href=&#34;https://en.wikipedia.org/wiki/Mathematical_optimization&#34;&gt;optimization&lt;/a&gt; problem. Find the &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t&#34; alt=&#34;t&#34; title=&#34;t&#34; /&gt; that minimizes the variance of x plus the variance of y. We can find this by finding the formula for the sum of variances, taking the first derivative, and setting it to zero.&lt;/p&gt;
&lt;p&gt;The typical formula for finding the sum of variances of a matrix &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?M&#34; alt=&#34;M&#34; title=&#34;M&#34; /&gt; is to take the &lt;a href=&#34;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&#34;&gt;trace&lt;/a&gt; of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Covariance_matrix&#34;&gt;covariance matrix&lt;/a&gt;, &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Cmathrm%7BTr%7D%20%5Cleft%5B%20%5Cleft%28M%20-%20%5Cmu_M%20%5Cright%29%5ET%20%5Cleft%28M%20-%20%5Cmu_M%20%5Cright%29%20%5Cright%5D&#34; alt=&#34;\mathrm{Tr} \left[ \left(M - \mu_M \right)^T \left(M - \mu_M \right) \right]&#34; title=&#34;\mathrm{Tr} \left[ \left(M - \mu_M \right)^T \left(M - \mu_M \right) \right]&#34; /&gt;. However, in this form, it’s not too fun to work with. That’s because we have to re-compute the mean of of the positions at every point, and things will get messy before they get clean.&lt;/p&gt;
&lt;p&gt;Conceptually, however, we have a powerful tool: the &lt;a href=&#34;https://en.wikipedia.org/wiki/Center-of-momentum_frame&#34;&gt;Center of Mass frame&lt;/a&gt;. Essentially, because our system has no external forces (and no net acceleration), we can &lt;em&gt;perform a &lt;a href=&#34;https://en.wikipedia.org/wiki/Galilean_transformation&#34;&gt;Galilean transform&lt;/a&gt;&lt;/em&gt; into a frame of reference where the center of mass is &lt;em&gt;fixed at the origin&lt;/em&gt;, and &lt;em&gt;never changes&lt;/em&gt;. If we can do this, then we only need to compute &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Cmathrm%7BTr%7D%20%5Cleft%28M%5ET%20M%20%5Cright%29&#34; alt=&#34;\mathrm{Tr} \left(M^T M \right)&#34; title=&#34;\mathrm{Tr} \left(M^T M \right)&#34; /&gt; (since we guarantee that the mean of &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?M&#34; alt=&#34;M&#34; title=&#34;M&#34; /&gt; is 0), which is relatively easy peasy.&lt;/p&gt;
&lt;p&gt;Because our system has points of all equal “mass”, we can shift &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?R&#34; alt=&#34;R&#34; title=&#34;R&#34; /&gt; into &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Chat%7BR%7D&#34; alt=&#34;\hat{R}&#34; title=&#34;\hat{R}&#34; /&gt; (&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?R&#34; alt=&#34;R&#34; title=&#34;R&#34; /&gt; shifted into the center of mass frame) and &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?V&#34; alt=&#34;V&#34; title=&#34;V&#34; /&gt; into &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Chat%7BV%7D&#34; alt=&#34;\hat{V}&#34; title=&#34;\hat{V}&#34; /&gt; by just subtracting by the &lt;em&gt;initial&lt;/em&gt; mean:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Chat%7BR%7D%20%26%20%3D%20R%20-%20%5Cmu_R%20%5C%5C%0A%5Chat%7BV%7D%20%26%20%3D%20V%20-%20%5Cmu_V%0A%5Cend%7Baligned%7D%0A&#34; alt=&#34;
\begin{aligned}
\hat{R} &amp;amp; = R - \mu_R \\
\hat{V} &amp;amp; = V - \mu_V
\end{aligned}
&#34; title=&#34;
\begin{aligned}
\hat{R} &amp;amp; = R - \mu_R \\
\hat{V} &amp;amp; = V - \mu_V
\end{aligned}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;This means that our formula for variance at time T is now simple to manipulate. Because we now know that center of mass &lt;em&gt;is always zero&lt;/em&gt;, we can compute the sum of variance as:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0A%5Clvert%20%5CSigma%28t%29%20%5Crvert%20%3D%20%5Cmathrm%7BTr%7D%20%5Cleft%5B%20%5Cleft%28%20%5Chat%7BR%7D%20%2B%20%5Chat%7BV%7D%20t%20%5Cright%29%5ET%20%5Cleft%28%20%5Chat%7BR%7D%20%2B%20%5Chat%7BV%7D%20t%20%5Cright%29%20%5Cright%5D%0A&#34; alt=&#34;
\lvert \Sigma(t) \rvert = \mathrm{Tr} \left[ \left( \hat{R} + \hat{V} t \right)^T \left( \hat{R} + \hat{V} t \right) \right]
&#34; title=&#34;
\lvert \Sigma(t) \rvert = \mathrm{Tr} \left[ \left( \hat{R} + \hat{V} t \right)^T \left( \hat{R} + \hat{V} t \right) \right]
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;We can do some simplification, remembering that the trace distributes over addition, and that &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%5Cmathrm%7BTr%7D%20%5Cleft%28%20X%5ET%20Y%20%5Cright%29%20%3D%20%5Cmathrm%7BTr%7D%20%5Cleft%20%28Y%5ET%20X%20%5Cright%29&#34; alt=&#34;\mathrm{Tr} \left( X^T Y \right) = \mathrm{Tr} \left (Y^T X \right)&#34; title=&#34;\mathrm{Tr} \left( X^T Y \right) = \mathrm{Tr} \left (Y^T X \right)&#34; /&gt;:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0A%5Clvert%20%5CSigma%28t%29%20%5Crvert%20%3D%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BR%7D%5ET%20%5Chat%7BR%7D%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2B%202%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BR%7D%5ET%20%5Chat%7BV%7D%29%20t%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2B%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BV%7D%5ET%20%5Chat%7BV%7D%29%20t%5E2%0A&#34; alt=&#34;
\lvert \Sigma(t) \rvert = \mathrm{Tr} (\hat{R}^T \hat{R})
                   + 2 \mathrm{Tr} (\hat{R}^T \hat{V}) t
                   + \mathrm{Tr} (\hat{V}^T \hat{V}) t^2
&#34; title=&#34;
\lvert \Sigma(t) \rvert = \mathrm{Tr} (\hat{R}^T \hat{R})
                   + 2 \mathrm{Tr} (\hat{R}^T \hat{V}) t
                   + \mathrm{Tr} (\hat{V}^T \hat{V}) t^2
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Now, we want to minimize the sum of variances. So to do that, we can take the first derivative with respect to &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t&#34; alt=&#34;t&#34; title=&#34;t&#34; /&gt;, and set it to be zero:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0A%5Cbegin%7Baligned%7D%0A%5Cfrac%7Bd%7D%7Bd%20t%7D%20%5Clvert%20%5CSigma%28t%29%20%5Crvert%20%26%20%3D%202%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BR%7D%5ET%20%5Chat%7BV%7D%29%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2B%202%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BV%7D%5ET%20%5Chat%7BV%7D%29%20t%20%5C%5C%0A0%20%26%20%3D%202%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BR%7D%5ET%20%5Chat%7BV%7D%29%20%2B%202%20%5Cmathrm%7BTr%7D%20%28%5Chat%7BV%7D%5ET%20%5Chat%7BV%7D%29%20t_f%20%5C%5C%0At_f%20%26%20%3D%20-%20%5Cfrac%7B%5Cmathrm%7BTr%7D%20%28%5Chat%7BR%7D%5ET%20%5Chat%7BV%7D%29%7D%7B%5Cmathrm%7BTr%7D%28%5Chat%7BV%7D%5ET%20%5Chat%7BV%7D%29%7D%0A%5Cend%7Baligned%7D%0A&#34; alt=&#34;
\begin{aligned}
\frac{d}{d t} \lvert \Sigma(t) \rvert &amp;amp; = 2 \mathrm{Tr} (\hat{R}^T \hat{V})
                                  + 2 \mathrm{Tr} (\hat{V}^T \hat{V}) t \\
0 &amp;amp; = 2 \mathrm{Tr} (\hat{R}^T \hat{V}) + 2 \mathrm{Tr} (\hat{V}^T \hat{V}) t_f \\
t_f &amp;amp; = - \frac{\mathrm{Tr} (\hat{R}^T \hat{V})}{\mathrm{Tr}(\hat{V}^T \hat{V})}
\end{aligned}
&#34; title=&#34;
\begin{aligned}
\frac{d}{d t} \lvert \Sigma(t) \rvert &amp;amp; = 2 \mathrm{Tr} (\hat{R}^T \hat{V})
                                  + 2 \mathrm{Tr} (\hat{V}^T \hat{V}) t \\
0 &amp;amp; = 2 \mathrm{Tr} (\hat{R}^T \hat{V}) + 2 \mathrm{Tr} (\hat{V}^T \hat{V}) t_f \\
t_f &amp;amp; = - \frac{\mathrm{Tr} (\hat{R}^T \hat{V})}{\mathrm{Tr}(\hat{V}^T \hat{V})}
\end{aligned}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;And just like that, we have a formula for &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t_f&#34; alt=&#34;t_f&#34; title=&#34;t_f&#34; /&gt;!&lt;/p&gt;
&lt;p&gt;We can simplify this a little more by remembering that the trace of a matrix multiplication is the sum of the dot products of the columns of the first matrix by the rows of the second. That means we can write:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0At_f%20%3D%20-%20%5Cfrac%7B%5Csum_i%20%5Chat%7B%5Cmathbf%7Br%7D%7D_i%20%5Ccdot%20%5Chat%7B%5Cmathbf%7Bv%7D%7D_i%7D%7B%5Csum_i%20%5Chat%7B%5Cmathbf%7Bv%7D%7D_i%20%5Ccdot%20%5Chat%7B%5Cmathbf%7Bv%7D%7D_i%7D%0A&#34; alt=&#34;
t_f = - \frac{\sum_i \hat{\mathbf{r}}_i \cdot \hat{\mathbf{v}}_i}{\sum_i \hat{\mathbf{v}}_i \cdot \hat{\mathbf{v}}_i}
&#34; title=&#34;
t_f = - \frac{\sum_i \hat{\mathbf{r}}_i \cdot \hat{\mathbf{v}}_i}{\sum_i \hat{\mathbf{v}}_i \cdot \hat{\mathbf{v}}_i}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;Once we find this, we can plug into our original form, to find that our final points are, in our un-shifted coordinates, &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?R%20%2B%20V%20t_f&#34; alt=&#34;R + V t_f&#34; title=&#34;R + V t_f&#34; /&gt;. This is because Galilean transformations leave time unchanged, unlike other frame transformations, like the Lorentz transform. However, we have a simpler option: we could just leave our answer in shifted coordinates as well, since we only care about the shape of the result, and not the absolute position.&lt;/p&gt;
&lt;p&gt;We can write this as a Haskell function, assuming we take in a list of &lt;code&gt;V2 Double&lt;/code&gt; for velocities and &lt;code&gt;V2 Double&lt;/code&gt; for positions, from the &lt;em&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Center-of-momentum_frame&#34;&gt;linear&lt;/a&gt;&lt;/em&gt; library:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode haskell&#34;&gt;&lt;code class=&#34;sourceCode haskell&#34;&gt;&lt;span id=&#34;cb3-1&#34;&gt;&lt;a href=&#34;#cb3-1&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Shift so that centroid is at zero&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-2&#34;&gt;&lt;a href=&#34;#cb3-2&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;centralize ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;]&lt;/span&gt;
&lt;span id=&#34;cb3-3&#34;&gt;&lt;a href=&#34;#cb3-3&#34;&gt;&lt;/a&gt;centralize ps &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;map&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;subtract&lt;/span&gt; mean) ps&lt;/span&gt;
&lt;span id=&#34;cb3-4&#34;&gt;&lt;a href=&#34;#cb3-4&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-5&#34;&gt;&lt;a href=&#34;#cb3-5&#34;&gt;&lt;/a&gt;    mean &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; ps &lt;span class=&#34;op&#34;&gt;L.^/&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;fromIntegral&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;length&lt;/span&gt; ps)&lt;/span&gt;
&lt;span id=&#34;cb3-6&#34;&gt;&lt;a href=&#34;#cb3-6&#34;&gt;&lt;/a&gt;                &lt;span class=&#34;co&#34;&gt;-- ^ component-wise division&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-7&#34;&gt;&lt;a href=&#34;#cb3-7&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-8&#34;&gt;&lt;a href=&#34;#cb3-8&#34;&gt;&lt;/a&gt;&lt;span class=&#34;co&#34;&gt;-- | Sum of dot products&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-9&#34;&gt;&lt;a href=&#34;#cb3-9&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;sumOfDots ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;] &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-10&#34;&gt;&lt;a href=&#34;#cb3-10&#34;&gt;&lt;/a&gt;sumOfDots xs ys &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;sum&lt;/span&gt; (&lt;span class=&#34;fu&#34;&gt;zipWith&lt;/span&gt; L.dot xs ys)&lt;/span&gt;
&lt;span id=&#34;cb3-11&#34;&gt;&lt;a href=&#34;#cb3-11&#34;&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-12&#34;&gt;&lt;a href=&#34;#cb3-12&#34;&gt;&lt;/a&gt;findWord&lt;/span&gt;
&lt;span id=&#34;cb3-13&#34;&gt;&lt;a href=&#34;#cb3-13&#34;&gt;&lt;/a&gt;&lt;span class=&#34;ot&#34;&gt;    ::&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;]              &lt;span class=&#34;co&#34;&gt;-- ^ velocities&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-14&#34;&gt;&lt;a href=&#34;#cb3-14&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; [&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;]              &lt;span class=&#34;co&#34;&gt;-- ^ initial positions&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-15&#34;&gt;&lt;a href=&#34;#cb3-15&#34;&gt;&lt;/a&gt;    &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; ([&lt;span class=&#34;dt&#34;&gt;V2&lt;/span&gt; &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;], &lt;span class=&#34;dt&#34;&gt;Double&lt;/span&gt;)    &lt;span class=&#34;co&#34;&gt;-- ^ points in word, and final time t&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-16&#34;&gt;&lt;a href=&#34;#cb3-16&#34;&gt;&lt;/a&gt;findWord (centralize&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;vs) (centralize&lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt;xs) &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; (final, t)&lt;/span&gt;
&lt;span id=&#34;cb3-17&#34;&gt;&lt;a href=&#34;#cb3-17&#34;&gt;&lt;/a&gt;  &lt;span class=&#34;kw&#34;&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id=&#34;cb3-18&#34;&gt;&lt;a href=&#34;#cb3-18&#34;&gt;&lt;/a&gt;    t     &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;negate&lt;/span&gt; (sumOfDots xs vs &lt;span class=&#34;op&#34;&gt;/&lt;/span&gt; sumOfDots vs vs)&lt;/span&gt;
&lt;span id=&#34;cb3-19&#34;&gt;&lt;a href=&#34;#cb3-19&#34;&gt;&lt;/a&gt;    final &lt;span class=&#34;ot&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;fu&#34;&gt;zipWith&lt;/span&gt; (\v x &lt;span class=&#34;ot&#34;&gt;-&amp;gt;&lt;/span&gt; x &lt;span class=&#34;op&#34;&gt;+&lt;/span&gt; t &lt;span class=&#34;op&#34;&gt;L.*^&lt;/span&gt; v) vs xs&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We don’t even need to round the answer — we can directly make a scatter plot of these points and read off what they look like :)&lt;/p&gt;
&lt;h2 id=&#34;part-2&#34;&gt;Part 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Good thing you didn’t have to wait, because that would have taken a long time - much longer than the &lt;code&gt;3&lt;/code&gt; seconds in the example above.&lt;/p&gt;
&lt;p&gt;Impressed by your sub-hour communication capabilities, the Elves are curious: &lt;em&gt;exactly how many seconds would they have needed to wait for that message to appear?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This one is just &lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?t&#34; alt=&#34;t&#34; title=&#34;t&#34; /&gt;, which we solved for in the last part! This time, we do need to remember to &lt;code&gt;round&lt;/code&gt; it before we submit.&lt;/p&gt;
&lt;h2 id=&#34;message-in-the-stars&#34;&gt;Message in the Stars&lt;/h2&gt;
&lt;p&gt;Optimization by finding the first derivative is a common tool in math that is definitely under-utilized! In practice, unless we have a really clean system, we won’t be able to analytically “solve for zero” in most situations. However, this system shows all of the signs of being well-behaved: the thing we are minimizing is quadratic on our variable, so the first derivative will be linear on our variable, making “solving for zero” very simple.&lt;/p&gt;
&lt;p&gt;To do this in a clean way we:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Represented our system as a matrix formula, giving us key linear algebra insights we could exploit.&lt;/li&gt;
&lt;li&gt;Saw that our problem is feasible, because our thing we are minimizing is quadratic in our variable, meaning the derivative is linear in our variable.&lt;/li&gt;
&lt;li&gt;Made this feasible by using a Galilean transform to shift things into the center-of-mass frame, so that the mean is &lt;em&gt;fixed&lt;/em&gt; over the entire time span, and &lt;em&gt;set to zero&lt;/em&gt;. This made the final solution simple enough to work out on a small sheet of notebook paper.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;And isn’t it cute that we use the &lt;em&gt;Galilean&lt;/em&gt; transform, named after someone who is famous for having studied the motion of astronomical bodies? Maybe that was a subtle hint from the author of the challenges ;)&lt;/p&gt;
&lt;p&gt;Anyway, I thought this was a fun twist on the typical Advent of Code challenges. It’s always fun when something that you might think can only be solved by simulation turns out to have a closed-form solution…but even more fun when the closed-form solution turns out to just be simple linear algebra:&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;img style=&#34;vertical-align:middle&#34; src=&#34;https://latex.codecogs.com/png.latex?%0At_f%20%3D%20-%20%5Cfrac%7B%5Csum_i%20%5Chat%7B%5Cmathbf%7Br%7D%7D_i%20%5Ccdot%20%5Chat%7B%5Cmathbf%7Bv%7D%7D_i%7D%7B%5Csum_i%20%5Chat%7B%5Cmathbf%7Bv%7D%7D_i%20%5Ccdot%20%5Chat%7B%5Cmathbf%7Bv%7D%7D_i%7D%0A&#34; alt=&#34;
t_f = - \frac{\sum_i \hat{\mathbf{r}}_i \cdot \hat{\mathbf{v}}_i}{\sum_i \hat{\mathbf{v}}_i \cdot \hat{\mathbf{v}}_i}
&#34; title=&#34;
t_f = - \frac{\sum_i \hat{\mathbf{r}}_i \cdot \hat{\mathbf{v}}_i}{\sum_i \hat{\mathbf{v}}_i \cdot \hat{\mathbf{v}}_i}
&#34; /&gt;&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;“It’s just dot products all the way down.”&lt;/p&gt;</description><author>Justin Le</author><category>Math</category><guid isPermaLink="true">https://blog.jle.im/entry/shifting-the-stars.html</guid><pubDate>Tue, 11 Dec 2018 00:34:37 UTC</pubDate><creator>Justin Le</creator><subject>Math</subject><date>2018-12-11</date></item><language>en</language><copyright>Copyright 2020 Justin Le</copyright><managingEditor>justin@jle.im (Justin Le)</managingEditor><webMaster>justin@jle.im (Justin Le)</webMaster><lastBuildDate>Fri,  4 Dec 2020 02:03:16 UTC</lastBuildDate><generator>feed-1.0.0.0 (Sigbjorn Finne)</generator><image><url>https://blog.jle.im/img/site_logo.jpg</url><title>in Code</title><link>https://blog.jle.im/</link></image><creator>Justin Le</creator><language>en</language><rights>Copyright 2020 Justin Le</rights><date>2020-12-04</date><description>Weblog of Justin Le, covering various adventures in programming and explorations in the worlds of computation physics, and knowledge.
</description></channel></rss>